{"ast":null,"code":"import { point } from \"@turf/helpers\";\n/**\n * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring},\n * {@link MultiPolygon|multi-polygon} or {@link Polygon|polygon} and\n * returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = turf.polygon([[\n *   [-12.034835, 8.901183],\n *   [-12.060413, 8.899826],\n *   [-12.03638, 8.873199],\n *   [-12.059383, 8.871418],\n *   [-12.034835, 8.901183]\n * ]]);\n *\n * var kinks = turf.kinks(poly);\n *\n * //addToMap\n * var addToMap = [poly, kinks]\n */\nexport default function kinks(featureIn) {\n  var coordinates;\n  var feature;\n  var results = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  if (featureIn.type === \"Feature\") {\n    feature = featureIn.geometry;\n  } else {\n    feature = featureIn;\n  }\n  if (feature.type === \"LineString\") {\n    coordinates = [feature.coordinates];\n  } else if (feature.type === \"MultiLineString\") {\n    coordinates = feature.coordinates;\n  } else if (feature.type === \"MultiPolygon\") {\n    coordinates = [].concat.apply([], feature.coordinates);\n  } else if (feature.type === \"Polygon\") {\n    coordinates = feature.coordinates;\n  } else {\n    throw new Error(\"Input must be a LineString, MultiLineString, \" + \"Polygon, or MultiPolygon Feature or Geometry\");\n  }\n  coordinates.forEach(function (line1) {\n    coordinates.forEach(function (line2) {\n      for (var i = 0; i < line1.length - 1; i++) {\n        // start iteration at i, intersections for k < i have already\n        // been checked in previous outer loop iterations\n        for (var k = i; k < line2.length - 1; k++) {\n          if (line1 === line2) {\n            // segments are adjacent and always share a vertex, not a kink\n            if (Math.abs(i - k) === 1) {\n              continue;\n            }\n            // first and last segment in a closed lineString or ring always share a vertex, not a kink\n            if (\n            // segments are first and last segment of lineString\n            i === 0 && k === line1.length - 2 &&\n            // lineString is closed\n            line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]) {\n              continue;\n            }\n          }\n          var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n          if (intersection) {\n            results.features.push(point([intersection[0], intersection[1]]));\n          }\n        }\n      }\n    });\n  });\n  return results;\n}\n// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  // if the lines intersect, the result contains the x and y of the\n  // intersection (treating the lines as infinite) and booleans for whether\n  // line segment 1 or line segment 2 contain the point\n  var denominator;\n  var a;\n  var b;\n  var numerator1;\n  var numerator2;\n  var result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n  if (denominator === 0) {\n    if (result.x !== null && result.y !== null) {\n      return result;\n    } else {\n      return false;\n    }\n  }\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n  // if we cast these lines infinitely in both directions, they intersect here:\n  result.x = line1StartX + a * (line1EndX - line1StartX);\n  result.y = line1StartY + a * (line1EndY - line1StartY);\n  // if line1 is a segment and line2 is infinite, they intersect if:\n  if (a >= 0 && a <= 1) {\n    result.onLine1 = true;\n  }\n  // if line2 is a segment and line1 is infinite, they intersect if:\n  if (b >= 0 && b <= 1) {\n    result.onLine2 = true;\n  }\n  // if line1 and line2 are segments, they intersect if both of the above are true\n  if (result.onLine1 && result.onLine2) {\n    return [result.x, result.y];\n  } else {\n    return false;\n  }\n}","map":{"version":3,"names":["point","kinks","featureIn","coordinates","feature","results","type","features","geometry","concat","apply","Error","forEach","line1","line2","i","length","k","Math","abs","intersection","lineIntersects","push","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","a","b","numerator1","numerator2","result","x","y","onLine1","onLine2"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/kinks/dist/es/index.js"],"sourcesContent":["import { point } from \"@turf/helpers\";\n/**\n * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring},\n * {@link MultiPolygon|multi-polygon} or {@link Polygon|polygon} and\n * returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = turf.polygon([[\n *   [-12.034835, 8.901183],\n *   [-12.060413, 8.899826],\n *   [-12.03638, 8.873199],\n *   [-12.059383, 8.871418],\n *   [-12.034835, 8.901183]\n * ]]);\n *\n * var kinks = turf.kinks(poly);\n *\n * //addToMap\n * var addToMap = [poly, kinks]\n */\nexport default function kinks(featureIn) {\n    var coordinates;\n    var feature;\n    var results = {\n        type: \"FeatureCollection\",\n        features: [],\n    };\n    if (featureIn.type === \"Feature\") {\n        feature = featureIn.geometry;\n    }\n    else {\n        feature = featureIn;\n    }\n    if (feature.type === \"LineString\") {\n        coordinates = [feature.coordinates];\n    }\n    else if (feature.type === \"MultiLineString\") {\n        coordinates = feature.coordinates;\n    }\n    else if (feature.type === \"MultiPolygon\") {\n        coordinates = [].concat.apply([], feature.coordinates);\n    }\n    else if (feature.type === \"Polygon\") {\n        coordinates = feature.coordinates;\n    }\n    else {\n        throw new Error(\"Input must be a LineString, MultiLineString, \" +\n            \"Polygon, or MultiPolygon Feature or Geometry\");\n    }\n    coordinates.forEach(function (line1) {\n        coordinates.forEach(function (line2) {\n            for (var i = 0; i < line1.length - 1; i++) {\n                // start iteration at i, intersections for k < i have already\n                // been checked in previous outer loop iterations\n                for (var k = i; k < line2.length - 1; k++) {\n                    if (line1 === line2) {\n                        // segments are adjacent and always share a vertex, not a kink\n                        if (Math.abs(i - k) === 1) {\n                            continue;\n                        }\n                        // first and last segment in a closed lineString or ring always share a vertex, not a kink\n                        if (\n                        // segments are first and last segment of lineString\n                        i === 0 &&\n                            k === line1.length - 2 &&\n                            // lineString is closed\n                            line1[i][0] === line1[line1.length - 1][0] &&\n                            line1[i][1] === line1[line1.length - 1][1]) {\n                            continue;\n                        }\n                    }\n                    var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n                    if (intersection) {\n                        results.features.push(point([intersection[0], intersection[1]]));\n                    }\n                }\n            }\n        });\n    });\n    return results;\n}\n// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n    // if the lines intersect, the result contains the x and y of the\n    // intersection (treating the lines as infinite) and booleans for whether\n    // line segment 1 or line segment 2 contain the point\n    var denominator;\n    var a;\n    var b;\n    var numerator1;\n    var numerator2;\n    var result = {\n        x: null,\n        y: null,\n        onLine1: false,\n        onLine2: false,\n    };\n    denominator =\n        (line2EndY - line2StartY) * (line1EndX - line1StartX) -\n            (line2EndX - line2StartX) * (line1EndY - line1StartY);\n    if (denominator === 0) {\n        if (result.x !== null && result.y !== null) {\n            return result;\n        }\n        else {\n            return false;\n        }\n    }\n    a = line1StartY - line2StartY;\n    b = line1StartX - line2StartX;\n    numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n    numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n    // if we cast these lines infinitely in both directions, they intersect here:\n    result.x = line1StartX + a * (line1EndX - line1StartX);\n    result.y = line1StartY + a * (line1EndY - line1StartY);\n    // if line1 is a segment and line2 is infinite, they intersect if:\n    if (a >= 0 && a <= 1) {\n        result.onLine1 = true;\n    }\n    // if line2 is a segment and line1 is infinite, they intersect if:\n    if (b >= 0 && b <= 1) {\n        result.onLine2 = true;\n    }\n    // if line1 and line2 are segments, they intersect if both of the above are true\n    if (result.onLine1 && result.onLine2) {\n        return [result.x, result.y];\n    }\n    else {\n        return false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}