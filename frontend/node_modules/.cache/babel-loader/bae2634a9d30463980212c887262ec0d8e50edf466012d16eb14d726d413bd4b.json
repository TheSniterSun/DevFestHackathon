{"ast":null,"code":"import bearing from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\n/**\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\n *\n * @name angle\n * @param {Coord} startPoint Start Point Coordinates\n * @param {Coord} midPoint Mid Point Coordinates\n * @param {Coord} endPoint End Point Coordinates\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\n * @returns {number} Angle between the provided points, or its explementary.\n * @example\n * turf.angle([5, 5], [5, 6], [3, 4]);\n * //=45\n */\nfunction angle(startPoint, midPoint, endPoint, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Optional Parameters\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  // Validation\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  }\n  // Rename to shorter variables\n  var A = startPoint;\n  var O = midPoint;\n  var B = endPoint;\n  // Main\n  var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));\n  var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O));\n  var angleAO = Math.abs(azimuthAO - azimuthBO);\n  // Explementary angle\n  if (options.explementary === true) {\n    return 360 - angleAO;\n  }\n  return angleAO;\n}\nexport default angle;","map":{"version":3,"names":["bearing","bearingToAzimuth","isObject","rhumbBearing","angle","startPoint","midPoint","endPoint","options","Error","A","O","B","azimuthAO","mercator","azimuthBO","angleAO","Math","abs","explementary"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/angle/dist/es/index.js"],"sourcesContent":["import bearing from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\n/**\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\n *\n * @name angle\n * @param {Coord} startPoint Start Point Coordinates\n * @param {Coord} midPoint Mid Point Coordinates\n * @param {Coord} endPoint End Point Coordinates\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\n * @returns {number} Angle between the provided points, or its explementary.\n * @example\n * turf.angle([5, 5], [5, 6], [3, 4]);\n * //=45\n */\nfunction angle(startPoint, midPoint, endPoint, options) {\n    if (options === void 0) { options = {}; }\n    // Optional Parameters\n    if (!isObject(options)) {\n        throw new Error(\"options is invalid\");\n    }\n    // Validation\n    if (!startPoint) {\n        throw new Error(\"startPoint is required\");\n    }\n    if (!midPoint) {\n        throw new Error(\"midPoint is required\");\n    }\n    if (!endPoint) {\n        throw new Error(\"endPoint is required\");\n    }\n    // Rename to shorter variables\n    var A = startPoint;\n    var O = midPoint;\n    var B = endPoint;\n    // Main\n    var azimuthAO = bearingToAzimuth(options.mercator !== true ? bearing(A, O) : rhumbBearing(A, O));\n    var azimuthBO = bearingToAzimuth(options.mercator !== true ? bearing(B, O) : rhumbBearing(B, O));\n    var angleAO = Math.abs(azimuthAO - azimuthBO);\n    // Explementary angle\n    if (options.explementary === true) {\n        return 360 - angleAO;\n    }\n    return angleAO;\n}\nexport default angle;\n"],"mappings":"AAAA,OAAOA,OAAO,MAAM,eAAe;AACnC,SAASC,gBAAgB,EAAEC,QAAQ,QAAQ,eAAe;AAC1D,OAAOC,YAAY,MAAM,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAACC,UAAU,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EACpD,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC;EACA,IAAI,CAACN,QAAQ,CAACM,OAAO,CAAC,EAAE;IACpB,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EACzC;EACA;EACA,IAAI,CAACJ,UAAU,EAAE;IACb,MAAM,IAAII,KAAK,CAAC,wBAAwB,CAAC;EAC7C;EACA,IAAI,CAACH,QAAQ,EAAE;IACX,MAAM,IAAIG,KAAK,CAAC,sBAAsB,CAAC;EAC3C;EACA,IAAI,CAACF,QAAQ,EAAE;IACX,MAAM,IAAIE,KAAK,CAAC,sBAAsB,CAAC;EAC3C;EACA;EACA,IAAIC,CAAC,GAAGL,UAAU;EAClB,IAAIM,CAAC,GAAGL,QAAQ;EAChB,IAAIM,CAAC,GAAGL,QAAQ;EAChB;EACA,IAAIM,SAAS,GAAGZ,gBAAgB,CAACO,OAAO,CAACM,QAAQ,KAAK,IAAI,GAAGd,OAAO,CAACU,CAAC,EAAEC,CAAC,CAAC,GAAGR,YAAY,CAACO,CAAC,EAAEC,CAAC,CAAC,CAAC;EAChG,IAAII,SAAS,GAAGd,gBAAgB,CAACO,OAAO,CAACM,QAAQ,KAAK,IAAI,GAAGd,OAAO,CAACY,CAAC,EAAED,CAAC,CAAC,GAAGR,YAAY,CAACS,CAAC,EAAED,CAAC,CAAC,CAAC;EAChG,IAAIK,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACL,SAAS,GAAGE,SAAS,CAAC;EAC7C;EACA,IAAIP,OAAO,CAACW,YAAY,KAAK,IAAI,EAAE;IAC/B,OAAO,GAAG,GAAGH,OAAO;EACxB;EACA,OAAOA,OAAO;AAClB;AACA,eAAeZ,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}