{"ast":null,"code":"import { orientationIndex, envelopeIsEqual, envelopeContains, coordinatesEqual } from \"./util.js\";\nimport { multiPoint, polygon, point } from \"@turf/helpers\";\nimport envelope from \"@turf/envelope\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\n/**\n * Ring of edges which form a polygon.\n *\n * The ring may be either an outer shell or a hole.\n *\n * This class is inspired in GEOS's geos::operation::polygonize::EdgeRing\n */\nvar EdgeRing = /** @class */function () {\n  function EdgeRing() {\n    this.edges = [];\n    this.polygon = undefined; //< Caches Polygon representation\n    this.envelope = undefined; //< Caches Envelope representation\n  }\n  /**\n   * Add an edge to the ring, inserting it in the last position.\n   *\n   * @memberof EdgeRing\n   * @param {Edge} edge - Edge to be inserted\n   */\n  EdgeRing.prototype.push = function (edge) {\n    this.edges.push(edge);\n    this.polygon = this.envelope = undefined;\n  };\n  /**\n   * Get Edge.\n   *\n   * @memberof EdgeRing\n   * @param {number} i - Index\n   * @returns {Edge} - Edge in the i position\n   */\n  EdgeRing.prototype.get = function (i) {\n    return this.edges[i];\n  };\n  Object.defineProperty(EdgeRing.prototype, \"length\", {\n    /**\n     * Getter of length property.\n     *\n     * @memberof EdgeRing\n     * @returns {number} - Length of the edge ring.\n     */\n    get: function () {\n      return this.edges.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.forEach\n   */\n  EdgeRing.prototype.forEach = function (f) {\n    this.edges.forEach(f);\n  };\n  /**\n   * Similar to Array.prototype.map for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.map\n   * @returns {Array} - The mapped values in the function\n   */\n  EdgeRing.prototype.map = function (f) {\n    return this.edges.map(f);\n  };\n  /**\n   * Similar to Array.prototype.some for the list of Edges in the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @param {Function} f - The same function to be passed to Array.prototype.some\n   * @returns {boolean} - True if an Edge check the condition\n   */\n  EdgeRing.prototype.some = function (f) {\n    return this.edges.some(f);\n  };\n  /**\n   * Check if the ring is valid in geomtry terms.\n   *\n   * A ring must have either 0 or 4 or more points. The first and the last must be\n   * equal (in 2D)\n   * geos::geom::LinearRing::validateConstruction\n   *\n   * @memberof EdgeRing\n   * @returns {boolean} - Validity of the EdgeRing\n   */\n  EdgeRing.prototype.isValid = function () {\n    // TODO: stub\n    return true;\n  };\n  /**\n   * Tests whether this ring is a hole.\n   *\n   * A ring is a hole if it is oriented counter-clockwise.\n   * Similar implementation of geos::algorithm::CGAlgorithms::isCCW\n   *\n   * @memberof EdgeRing\n   * @returns {boolean} - true: if it is a hole\n   */\n  EdgeRing.prototype.isHole = function () {\n    var _this = this;\n    // XXX: Assuming Ring is valid\n    // Find highest point\n    var hiIndex = this.edges.reduce(function (high, edge, i) {\n        if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1]) high = i;\n        return high;\n      }, 0),\n      iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1,\n      iNext = (hiIndex + 1) % this.length,\n      disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);\n    if (disc === 0) return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];\n    return disc > 0;\n  };\n  /**\n   * Creates a MultiPoint representing the EdgeRing (discarts edges directions).\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing\n   */\n  EdgeRing.prototype.toMultiPoint = function () {\n    return multiPoint(this.edges.map(function (edge) {\n      return edge.from.coordinates;\n    }));\n  };\n  /**\n   * Creates a Polygon representing the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring\n   */\n  EdgeRing.prototype.toPolygon = function () {\n    if (this.polygon) return this.polygon;\n    var coordinates = this.edges.map(function (edge) {\n      return edge.from.coordinates;\n    });\n    coordinates.push(this.edges[0].from.coordinates);\n    return this.polygon = polygon([coordinates]);\n  };\n  /**\n   * Calculates the envelope of the EdgeRing.\n   *\n   * @memberof EdgeRing\n   * @returns {Feature<Polygon>} - envelope\n   */\n  EdgeRing.prototype.getEnvelope = function () {\n    if (this.envelope) return this.envelope;\n    return this.envelope = envelope(this.toPolygon());\n  };\n  /**\n   * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`\n   *\n   * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list\n   * @param {EdgeRing[]} shellList - List of EdgeRing in which to search\n   *\n   * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing\n   */\n  EdgeRing.findEdgeRingContaining = function (testEdgeRing, shellList) {\n    var testEnvelope = testEdgeRing.getEnvelope();\n    var minEnvelope, minShell;\n    shellList.forEach(function (shell) {\n      var tryEnvelope = shell.getEnvelope();\n      if (minShell) minEnvelope = minShell.getEnvelope();\n      // the hole envelope cannot equal the shell envelope\n      if (envelopeIsEqual(tryEnvelope, testEnvelope)) return;\n      if (envelopeContains(tryEnvelope, testEnvelope)) {\n        var testEdgeRingCoordinates = testEdgeRing.map(function (edge) {\n          return edge.from.coordinates;\n        });\n        var testPoint = void 0;\n        var _loop_1 = function (pt) {\n          if (!shell.some(function (edge) {\n            return coordinatesEqual(pt, edge.from.coordinates);\n          })) {\n            testPoint = pt;\n          }\n        };\n        for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {\n          var pt = testEdgeRingCoordinates_1[_i];\n          _loop_1(pt);\n        }\n        if (testPoint && shell.inside(point(testPoint))) {\n          if (!minShell || envelopeContains(minEnvelope, tryEnvelope)) minShell = shell;\n        }\n      }\n    });\n    return minShell;\n  };\n  /**\n   * Checks if the point is inside the edgeRing\n   *\n   * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing\n   * @returns {boolean} - True if it is inside, False otherwise\n   */\n  EdgeRing.prototype.inside = function (pt) {\n    return booleanPointInPolygon(pt, this.toPolygon());\n  };\n  return EdgeRing;\n}();\nexport default EdgeRing;","map":{"version":3,"names":["orientationIndex","envelopeIsEqual","envelopeContains","coordinatesEqual","multiPoint","polygon","point","envelope","booleanPointInPolygon","EdgeRing","edges","undefined","prototype","push","edge","get","i","Object","defineProperty","length","enumerable","configurable","forEach","f","map","some","isValid","isHole","_this","hiIndex","reduce","high","from","coordinates","iPrev","iNext","disc","toMultiPoint","toPolygon","getEnvelope","findEdgeRingContaining","testEdgeRing","shellList","testEnvelope","minEnvelope","minShell","shell","tryEnvelope","testEdgeRingCoordinates","testPoint","_loop_1","pt","_i","testEdgeRingCoordinates_1","inside"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js"],"sourcesContent":["import { orientationIndex, envelopeIsEqual, envelopeContains, coordinatesEqual, } from \"./util.js\";\nimport { multiPoint, polygon, point, } from \"@turf/helpers\";\nimport envelope from \"@turf/envelope\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\n/**\n * Ring of edges which form a polygon.\n *\n * The ring may be either an outer shell or a hole.\n *\n * This class is inspired in GEOS's geos::operation::polygonize::EdgeRing\n */\nvar EdgeRing = /** @class */ (function () {\n    function EdgeRing() {\n        this.edges = [];\n        this.polygon = undefined; //< Caches Polygon representation\n        this.envelope = undefined; //< Caches Envelope representation\n    }\n    /**\n     * Add an edge to the ring, inserting it in the last position.\n     *\n     * @memberof EdgeRing\n     * @param {Edge} edge - Edge to be inserted\n     */\n    EdgeRing.prototype.push = function (edge) {\n        this.edges.push(edge);\n        this.polygon = this.envelope = undefined;\n    };\n    /**\n     * Get Edge.\n     *\n     * @memberof EdgeRing\n     * @param {number} i - Index\n     * @returns {Edge} - Edge in the i position\n     */\n    EdgeRing.prototype.get = function (i) {\n        return this.edges[i];\n    };\n    Object.defineProperty(EdgeRing.prototype, \"length\", {\n        /**\n         * Getter of length property.\n         *\n         * @memberof EdgeRing\n         * @returns {number} - Length of the edge ring.\n         */\n        get: function () {\n            return this.edges.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @param {Function} f - The same function to be passed to Array.prototype.forEach\n     */\n    EdgeRing.prototype.forEach = function (f) {\n        this.edges.forEach(f);\n    };\n    /**\n     * Similar to Array.prototype.map for the list of Edges in the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @param {Function} f - The same function to be passed to Array.prototype.map\n     * @returns {Array} - The mapped values in the function\n     */\n    EdgeRing.prototype.map = function (f) {\n        return this.edges.map(f);\n    };\n    /**\n     * Similar to Array.prototype.some for the list of Edges in the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @param {Function} f - The same function to be passed to Array.prototype.some\n     * @returns {boolean} - True if an Edge check the condition\n     */\n    EdgeRing.prototype.some = function (f) {\n        return this.edges.some(f);\n    };\n    /**\n     * Check if the ring is valid in geomtry terms.\n     *\n     * A ring must have either 0 or 4 or more points. The first and the last must be\n     * equal (in 2D)\n     * geos::geom::LinearRing::validateConstruction\n     *\n     * @memberof EdgeRing\n     * @returns {boolean} - Validity of the EdgeRing\n     */\n    EdgeRing.prototype.isValid = function () {\n        // TODO: stub\n        return true;\n    };\n    /**\n     * Tests whether this ring is a hole.\n     *\n     * A ring is a hole if it is oriented counter-clockwise.\n     * Similar implementation of geos::algorithm::CGAlgorithms::isCCW\n     *\n     * @memberof EdgeRing\n     * @returns {boolean} - true: if it is a hole\n     */\n    EdgeRing.prototype.isHole = function () {\n        var _this = this;\n        // XXX: Assuming Ring is valid\n        // Find highest point\n        var hiIndex = this.edges.reduce(function (high, edge, i) {\n            if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])\n                high = i;\n            return high;\n        }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);\n        if (disc === 0)\n            return (this.edges[iPrev].from.coordinates[0] >\n                this.edges[iNext].from.coordinates[0]);\n        return disc > 0;\n    };\n    /**\n     * Creates a MultiPoint representing the EdgeRing (discarts edges directions).\n     *\n     * @memberof EdgeRing\n     * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing\n     */\n    EdgeRing.prototype.toMultiPoint = function () {\n        return multiPoint(this.edges.map(function (edge) { return edge.from.coordinates; }));\n    };\n    /**\n     * Creates a Polygon representing the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring\n     */\n    EdgeRing.prototype.toPolygon = function () {\n        if (this.polygon)\n            return this.polygon;\n        var coordinates = this.edges.map(function (edge) { return edge.from.coordinates; });\n        coordinates.push(this.edges[0].from.coordinates);\n        return (this.polygon = polygon([coordinates]));\n    };\n    /**\n     * Calculates the envelope of the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @returns {Feature<Polygon>} - envelope\n     */\n    EdgeRing.prototype.getEnvelope = function () {\n        if (this.envelope)\n            return this.envelope;\n        return (this.envelope = envelope(this.toPolygon()));\n    };\n    /**\n     * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`\n     *\n     * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list\n     * @param {EdgeRing[]} shellList - List of EdgeRing in which to search\n     *\n     * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing\n     */\n    EdgeRing.findEdgeRingContaining = function (testEdgeRing, shellList) {\n        var testEnvelope = testEdgeRing.getEnvelope();\n        var minEnvelope, minShell;\n        shellList.forEach(function (shell) {\n            var tryEnvelope = shell.getEnvelope();\n            if (minShell)\n                minEnvelope = minShell.getEnvelope();\n            // the hole envelope cannot equal the shell envelope\n            if (envelopeIsEqual(tryEnvelope, testEnvelope))\n                return;\n            if (envelopeContains(tryEnvelope, testEnvelope)) {\n                var testEdgeRingCoordinates = testEdgeRing.map(function (edge) { return edge.from.coordinates; });\n                var testPoint = void 0;\n                var _loop_1 = function (pt) {\n                    if (!shell.some(function (edge) { return coordinatesEqual(pt, edge.from.coordinates); })) {\n                        testPoint = pt;\n                    }\n                };\n                for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {\n                    var pt = testEdgeRingCoordinates_1[_i];\n                    _loop_1(pt);\n                }\n                if (testPoint && shell.inside(point(testPoint))) {\n                    if (!minShell || envelopeContains(minEnvelope, tryEnvelope))\n                        minShell = shell;\n                }\n            }\n        });\n        return minShell;\n    };\n    /**\n     * Checks if the point is inside the edgeRing\n     *\n     * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing\n     * @returns {boolean} - True if it is inside, False otherwise\n     */\n    EdgeRing.prototype.inside = function (pt) {\n        return booleanPointInPolygon(pt, this.toPolygon());\n    };\n    return EdgeRing;\n}());\nexport default EdgeRing;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}