{"ast":null,"code":"/**\r\n * @requires ./PriorityQueue.js\r\n */\n\nif (typeof module !== 'undefined' && module.exports) {\n  var PriorityQueue = require('./PriorityQueue.js');\n}\n\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\n  /** @type {number} */\n  this.epsilon = 1;\n  /** @type {number} */\n  this.minPts = 1;\n  /** @type {function} */\n  this.distance = this._euclideanDistance;\n\n  // temporary variables used during computation\n\n  /** @type {Array} */\n  this._reachability = [];\n  /** @type {Array} */\n  this._processed = [];\n  /** @type {number} */\n  this._coreDistance = 0;\n  /** @type {Array} */\n  this._orderedList = [];\n  this._init(dataset, epsilon, minPts, distanceFunction);\n}\n\n/******************************************************************************/\n// pulic functions\n\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\nOPTICS.prototype.run = function (dataset, epsilon, minPts, distanceFunction) {\n  this._init(dataset, epsilon, minPts, distanceFunction);\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\n    if (this._processed[pointId] !== 1) {\n      this._processed[pointId] = 1;\n      this.clusters.push([pointId]);\n      var clusterId = this.clusters.length - 1;\n      this._orderedList.push(pointId);\n      var priorityQueue = new PriorityQueue(null, null, 'asc');\n      var neighbors = this._regionQuery(pointId);\n\n      // using priority queue assign elements to new cluster\n      if (this._distanceToCore(pointId) !== undefined) {\n        this._updateQueue(pointId, neighbors, priorityQueue);\n        this._expandCluster(clusterId, priorityQueue);\n      }\n    }\n  }\n  return this.clusters;\n};\n\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\nOPTICS.prototype.getReachabilityPlot = function () {\n  var reachabilityPlot = [];\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\n    var pointId = this._orderedList[i];\n    var distance = this._reachability[pointId];\n    reachabilityPlot.push([pointId, distance]);\n  }\n  return reachabilityPlot;\n};\n\n/******************************************************************************/\n// protected functions\n\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\nOPTICS.prototype._init = function (dataset, epsilon, minPts, distance) {\n  if (dataset) {\n    if (!(dataset instanceof Array)) {\n      throw Error('Dataset must be of type array, ' + typeof dataset + ' given');\n    }\n    this.dataset = dataset;\n    this.clusters = [];\n    this._reachability = new Array(this.dataset.length);\n    this._processed = new Array(this.dataset.length);\n    this._coreDistance = 0;\n    this._orderedList = [];\n  }\n  if (epsilon) {\n    this.epsilon = epsilon;\n  }\n  if (minPts) {\n    this.minPts = minPts;\n  }\n  if (distance) {\n    this.distance = distance;\n  }\n};\n\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\nOPTICS.prototype._updateQueue = function (pointId, neighbors, queue) {\n  var self = this;\n  this._coreDistance = this._distanceToCore(pointId);\n  neighbors.forEach(function (pointId2) {\n    if (self._processed[pointId2] === undefined) {\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\n      var newReachableDistance = Math.max(self._coreDistance, dist);\n      if (self._reachability[pointId2] === undefined) {\n        self._reachability[pointId2] = newReachableDistance;\n        queue.insert(pointId2, newReachableDistance);\n      } else {\n        if (newReachableDistance < self._reachability[pointId2]) {\n          self._reachability[pointId2] = newReachableDistance;\n          queue.remove(pointId2);\n          queue.insert(pointId2, newReachableDistance);\n        }\n      }\n    }\n  });\n};\n\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\nOPTICS.prototype._expandCluster = function (clusterId, queue) {\n  var queueElements = queue.getElements();\n  for (var p = 0, l = queueElements.length; p < l; p++) {\n    var pointId = queueElements[p];\n    if (this._processed[pointId] === undefined) {\n      var neighbors = this._regionQuery(pointId);\n      this._processed[pointId] = 1;\n      this.clusters[clusterId].push(pointId);\n      this._orderedList.push(pointId);\n      if (this._distanceToCore(pointId) !== undefined) {\n        this._updateQueue(pointId, neighbors, queue);\n        this._expandCluster(clusterId, queue);\n      }\n    }\n  }\n};\n\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\nOPTICS.prototype._distanceToCore = function (pointId) {\n  var l = this.epsilon;\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\n    var neighbors = this._regionQuery(pointId, coreDistCand);\n    if (neighbors.length >= this.minPts) {\n      return coreDistCand;\n    }\n  }\n  return;\n};\n\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\nOPTICS.prototype._regionQuery = function (pointId, epsilon) {\n  epsilon = epsilon || this.epsilon;\n  var neighbors = [];\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\n      neighbors.push(id);\n    }\n  }\n  return neighbors;\n};\n\n/******************************************************************************/\n// helpers\n\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\nOPTICS.prototype._euclideanDistance = function (p, q) {\n  var sum = 0;\n  var i = Math.min(p.length, q.length);\n  while (i--) {\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n  return Math.sqrt(sum);\n};\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = OPTICS;\n}","map":{"version":3,"names":["module","exports","PriorityQueue","require","OPTICS","dataset","epsilon","minPts","distanceFunction","distance","_euclideanDistance","_reachability","_processed","_coreDistance","_orderedList","_init","prototype","run","pointId","l","length","clusters","push","clusterId","priorityQueue","neighbors","_regionQuery","_distanceToCore","undefined","_updateQueue","_expandCluster","getReachabilityPlot","reachabilityPlot","i","Array","Error","queue","self","forEach","pointId2","dist","newReachableDistance","Math","max","insert","remove","queueElements","getElements","p","coreDistCand","id","q","sum","min","sqrt"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/density-clustering/lib/OPTICS.js"],"sourcesContent":["\r\n/**\r\n * @requires ./PriorityQueue.js\r\n */\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n      var PriorityQueue = require('./PriorityQueue.js');\r\n}\r\n\r\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\r\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 1;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._reachability = [];\r\n  /** @type {Array} */\r\n  this._processed = [];\r\n  /** @type {number} */\r\n  this._coreDistance = 0;\r\n  /** @type {Array} */\r\n  this._orderedList = [];\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n}\r\n\r\n/******************************************************************************/\r\n// pulic functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nOPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\r\n    if (this._processed[pointId] !== 1) {\r\n      this._processed[pointId] = 1;\r\n      this.clusters.push([pointId]);\r\n      var clusterId = this.clusters.length - 1;\r\n\r\n      this._orderedList.push(pointId);\r\n      var priorityQueue = new PriorityQueue(null, null, 'asc');\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      // using priority queue assign elements to new cluster\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, priorityQueue);\r\n        this._expandCluster(clusterId, priorityQueue);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\r\nOPTICS.prototype.getReachabilityPlot = function() {\r\n  var reachabilityPlot = [];\r\n\r\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\r\n    var pointId = this._orderedList[i];\r\n    var distance = this._reachability[pointId];\r\n\r\n    reachabilityPlot.push([pointId, distance]);\r\n  }\r\n\r\n  return reachabilityPlot;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this._reachability = new Array(this.dataset.length);\r\n    this._processed = new Array(this.dataset.length);\r\n    this._coreDistance = 0;\r\n    this._orderedList = [];\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {\r\n  var self = this;\r\n\r\n  this._coreDistance = this._distanceToCore(pointId);\r\n  neighbors.forEach(function(pointId2) {\r\n    if (self._processed[pointId2] === undefined) {\r\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\r\n      var newReachableDistance = Math.max(self._coreDistance, dist);\r\n\r\n      if (self._reachability[pointId2] === undefined) {\r\n        self._reachability[pointId2] = newReachableDistance;\r\n        queue.insert(pointId2, newReachableDistance);\r\n      } else {\r\n        if (newReachableDistance < self._reachability[pointId2]) {\r\n          self._reachability[pointId2] = newReachableDistance;\r\n          queue.remove(pointId2);\r\n          queue.insert(pointId2, newReachableDistance);\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._expandCluster = function(clusterId, queue) {\r\n  var queueElements = queue.getElements();\r\n\r\n  for (var p = 0, l = queueElements.length; p < l; p++) {\r\n    var pointId = queueElements[p];\r\n    if (this._processed[pointId] === undefined) {\r\n      var neighbors = this._regionQuery(pointId);\r\n      this._processed[pointId] = 1;\r\n\r\n      this.clusters[clusterId].push(pointId);\r\n      this._orderedList.push(pointId);\r\n\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, queue);\r\n        this._expandCluster(clusterId, queue);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._distanceToCore = function(pointId) {\r\n  var l = this.epsilon;\r\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\r\n    var neighbors = this._regionQuery(pointId, coreDistCand);\r\n    if (neighbors.length >= this.minPts) {\r\n      return coreDistCand;\r\n    }\r\n  }\r\n\r\n  return;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nOPTICS.prototype._regionQuery = function(pointId, epsilon) {\r\n  epsilon = epsilon || this.epsilon;\r\n  var neighbors = [];\r\n\r\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\r\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = OPTICS;\r\n}\r\n"],"mappings":"AACA;AACA;AACA;;AAEA,IAAI,OAAOA,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,OAAO,EAAE;EAC/C,IAAIC,aAAa,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAEC,gBAAgB,EAAE;EAC1D;EACA,IAAI,CAACF,OAAO,GAAG,CAAC;EAChB;EACA,IAAI,CAACC,MAAM,GAAG,CAAC;EACf;EACA,IAAI,CAACE,QAAQ,GAAG,IAAI,CAACC,kBAAkB;;EAEvC;;EAEA;EACA,IAAI,CAACC,aAAa,GAAG,EAAE;EACvB;EACA,IAAI,CAACC,UAAU,GAAG,EAAE;EACpB;EACA,IAAI,CAACC,aAAa,GAAG,CAAC;EACtB;EACA,IAAI,CAACC,YAAY,GAAG,EAAE;EAEtB,IAAI,CAACC,KAAK,CAACV,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAEC,gBAAgB,CAAC;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,MAAM,CAACY,SAAS,CAACC,GAAG,GAAG,UAASZ,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAEC,gBAAgB,EAAE;EAC1E,IAAI,CAACO,KAAK,CAACV,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAEC,gBAAgB,CAAC;EAEtD,KAAK,IAAIU,OAAO,GAAG,CAAC,EAAEC,CAAC,GAAG,IAAI,CAACd,OAAO,CAACe,MAAM,EAAEF,OAAO,GAAGC,CAAC,EAAED,OAAO,EAAE,EAAE;IACrE,IAAI,IAAI,CAACN,UAAU,CAACM,OAAO,CAAC,KAAK,CAAC,EAAE;MAClC,IAAI,CAACN,UAAU,CAACM,OAAO,CAAC,GAAG,CAAC;MAC5B,IAAI,CAACG,QAAQ,CAACC,IAAI,CAAC,CAACJ,OAAO,CAAC,CAAC;MAC7B,IAAIK,SAAS,GAAG,IAAI,CAACF,QAAQ,CAACD,MAAM,GAAG,CAAC;MAExC,IAAI,CAACN,YAAY,CAACQ,IAAI,CAACJ,OAAO,CAAC;MAC/B,IAAIM,aAAa,GAAG,IAAItB,aAAa,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC;MACxD,IAAIuB,SAAS,GAAG,IAAI,CAACC,YAAY,CAACR,OAAO,CAAC;;MAE1C;MACA,IAAI,IAAI,CAACS,eAAe,CAACT,OAAO,CAAC,KAAKU,SAAS,EAAE;QAC/C,IAAI,CAACC,YAAY,CAACX,OAAO,EAAEO,SAAS,EAAED,aAAa,CAAC;QACpD,IAAI,CAACM,cAAc,CAACP,SAAS,EAAEC,aAAa,CAAC;MAC/C;IACF;EACF;EAEA,OAAO,IAAI,CAACH,QAAQ;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAjB,MAAM,CAACY,SAAS,CAACe,mBAAmB,GAAG,YAAW;EAChD,IAAIC,gBAAgB,GAAG,EAAE;EAEzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEd,CAAC,GAAG,IAAI,CAACL,YAAY,CAACM,MAAM,EAAEa,CAAC,GAAGd,CAAC,EAAEc,CAAC,EAAE,EAAE;IACxD,IAAIf,OAAO,GAAG,IAAI,CAACJ,YAAY,CAACmB,CAAC,CAAC;IAClC,IAAIxB,QAAQ,GAAG,IAAI,CAACE,aAAa,CAACO,OAAO,CAAC;IAE1Cc,gBAAgB,CAACV,IAAI,CAAC,CAACJ,OAAO,EAAET,QAAQ,CAAC,CAAC;EAC5C;EAEA,OAAOuB,gBAAgB;AACzB,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5B,MAAM,CAACY,SAAS,CAACD,KAAK,GAAG,UAASV,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAEE,QAAQ,EAAE;EAEpE,IAAIJ,OAAO,EAAE;IAEX,IAAI,EAAEA,OAAO,YAAY6B,KAAK,CAAC,EAAE;MAC/B,MAAMC,KAAK,CAAC,iCAAiC,GAC3C,OAAO9B,OAAO,GAAG,QAAQ,CAAC;IAC9B;IAEA,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACgB,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACV,aAAa,GAAG,IAAIuB,KAAK,CAAC,IAAI,CAAC7B,OAAO,CAACe,MAAM,CAAC;IACnD,IAAI,CAACR,UAAU,GAAG,IAAIsB,KAAK,CAAC,IAAI,CAAC7B,OAAO,CAACe,MAAM,CAAC;IAChD,IAAI,CAACP,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,YAAY,GAAG,EAAE;EACxB;EAEA,IAAIR,OAAO,EAAE;IACX,IAAI,CAACA,OAAO,GAAGA,OAAO;EACxB;EAEA,IAAIC,MAAM,EAAE;IACV,IAAI,CAACA,MAAM,GAAGA,MAAM;EACtB;EAEA,IAAIE,QAAQ,EAAE;IACZ,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC1B;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,MAAM,CAACY,SAAS,CAACa,YAAY,GAAG,UAASX,OAAO,EAAEO,SAAS,EAAEW,KAAK,EAAE;EAClE,IAAIC,IAAI,GAAG,IAAI;EAEf,IAAI,CAACxB,aAAa,GAAG,IAAI,CAACc,eAAe,CAACT,OAAO,CAAC;EAClDO,SAAS,CAACa,OAAO,CAAC,UAASC,QAAQ,EAAE;IACnC,IAAIF,IAAI,CAACzB,UAAU,CAAC2B,QAAQ,CAAC,KAAKX,SAAS,EAAE;MAC3C,IAAIY,IAAI,GAAGH,IAAI,CAAC5B,QAAQ,CAAC4B,IAAI,CAAChC,OAAO,CAACa,OAAO,CAAC,EAAEmB,IAAI,CAAChC,OAAO,CAACkC,QAAQ,CAAC,CAAC;MACvE,IAAIE,oBAAoB,GAAGC,IAAI,CAACC,GAAG,CAACN,IAAI,CAACxB,aAAa,EAAE2B,IAAI,CAAC;MAE7D,IAAIH,IAAI,CAAC1B,aAAa,CAAC4B,QAAQ,CAAC,KAAKX,SAAS,EAAE;QAC9CS,IAAI,CAAC1B,aAAa,CAAC4B,QAAQ,CAAC,GAAGE,oBAAoB;QACnDL,KAAK,CAACQ,MAAM,CAACL,QAAQ,EAAEE,oBAAoB,CAAC;MAC9C,CAAC,MAAM;QACL,IAAIA,oBAAoB,GAAGJ,IAAI,CAAC1B,aAAa,CAAC4B,QAAQ,CAAC,EAAE;UACvDF,IAAI,CAAC1B,aAAa,CAAC4B,QAAQ,CAAC,GAAGE,oBAAoB;UACnDL,KAAK,CAACS,MAAM,CAACN,QAAQ,CAAC;UACtBH,KAAK,CAACQ,MAAM,CAACL,QAAQ,EAAEE,oBAAoB,CAAC;QAC9C;MACF;IACF;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArC,MAAM,CAACY,SAAS,CAACc,cAAc,GAAG,UAASP,SAAS,EAAEa,KAAK,EAAE;EAC3D,IAAIU,aAAa,GAAGV,KAAK,CAACW,WAAW,CAAC,CAAC;EAEvC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAE7B,CAAC,GAAG2B,aAAa,CAAC1B,MAAM,EAAE4B,CAAC,GAAG7B,CAAC,EAAE6B,CAAC,EAAE,EAAE;IACpD,IAAI9B,OAAO,GAAG4B,aAAa,CAACE,CAAC,CAAC;IAC9B,IAAI,IAAI,CAACpC,UAAU,CAACM,OAAO,CAAC,KAAKU,SAAS,EAAE;MAC1C,IAAIH,SAAS,GAAG,IAAI,CAACC,YAAY,CAACR,OAAO,CAAC;MAC1C,IAAI,CAACN,UAAU,CAACM,OAAO,CAAC,GAAG,CAAC;MAE5B,IAAI,CAACG,QAAQ,CAACE,SAAS,CAAC,CAACD,IAAI,CAACJ,OAAO,CAAC;MACtC,IAAI,CAACJ,YAAY,CAACQ,IAAI,CAACJ,OAAO,CAAC;MAE/B,IAAI,IAAI,CAACS,eAAe,CAACT,OAAO,CAAC,KAAKU,SAAS,EAAE;QAC/C,IAAI,CAACC,YAAY,CAACX,OAAO,EAAEO,SAAS,EAAEW,KAAK,CAAC;QAC5C,IAAI,CAACN,cAAc,CAACP,SAAS,EAAEa,KAAK,CAAC;MACvC;IACF;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAhC,MAAM,CAACY,SAAS,CAACW,eAAe,GAAG,UAAST,OAAO,EAAE;EACnD,IAAIC,CAAC,GAAG,IAAI,CAACb,OAAO;EACpB,KAAK,IAAI2C,YAAY,GAAG,CAAC,EAAEA,YAAY,GAAG9B,CAAC,EAAE8B,YAAY,EAAE,EAAE;IAC3D,IAAIxB,SAAS,GAAG,IAAI,CAACC,YAAY,CAACR,OAAO,EAAE+B,YAAY,CAAC;IACxD,IAAIxB,SAAS,CAACL,MAAM,IAAI,IAAI,CAACb,MAAM,EAAE;MACnC,OAAO0C,YAAY;IACrB;EACF;EAEA;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7C,MAAM,CAACY,SAAS,CAACU,YAAY,GAAG,UAASR,OAAO,EAAEZ,OAAO,EAAE;EACzDA,OAAO,GAAGA,OAAO,IAAI,IAAI,CAACA,OAAO;EACjC,IAAImB,SAAS,GAAG,EAAE;EAElB,KAAK,IAAIyB,EAAE,GAAG,CAAC,EAAE/B,CAAC,GAAG,IAAI,CAACd,OAAO,CAACe,MAAM,EAAE8B,EAAE,GAAG/B,CAAC,EAAE+B,EAAE,EAAE,EAAE;IACtD,IAAI,IAAI,CAACzC,QAAQ,CAAC,IAAI,CAACJ,OAAO,CAACa,OAAO,CAAC,EAAE,IAAI,CAACb,OAAO,CAAC6C,EAAE,CAAC,CAAC,GAAG5C,OAAO,EAAE;MACpEmB,SAAS,CAACH,IAAI,CAAC4B,EAAE,CAAC;IACpB;EACF;EAEA,OAAOzB,SAAS;AAClB,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArB,MAAM,CAACY,SAAS,CAACN,kBAAkB,GAAG,UAASsC,CAAC,EAAEG,CAAC,EAAE;EACnD,IAAIC,GAAG,GAAG,CAAC;EACX,IAAInB,CAAC,GAAGS,IAAI,CAACW,GAAG,CAACL,CAAC,CAAC5B,MAAM,EAAE+B,CAAC,CAAC/B,MAAM,CAAC;EAEpC,OAAOa,CAAC,EAAE,EAAE;IACVmB,GAAG,IAAI,CAACJ,CAAC,CAACf,CAAC,CAAC,GAAGkB,CAAC,CAAClB,CAAC,CAAC,KAAKe,CAAC,CAACf,CAAC,CAAC,GAAGkB,CAAC,CAAClB,CAAC,CAAC,CAAC;EACtC;EAEA,OAAOS,IAAI,CAACY,IAAI,CAACF,GAAG,CAAC;AACvB,CAAC;AAED,IAAI,OAAOpD,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,OAAO,EAAE;EACnDD,MAAM,CAACC,OAAO,GAAGG,MAAM;AACzB"},"metadata":{},"sourceType":"script","externalDependencies":[]}