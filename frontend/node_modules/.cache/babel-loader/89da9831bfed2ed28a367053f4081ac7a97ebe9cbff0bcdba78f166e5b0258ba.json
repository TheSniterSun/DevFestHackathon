{"ast":null,"code":"'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\nvar quickselect = require('quickselect');\nfunction rbush(maxEntries, format) {\n  if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n  // max entries in a node is 9 by default; min node fill is 40% for best performance\n  this._maxEntries = Math.max(4, maxEntries || 9);\n  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n  if (format) {\n    this._initFormat(format);\n  }\n  this.clear();\n}\nrbush.prototype = {\n  all: function () {\n    return this._all(this.data, []);\n  },\n  search: function (bbox) {\n    var node = this.data,\n      result = [],\n      toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return result;\n    var nodesToSearch = [],\n      i,\n      len,\n      child,\n      childBBox;\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n        }\n      }\n      node = nodesToSearch.pop();\n    }\n    return result;\n  },\n  collides: function (bbox) {\n    var node = this.data,\n      toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return false;\n    var nodesToSearch = [],\n      i,\n      len,\n      child,\n      childBBox;\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) return true;\n          nodesToSearch.push(child);\n        }\n      }\n      node = nodesToSearch.pop();\n    }\n    return false;\n  },\n  load: function (data) {\n    if (!(data && data.length)) return this;\n    if (data.length < this._minEntries) {\n      for (var i = 0, len = data.length; i < len; i++) {\n        this.insert(data[i]);\n      }\n      return this;\n    }\n\n    // recursively build the tree with the given data from scratch using OMT algorithm\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        var tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      }\n\n      // insert the small tree into the large tree at appropriate level\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n    return this;\n  },\n  insert: function (item) {\n    if (item) this._insert(item, this.data.height - 1);\n    return this;\n  },\n  clear: function () {\n    this.data = createNode([]);\n    return this;\n  },\n  remove: function (item, equalsFn) {\n    if (!item) return this;\n    var node = this.data,\n      bbox = this.toBBox(item),\n      path = [],\n      indexes = [],\n      i,\n      parent,\n      index,\n      goingUp;\n\n    // depth-first iterative tree traversal\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n      if (node.leaf) {\n        // check current node\n        index = findItem(item, node.children, equalsFn);\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n          this._condense(path);\n          return this;\n        }\n      }\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else node = null; // nothing found\n    }\n    return this;\n  },\n  toBBox: function (item) {\n    return item;\n  },\n  compareMinX: compareNodeMinX,\n  compareMinY: compareNodeMinY,\n  toJSON: function () {\n    return this.data;\n  },\n  fromJSON: function (data) {\n    this.data = data;\n    return this;\n  },\n  _all: function (node, result) {\n    var nodesToSearch = [];\n    while (node) {\n      if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n      node = nodesToSearch.pop();\n    }\n    return result;\n  },\n  _build: function (items, left, right, height) {\n    var N = right - left + 1,\n      M = this._maxEntries,\n      node;\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M));\n\n      // target number of root entries to maximize storage utilization\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height;\n\n    // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M),\n      N1 = N2 * Math.ceil(Math.sqrt(M)),\n      i,\n      j,\n      right2,\n      right3;\n    multiSelect(items, left, right, N1, this.compareMinX);\n    for (i = left; i <= right; i += N1) {\n      right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n      for (j = i; j <= right2; j += N2) {\n        right3 = Math.min(j + N2 - 1, right2);\n\n        // pack each entry recursively\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n    calcBBox(node, this.toBBox);\n    return node;\n  },\n  _chooseSubtree: function (bbox, node, level, path) {\n    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n    while (true) {\n      path.push(node);\n      if (node.leaf || path.length - 1 === level) break;\n      minArea = minEnlargement = Infinity;\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        area = bboxArea(child);\n        enlargement = enlargedArea(bbox, child) - area;\n\n        // choose entry with the least area enlargement\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n      node = targetNode || node.children[0];\n    }\n    return node;\n  },\n  _insert: function (item, level, isNode) {\n    var toBBox = this.toBBox,\n      bbox = isNode ? item : toBBox(item),\n      insertPath = [];\n\n    // find the best node for accommodating the item, saving all nodes along the path too\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n    // put the item into the node\n    node.children.push(item);\n    extend(node, bbox);\n\n    // split on node overflow; propagate upwards if necessary\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n        level--;\n      } else break;\n    }\n\n    // adjust bboxes along the insertion path\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  },\n  // split overflowed node into two\n  _split: function (insertPath, level) {\n    var node = insertPath[level],\n      M = node.children.length,\n      m = this._minEntries;\n    this._chooseSplitAxis(node, m, M);\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n  },\n  _splitRoot: function (node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  },\n  _chooseSplitIndex: function (node, m, M) {\n    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n    minOverlap = minArea = Infinity;\n    for (i = m; i <= M - m; i++) {\n      bbox1 = distBBox(node, 0, i, this.toBBox);\n      bbox2 = distBBox(node, i, M, this.toBBox);\n      overlap = intersectionArea(bbox1, bbox2);\n      area = bboxArea(bbox1) + bboxArea(bbox2);\n\n      // choose distribution with minimum overlap\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n    return index;\n  },\n  // sorts node children by the best axis for split\n  _chooseSplitAxis: function (node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n      compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n      xMargin = this._allDistMargin(node, m, M, compareMinX),\n      yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n    // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n    if (xMargin < yMargin) node.children.sort(compareMinX);\n  },\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin: function (node, m, M, compare) {\n    node.children.sort(compare);\n    var toBBox = this.toBBox,\n      leftBBox = distBBox(node, 0, m, toBBox),\n      rightBBox = distBBox(node, M - m, M, toBBox),\n      margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n      i,\n      child;\n    for (i = m; i < M - m; i++) {\n      child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n    for (i = M - m - 1; i >= m; i--) {\n      child = node.children[i];\n      extend(rightBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(rightBBox);\n    }\n    return margin;\n  },\n  _adjustParentBBoxes: function (bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  },\n  _condense: function (path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else this.clear();\n      } else calcBBox(path[i], this.toBBox);\n    }\n  },\n  _initFormat: function (format) {\n    // data format (minX, minY, maxX, maxY accessors)\n\n    // uses eval-type function compilation instead of just accepting a toBBox function\n    // because the algorithms are very sensitive to sorting functions performance,\n    // so they should be dead simple and without inner calls\n\n    var compareArr = ['return a', ' - b', ';'];\n    this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n    this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n    this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n  }\n};\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn) return items.indexOf(item);\n  for (var i = 0; i < items.length; i++) {\n    if (equalsFn(item, items[i])) return i;\n  }\n  return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n  distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n  if (!destNode) destNode = createNode(null);\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n  for (var i = k, child; i < p; i++) {\n    child = node.children[i];\n    extend(destNode, node.leaf ? toBBox(child) : child);\n  }\n  return destNode;\n}\nfunction extend(a, b) {\n  a.minX = Math.min(a.minX, b.minX);\n  a.minY = Math.min(a.minY, b.minY);\n  a.maxX = Math.max(a.maxX, b.maxX);\n  a.maxY = Math.max(a.maxY, b.maxY);\n  return a;\n}\nfunction compareNodeMinX(a, b) {\n  return a.minX - b.minX;\n}\nfunction compareNodeMinY(a, b) {\n  return a.minY - b.minY;\n}\nfunction bboxArea(a) {\n  return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin(a) {\n  return a.maxX - a.minX + (a.maxY - a.minY);\n}\nfunction enlargedArea(a, b) {\n  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\nfunction intersectionArea(a, b) {\n  var minX = Math.max(a.minX, b.minX),\n    minY = Math.max(a.minY, b.minY),\n    maxX = Math.min(a.maxX, b.maxX),\n    maxY = Math.min(a.maxY, b.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\nfunction contains(a, b) {\n  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\nfunction intersects(a, b) {\n  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\nfunction createNode(children) {\n  return {\n    children: children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n  var stack = [left, right],\n    mid;\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n    if (right - left <= n) continue;\n    mid = left + Math.ceil((right - left) / n / 2) * n;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}","map":{"version":3,"names":["module","exports","rbush","default","quickselect","require","maxEntries","format","_maxEntries","Math","max","_minEntries","ceil","_initFormat","clear","prototype","all","_all","data","search","bbox","node","result","toBBox","intersects","nodesToSearch","i","len","child","childBBox","children","length","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","index","goingUp","findItem","splice","_condense","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","toJSON","fromJSON","apply","items","left","right","N","M","calcBBox","log","pow","N2","N1","sqrt","j","right2","right3","multiSelect","min","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","Infinity","bboxArea","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","distBBox","intersectionArea","xMargin","_allDistMargin","yMargin","sort","compare","leftBBox","rightBBox","margin","bboxMargin","siblings","indexOf","compareArr","Function","join","k","p","destNode","minX","minY","maxX","maxY","a","b","arr","n","stack","mid"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/rbush/index.js"],"sourcesContent":["'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}