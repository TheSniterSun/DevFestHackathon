{"ast":null,"code":"import centroid from \"@turf/centroid\";\nimport { getCoord } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * calcualte the Minkowski p-norm distance between two features.\n * @param feature1 point feature\n * @param feature2 point feature\n * @param p p-norm 1=<p<=infinity 1: Manhattan distance 2: Euclidean distance\n */\nexport function pNormDistance(feature1, feature2, p) {\n  if (p === void 0) {\n    p = 2;\n  }\n  var coordinate1 = getCoord(feature1);\n  var coordinate2 = getCoord(feature2);\n  var xDiff = coordinate1[0] - coordinate2[0];\n  var yDiff = coordinate1[1] - coordinate2[1];\n  if (p === 1) {\n    return Math.abs(xDiff) + Math.abs(yDiff);\n  }\n  return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);\n}\n/**\n *\n *\n * @name distanceWeight\n * @param {FeatureCollection<any>} fc FeatureCollection.\n * @param {Object} [options] option object.\n * @param {number} [options.threshold=10000] If the distance between neighbor and\n * target features is greater than threshold, the weight of that neighbor is 0.\n * @param {number} [options.p=2] Minkowski p-norm distance parameter.\n * 1: Manhattan distance. 2: Euclidean distance. 1=<p<=infinity.\n * @param {boolean} [options.binary=false] If true, weight=1 if d <= threshold otherwise weight=0.\n *  If false, weight=Math.pow(d, alpha).\n * @param {number} [options.alpha=-1] distance decay parameter.\n * A big value means the weight decay quickly as distance increases.\n * @param {boolean} [options.standardization=false] row standardization.\n * @returns {Array<Array<number>>} distance weight matrix.\n * @example\n *\n * var bbox = [-65, 40, -63, 42];\n * var dataset = turf.randomPoint(100, { bbox: bbox });\n * var result = turf.distanceWeight(dataset);\n */\nexport default function distanceWeight(fc, options) {\n  options = options || {};\n  var threshold = options.threshold || 10000;\n  var p = options.p || 2;\n  var binary = options.binary || false;\n  var alpha = options.alpha || -1;\n  var rowTransform = options.standardization || false;\n  var features = [];\n  featureEach(fc, function (feature) {\n    features.push(centroid(feature));\n  });\n  // computing the distance between the features\n  var weights = [];\n  for (var i = 0; i < features.length; i++) {\n    weights[i] = [];\n  }\n  for (var i = 0; i < features.length; i++) {\n    for (var j = i; j < features.length; j++) {\n      if (i === j) {\n        weights[i][j] = 0;\n      }\n      var dis = pNormDistance(features[i], features[j], p);\n      weights[i][j] = dis;\n      weights[j][i] = dis;\n    }\n  }\n  // binary or distance decay\n  for (var i = 0; i < features.length; i++) {\n    for (var j = 0; j < features.length; j++) {\n      var dis = weights[i][j];\n      if (dis === 0) {\n        continue;\n      }\n      if (binary) {\n        if (dis <= threshold) {\n          weights[i][j] = 1.0;\n        } else {\n          weights[i][j] = 0.0;\n        }\n      } else {\n        if (dis <= threshold) {\n          weights[i][j] = Math.pow(dis, alpha);\n        } else {\n          weights[i][j] = 0.0;\n        }\n      }\n    }\n  }\n  if (rowTransform) {\n    for (var i = 0; i < features.length; i++) {\n      var rowSum = weights[i].reduce(function (sum, currentVal) {\n        return sum + currentVal;\n      }, 0);\n      for (var j = 0; j < features.length; j++) {\n        weights[i][j] = weights[i][j] / rowSum;\n      }\n    }\n  }\n  return weights;\n}","map":{"version":3,"names":["centroid","getCoord","featureEach","pNormDistance","feature1","feature2","p","coordinate1","coordinate2","xDiff","yDiff","Math","abs","pow","distanceWeight","fc","options","threshold","binary","alpha","rowTransform","standardization","features","feature","push","weights","i","length","j","dis","rowSum","reduce","sum","currentVal"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/distance-weight/dist/es/index.js"],"sourcesContent":["import centroid from \"@turf/centroid\";\nimport { getCoord } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * calcualte the Minkowski p-norm distance between two features.\n * @param feature1 point feature\n * @param feature2 point feature\n * @param p p-norm 1=<p<=infinity 1: Manhattan distance 2: Euclidean distance\n */\nexport function pNormDistance(feature1, feature2, p) {\n    if (p === void 0) { p = 2; }\n    var coordinate1 = getCoord(feature1);\n    var coordinate2 = getCoord(feature2);\n    var xDiff = coordinate1[0] - coordinate2[0];\n    var yDiff = coordinate1[1] - coordinate2[1];\n    if (p === 1) {\n        return Math.abs(xDiff) + Math.abs(yDiff);\n    }\n    return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);\n}\n/**\n *\n *\n * @name distanceWeight\n * @param {FeatureCollection<any>} fc FeatureCollection.\n * @param {Object} [options] option object.\n * @param {number} [options.threshold=10000] If the distance between neighbor and\n * target features is greater than threshold, the weight of that neighbor is 0.\n * @param {number} [options.p=2] Minkowski p-norm distance parameter.\n * 1: Manhattan distance. 2: Euclidean distance. 1=<p<=infinity.\n * @param {boolean} [options.binary=false] If true, weight=1 if d <= threshold otherwise weight=0.\n *  If false, weight=Math.pow(d, alpha).\n * @param {number} [options.alpha=-1] distance decay parameter.\n * A big value means the weight decay quickly as distance increases.\n * @param {boolean} [options.standardization=false] row standardization.\n * @returns {Array<Array<number>>} distance weight matrix.\n * @example\n *\n * var bbox = [-65, 40, -63, 42];\n * var dataset = turf.randomPoint(100, { bbox: bbox });\n * var result = turf.distanceWeight(dataset);\n */\nexport default function distanceWeight(fc, options) {\n    options = options || {};\n    var threshold = options.threshold || 10000;\n    var p = options.p || 2;\n    var binary = options.binary || false;\n    var alpha = options.alpha || -1;\n    var rowTransform = options.standardization || false;\n    var features = [];\n    featureEach(fc, function (feature) {\n        features.push(centroid(feature));\n    });\n    // computing the distance between the features\n    var weights = [];\n    for (var i = 0; i < features.length; i++) {\n        weights[i] = [];\n    }\n    for (var i = 0; i < features.length; i++) {\n        for (var j = i; j < features.length; j++) {\n            if (i === j) {\n                weights[i][j] = 0;\n            }\n            var dis = pNormDistance(features[i], features[j], p);\n            weights[i][j] = dis;\n            weights[j][i] = dis;\n        }\n    }\n    // binary or distance decay\n    for (var i = 0; i < features.length; i++) {\n        for (var j = 0; j < features.length; j++) {\n            var dis = weights[i][j];\n            if (dis === 0) {\n                continue;\n            }\n            if (binary) {\n                if (dis <= threshold) {\n                    weights[i][j] = 1.0;\n                }\n                else {\n                    weights[i][j] = 0.0;\n                }\n            }\n            else {\n                if (dis <= threshold) {\n                    weights[i][j] = Math.pow(dis, alpha);\n                }\n                else {\n                    weights[i][j] = 0.0;\n                }\n            }\n        }\n    }\n    if (rowTransform) {\n        for (var i = 0; i < features.length; i++) {\n            var rowSum = weights[i].reduce(function (sum, currentVal) {\n                return sum + currentVal;\n            }, 0);\n            for (var j = 0; j < features.length; j++) {\n                weights[i][j] = weights[i][j] / rowSum;\n            }\n        }\n    }\n    return weights;\n}\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,gBAAgB;AACrC,SAASC,QAAQ,QAAQ,iBAAiB;AAC1C,SAASC,WAAW,QAAQ,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,CAAC,EAAE;EACjD,IAAIA,CAAC,KAAK,KAAK,CAAC,EAAE;IAAEA,CAAC,GAAG,CAAC;EAAE;EAC3B,IAAIC,WAAW,GAAGN,QAAQ,CAACG,QAAQ,CAAC;EACpC,IAAII,WAAW,GAAGP,QAAQ,CAACI,QAAQ,CAAC;EACpC,IAAII,KAAK,GAAGF,WAAW,CAAC,CAAC,CAAC,GAAGC,WAAW,CAAC,CAAC,CAAC;EAC3C,IAAIE,KAAK,GAAGH,WAAW,CAAC,CAAC,CAAC,GAAGC,WAAW,CAAC,CAAC,CAAC;EAC3C,IAAIF,CAAC,KAAK,CAAC,EAAE;IACT,OAAOK,IAAI,CAACC,GAAG,CAACH,KAAK,CAAC,GAAGE,IAAI,CAACC,GAAG,CAACF,KAAK,CAAC;EAC5C;EACA,OAAOC,IAAI,CAACE,GAAG,CAACF,IAAI,CAACE,GAAG,CAACJ,KAAK,EAAEH,CAAC,CAAC,GAAGK,IAAI,CAACE,GAAG,CAACH,KAAK,EAAEJ,CAAC,CAAC,EAAE,CAAC,GAAGA,CAAC,CAAC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASQ,cAAcA,CAACC,EAAE,EAAEC,OAAO,EAAE;EAChDA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAIC,SAAS,GAAGD,OAAO,CAACC,SAAS,IAAI,KAAK;EAC1C,IAAIX,CAAC,GAAGU,OAAO,CAACV,CAAC,IAAI,CAAC;EACtB,IAAIY,MAAM,GAAGF,OAAO,CAACE,MAAM,IAAI,KAAK;EACpC,IAAIC,KAAK,GAAGH,OAAO,CAACG,KAAK,IAAI,CAAC,CAAC;EAC/B,IAAIC,YAAY,GAAGJ,OAAO,CAACK,eAAe,IAAI,KAAK;EACnD,IAAIC,QAAQ,GAAG,EAAE;EACjBpB,WAAW,CAACa,EAAE,EAAE,UAAUQ,OAAO,EAAE;IAC/BD,QAAQ,CAACE,IAAI,CAACxB,QAAQ,CAACuB,OAAO,CAAC,CAAC;EACpC,CAAC,CAAC;EACF;EACA,IAAIE,OAAO,GAAG,EAAE;EAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;IACtCD,OAAO,CAACC,CAAC,CAAC,GAAG,EAAE;EACnB;EACA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,KAAK,IAAIE,CAAC,GAAGF,CAAC,EAAEE,CAAC,GAAGN,QAAQ,CAACK,MAAM,EAAEC,CAAC,EAAE,EAAE;MACtC,IAAIF,CAAC,KAAKE,CAAC,EAAE;QACTH,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAG,CAAC;MACrB;MACA,IAAIC,GAAG,GAAG1B,aAAa,CAACmB,QAAQ,CAACI,CAAC,CAAC,EAAEJ,QAAQ,CAACM,CAAC,CAAC,EAAEtB,CAAC,CAAC;MACpDmB,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAGC,GAAG;MACnBJ,OAAO,CAACG,CAAC,CAAC,CAACF,CAAC,CAAC,GAAGG,GAAG;IACvB;EACJ;EACA;EACA,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;IACtC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,QAAQ,CAACK,MAAM,EAAEC,CAAC,EAAE,EAAE;MACtC,IAAIC,GAAG,GAAGJ,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC;MACvB,IAAIC,GAAG,KAAK,CAAC,EAAE;QACX;MACJ;MACA,IAAIX,MAAM,EAAE;QACR,IAAIW,GAAG,IAAIZ,SAAS,EAAE;UAClBQ,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAG,GAAG;QACvB,CAAC,MACI;UACDH,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAG,GAAG;QACvB;MACJ,CAAC,MACI;QACD,IAAIC,GAAG,IAAIZ,SAAS,EAAE;UAClBQ,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAGjB,IAAI,CAACE,GAAG,CAACgB,GAAG,EAAEV,KAAK,CAAC;QACxC,CAAC,MACI;UACDM,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAG,GAAG;QACvB;MACJ;IACJ;EACJ;EACA,IAAIR,YAAY,EAAE;IACd,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;MACtC,IAAII,MAAM,GAAGL,OAAO,CAACC,CAAC,CAAC,CAACK,MAAM,CAAC,UAAUC,GAAG,EAAEC,UAAU,EAAE;QACtD,OAAOD,GAAG,GAAGC,UAAU;MAC3B,CAAC,EAAE,CAAC,CAAC;MACL,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,QAAQ,CAACK,MAAM,EAAEC,CAAC,EAAE,EAAE;QACtCH,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAGH,OAAO,CAACC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAGE,MAAM;MAC1C;IACJ;EACJ;EACA,OAAOL,OAAO;AAClB"},"metadata":{},"sourceType":"module","externalDependencies":[]}