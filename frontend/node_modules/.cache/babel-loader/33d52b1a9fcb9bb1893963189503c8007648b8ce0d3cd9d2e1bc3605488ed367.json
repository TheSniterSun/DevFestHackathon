{"ast":null,"code":"import bbox from '@turf/bbox';\nimport hexGrid from '@turf/hex-grid';\nimport pointGrid from '@turf/point-grid';\nimport distance from '@turf/distance';\nimport centroid from '@turf/centroid';\nimport squareGrid from '@turf/square-grid';\nimport triangleGrid from '@turf/triangle-grid';\nimport clone from '@turf/clone';\nimport { featureCollection } from '@turf/helpers';\nimport { featureEach } from '@turf/meta';\nimport { collectionOf } from '@turf/invariant';\n\n/**\n * Takes a set of points and estimates their 'property' values on a grid using the [Inverse Distance Weighting (IDW) method](https://en.wikipedia.org/wiki/Inverse_distance_weighting).\n *\n * @name interpolate\n * @param {FeatureCollection<Point>} points with known value\n * @param {number} cellSize the distance across each grid point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.gridType='square'] defines the output format based on a Grid Type (options: 'square' | 'point' | 'hex' | 'triangle')\n * @param {string} [options.property='elevation'] the property name in `points` from which z-values will be pulled, zValue fallbacks to 3rd coordinate if no property exists.\n * @param {string} [options.units='kilometers'] used in calculating cellSize, can be degrees, radians, miles, or kilometers\n * @param {number} [options.weight=1] exponent regulating the distance-decay weighting\n * @returns {FeatureCollection<Point|Polygon>} grid of points or polygons with interpolated 'property'\n * @example\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\n *\n * // add a random property to each point\n * turf.featureEach(points, function(point) {\n *     point.properties.solRad = Math.random() * 50;\n * });\n * var options = {gridType: 'points', property: 'solRad', units: 'miles'};\n * var grid = turf.interpolate(points, 100, options);\n *\n * //addToMap\n * var addToMap = [grid];\n */\nfunction interpolate(points, cellSize, options) {\n  // Optional parameters\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var gridType = options.gridType;\n  var property = options.property;\n  var weight = options.weight;\n\n  // validation\n  if (!points) throw new Error(\"points is required\");\n  collectionOf(points, \"Point\", \"input must contain Points\");\n  if (!cellSize) throw new Error(\"cellSize is required\");\n  if (weight !== undefined && typeof weight !== \"number\") throw new Error(\"weight must be a number\");\n\n  // default values\n  property = property || \"elevation\";\n  gridType = gridType || \"square\";\n  weight = weight || 1;\n  var box = bbox(points);\n  var grid;\n  switch (gridType) {\n    case \"point\":\n    case \"points\":\n      grid = pointGrid(box, cellSize, options);\n      break;\n    case \"square\":\n    case \"squares\":\n      grid = squareGrid(box, cellSize, options);\n      break;\n    case \"hex\":\n    case \"hexes\":\n      grid = hexGrid(box, cellSize, options);\n      break;\n    case \"triangle\":\n    case \"triangles\":\n      grid = triangleGrid(box, cellSize, options);\n      break;\n    default:\n      throw new Error(\"invalid gridType\");\n  }\n  var results = [];\n  featureEach(grid, function (gridFeature) {\n    var zw = 0;\n    var sw = 0;\n    // calculate the distance from each input point to the grid points\n    featureEach(points, function (point) {\n      var gridPoint = gridType === \"point\" ? gridFeature : centroid(gridFeature);\n      var d = distance(gridPoint, point, options);\n      var zValue;\n      // property has priority for zValue, fallbacks to 3rd coordinate from geometry\n      if (property !== undefined) zValue = point.properties[property];\n      if (zValue === undefined) zValue = point.geometry.coordinates[2];\n      if (zValue === undefined) throw new Error(\"zValue is missing\");\n      if (d === 0) zw = zValue;\n      var w = 1.0 / Math.pow(d, weight);\n      sw += w;\n      zw += w * zValue;\n    });\n    // write interpolated value for each grid point\n    var newFeature = clone(gridFeature);\n    newFeature.properties[property] = zw / sw;\n    results.push(newFeature);\n  });\n  return featureCollection(results);\n}\nexport default interpolate;","map":{"version":3,"names":["bbox","hexGrid","pointGrid","distance","centroid","squareGrid","triangleGrid","clone","featureCollection","featureEach","collectionOf","interpolate","points","cellSize","options","Error","gridType","property","weight","undefined","box","grid","results","gridFeature","zw","sw","point","gridPoint","d","zValue","properties","geometry","coordinates","w","Math","pow","newFeature","push"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/interpolate/dist/es/index.js"],"sourcesContent":["import bbox from '@turf/bbox';\nimport hexGrid from '@turf/hex-grid';\nimport pointGrid from '@turf/point-grid';\nimport distance from '@turf/distance';\nimport centroid from '@turf/centroid';\nimport squareGrid from '@turf/square-grid';\nimport triangleGrid from '@turf/triangle-grid';\nimport clone from '@turf/clone';\nimport { featureCollection } from '@turf/helpers';\nimport { featureEach } from '@turf/meta';\nimport { collectionOf } from '@turf/invariant';\n\n/**\n * Takes a set of points and estimates their 'property' values on a grid using the [Inverse Distance Weighting (IDW) method](https://en.wikipedia.org/wiki/Inverse_distance_weighting).\n *\n * @name interpolate\n * @param {FeatureCollection<Point>} points with known value\n * @param {number} cellSize the distance across each grid point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.gridType='square'] defines the output format based on a Grid Type (options: 'square' | 'point' | 'hex' | 'triangle')\n * @param {string} [options.property='elevation'] the property name in `points` from which z-values will be pulled, zValue fallbacks to 3rd coordinate if no property exists.\n * @param {string} [options.units='kilometers'] used in calculating cellSize, can be degrees, radians, miles, or kilometers\n * @param {number} [options.weight=1] exponent regulating the distance-decay weighting\n * @returns {FeatureCollection<Point|Polygon>} grid of points or polygons with interpolated 'property'\n * @example\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\n *\n * // add a random property to each point\n * turf.featureEach(points, function(point) {\n *     point.properties.solRad = Math.random() * 50;\n * });\n * var options = {gridType: 'points', property: 'solRad', units: 'miles'};\n * var grid = turf.interpolate(points, 100, options);\n *\n * //addToMap\n * var addToMap = [grid];\n */\nfunction interpolate(points, cellSize, options) {\n  // Optional parameters\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var gridType = options.gridType;\n  var property = options.property;\n  var weight = options.weight;\n\n  // validation\n  if (!points) throw new Error(\"points is required\");\n  collectionOf(points, \"Point\", \"input must contain Points\");\n  if (!cellSize) throw new Error(\"cellSize is required\");\n  if (weight !== undefined && typeof weight !== \"number\")\n    throw new Error(\"weight must be a number\");\n\n  // default values\n  property = property || \"elevation\";\n  gridType = gridType || \"square\";\n  weight = weight || 1;\n\n  var box = bbox(points);\n  var grid;\n  switch (gridType) {\n    case \"point\":\n    case \"points\":\n      grid = pointGrid(box, cellSize, options);\n      break;\n    case \"square\":\n    case \"squares\":\n      grid = squareGrid(box, cellSize, options);\n      break;\n    case \"hex\":\n    case \"hexes\":\n      grid = hexGrid(box, cellSize, options);\n      break;\n    case \"triangle\":\n    case \"triangles\":\n      grid = triangleGrid(box, cellSize, options);\n      break;\n    default:\n      throw new Error(\"invalid gridType\");\n  }\n  var results = [];\n  featureEach(grid, function (gridFeature) {\n    var zw = 0;\n    var sw = 0;\n    // calculate the distance from each input point to the grid points\n    featureEach(points, function (point) {\n      var gridPoint =\n        gridType === \"point\" ? gridFeature : centroid(gridFeature);\n      var d = distance(gridPoint, point, options);\n      var zValue;\n      // property has priority for zValue, fallbacks to 3rd coordinate from geometry\n      if (property !== undefined) zValue = point.properties[property];\n      if (zValue === undefined) zValue = point.geometry.coordinates[2];\n      if (zValue === undefined) throw new Error(\"zValue is missing\");\n      if (d === 0) zw = zValue;\n      var w = 1.0 / Math.pow(d, weight);\n      sw += w;\n      zw += w * zValue;\n    });\n    // write interpolated value for each grid point\n    var newFeature = clone(gridFeature);\n    newFeature.properties[property] = zw / sw;\n    results.push(newFeature);\n  });\n  return featureCollection(results);\n}\n\nexport default interpolate;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}