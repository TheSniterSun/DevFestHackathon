{"ast":null,"code":"import center from '@turf/center';\nimport { GeoJSONReader, BufferOp, GeoJSONWriter } from 'turf-jsts';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { geoAzimuthalEquidistant } from 'd3-geo';\nimport { featureCollection, earthRadius, radiansToLength, lengthToRadians, feature } from '@turf/helpers';\n\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @name buffer\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=8] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\nfunction buffer(geojson, radius, options) {\n  // Optional params\n  options = options || {};\n\n  // use user supplied options or default values\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8;\n\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\");\n\n  // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n  if (radius === undefined) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        var multiBuffered = bufferFeature(feature, radius, units, steps);\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n  return bufferFeature(geojson, radius, units, steps);\n}\n\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=8] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson;\n\n  // Geometry Types faster than jsts\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function (geometry) {\n      var buffered = bufferFeature(geometry, radius, units, steps);\n      if (buffered) results.push(buffered);\n    });\n    return featureCollection(results);\n  }\n\n  // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection)\n  };\n\n  // JSTS buffer operation\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered);\n\n  // Detect if empty geometries\n  if (coordsIsNaN(buffered.coordinates)) return undefined;\n\n  // Unproject coordinates (convert to Degrees)\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection)\n  };\n  return feature(result, properties);\n}\n\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\n\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\n\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\n\n/**\n * Define Azimuthal Equidistant projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection\n */\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\nexport default buffer;","map":{"version":3,"names":["center","GeoJSONReader","BufferOp","GeoJSONWriter","featureEach","geomEach","geoAzimuthalEquidistant","featureCollection","earthRadius","radiansToLength","lengthToRadians","feature","buffer","geojson","radius","options","units","steps","Error","undefined","results","type","geometry","buffered","bufferFeature","push","multiBuffered","properties","projection","defineProjection","projected","coordinates","projectCoords","reader","geom","read","distance","bufferOp","writer","write","coordsIsNaN","result","unprojectCoords","coords","Array","isArray","isNaN","proj","map","coord","invert","rotation","rotate","scale"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/buffer/dist/es/index.js"],"sourcesContent":["import center from '@turf/center';\nimport { GeoJSONReader, BufferOp, GeoJSONWriter } from 'turf-jsts';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { geoAzimuthalEquidistant } from 'd3-geo';\nimport { featureCollection, earthRadius, radiansToLength, lengthToRadians, feature } from '@turf/helpers';\n\n/**\n * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.\n *\n * When using a negative radius, the resulting geometry may be invalid if\n * it's too small compared to the radius magnitude. If the input is a\n * FeatureCollection, only valid members will be returned in the output\n * FeatureCollection - i.e., the output collection may have fewer members than\n * the input, or even be empty.\n *\n * @name buffer\n * @param {FeatureCollection|Geometry|Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer (negative values are allowed)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] any of the options supported by turf units\n * @param {number} [options.steps=8] number of steps\n * @returns {FeatureCollection|Feature<Polygon|MultiPolygon>|undefined} buffered features\n * @example\n * var point = turf.point([-90.548630, 14.616599]);\n * var buffered = turf.buffer(point, 500, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [point, buffered]\n */\nfunction buffer(geojson, radius, options) {\n  // Optional params\n  options = options || {};\n\n  // use user supplied options or default values\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8;\n\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\");\n\n  // Allow negative buffers (\"erosion\") or zero-sized buffers (\"repair geometry\")\n  if (radius === undefined) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        var multiBuffered = bufferFeature(feature, radius, units, steps);\n        if (multiBuffered) {\n          featureEach(multiBuffered, function (buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n  return bufferFeature(geojson, radius, units, steps);\n}\n\n/**\n * Buffer single Feature/Geometry\n *\n * @private\n * @param {Feature<any>} geojson input to be buffered\n * @param {number} radius distance to draw the buffer\n * @param {string} [units='kilometers'] any of the options supported by turf units\n * @param {number} [steps=8] number of steps\n * @returns {Feature<Polygon|MultiPolygon>} buffered feature\n */\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson;\n\n  // Geometry Types faster than jsts\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function (geometry) {\n      var buffered = bufferFeature(geometry, radius, units, steps);\n      if (buffered) results.push(buffered);\n    });\n    return featureCollection(results);\n  }\n\n  // Project GeoJSON to Azimuthal Equidistant projection (convert to Meters)\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection),\n  };\n\n  // JSTS buffer operation\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered);\n\n  // Detect if empty geometries\n  if (coordsIsNaN(buffered.coordinates)) return undefined;\n\n  // Unproject coordinates (convert to Degrees)\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection),\n  };\n\n  return feature(result, properties);\n}\n\n/**\n * Coordinates isNaN\n *\n * @private\n * @param {Array<any>} coords GeoJSON Coordinates\n * @returns {boolean} if NaN exists\n */\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\n\n/**\n * Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} projected coordinates\n */\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function (coord) {\n    return projectCoords(coord, proj);\n  });\n}\n\n/**\n * Un-Project coordinates to projection\n *\n * @private\n * @param {Array<any>} coords to un-project\n * @param {GeoProjection} proj D3 Geo Projection\n * @returns {Array<any>} un-projected coordinates\n */\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function (coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\n\n/**\n * Define Azimuthal Equidistant projection\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Base projection on center of GeoJSON\n * @returns {GeoProjection} D3 Geo Azimuthal Equidistant Projection\n */\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\n\nexport default buffer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}