{"ast":null,"code":"import cleanCoords from \"@turf/clean-coords\";\nimport lineSegment from \"@turf/line-segment\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\nimport { bearingToAzimuth } from \"@turf/helpers\";\n/**\n * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`\n *\n * @name booleanParallel\n * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false if the lines are parallel\n * @example\n * var line1 = turf.lineString([[0, 0], [0, 1]]);\n * var line2 = turf.lineString([[1, 0], [1, 1]]);\n *\n * turf.booleanParallel(line1, line2);\n * //=true\n */\nfunction booleanParallel(line1, line2) {\n  // validation\n  if (!line1) throw new Error(\"line1 is required\");\n  if (!line2) throw new Error(\"line2 is required\");\n  var type1 = getType(line1, \"line1\");\n  if (type1 !== \"LineString\") throw new Error(\"line1 must be a LineString\");\n  var type2 = getType(line2, \"line2\");\n  if (type2 !== \"LineString\") throw new Error(\"line2 must be a LineString\");\n  var segments1 = lineSegment(cleanCoords(line1)).features;\n  var segments2 = lineSegment(cleanCoords(line2)).features;\n  for (var i = 0; i < segments1.length; i++) {\n    var segment1 = segments1[i].geometry.coordinates;\n    if (!segments2[i]) break;\n    var segment2 = segments2[i].geometry.coordinates;\n    if (!isParallel(segment1, segment2)) return false;\n  }\n  return true;\n}\n/**\n * Compares slopes and return result\n *\n * @private\n * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature\n * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature\n * @returns {boolean} if slopes are equal\n */\nfunction isParallel(segment1, segment2) {\n  var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));\n  var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));\n  return slope1 === slope2;\n}\n/**\n * Returns Feature's type\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {string} name of the variable\n * @returns {string} Feature's type\n */\nfunction getType(geojson, name) {\n  if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n  if (geojson.type) return geojson.type; // if GeoJSON geometry\n  throw new Error(\"Invalid GeoJSON object for \" + name);\n}\nexport default booleanParallel;","map":{"version":3,"names":["cleanCoords","lineSegment","rhumbBearing","bearingToAzimuth","booleanParallel","line1","line2","Error","type1","getType","type2","segments1","features","segments2","i","length","segment1","geometry","coordinates","segment2","isParallel","slope1","slope2","geojson","name","type"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/boolean-parallel/dist/es/index.js"],"sourcesContent":["import cleanCoords from \"@turf/clean-coords\";\nimport lineSegment from \"@turf/line-segment\";\nimport rhumbBearing from \"@turf/rhumb-bearing\";\nimport { bearingToAzimuth, } from \"@turf/helpers\";\n/**\n * Boolean-Parallel returns True if each segment of `line1` is parallel to the correspondent segment of `line2`\n *\n * @name booleanParallel\n * @param {Geometry|Feature<LineString>} line1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<LineString>} line2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false if the lines are parallel\n * @example\n * var line1 = turf.lineString([[0, 0], [0, 1]]);\n * var line2 = turf.lineString([[1, 0], [1, 1]]);\n *\n * turf.booleanParallel(line1, line2);\n * //=true\n */\nfunction booleanParallel(line1, line2) {\n    // validation\n    if (!line1)\n        throw new Error(\"line1 is required\");\n    if (!line2)\n        throw new Error(\"line2 is required\");\n    var type1 = getType(line1, \"line1\");\n    if (type1 !== \"LineString\")\n        throw new Error(\"line1 must be a LineString\");\n    var type2 = getType(line2, \"line2\");\n    if (type2 !== \"LineString\")\n        throw new Error(\"line2 must be a LineString\");\n    var segments1 = lineSegment(cleanCoords(line1)).features;\n    var segments2 = lineSegment(cleanCoords(line2)).features;\n    for (var i = 0; i < segments1.length; i++) {\n        var segment1 = segments1[i].geometry.coordinates;\n        if (!segments2[i])\n            break;\n        var segment2 = segments2[i].geometry.coordinates;\n        if (!isParallel(segment1, segment2))\n            return false;\n    }\n    return true;\n}\n/**\n * Compares slopes and return result\n *\n * @private\n * @param {Geometry|Feature<LineString>} segment1 Geometry or Feature\n * @param {Geometry|Feature<LineString>} segment2 Geometry or Feature\n * @returns {boolean} if slopes are equal\n */\nfunction isParallel(segment1, segment2) {\n    var slope1 = bearingToAzimuth(rhumbBearing(segment1[0], segment1[1]));\n    var slope2 = bearingToAzimuth(rhumbBearing(segment2[0], segment2[1]));\n    return slope1 === slope2;\n}\n/**\n * Returns Feature's type\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {string} name of the variable\n * @returns {string} Feature's type\n */\nfunction getType(geojson, name) {\n    if (geojson.geometry && geojson.geometry.type)\n        return geojson.geometry.type;\n    if (geojson.type)\n        return geojson.type; // if GeoJSON geometry\n    throw new Error(\"Invalid GeoJSON object for \" + name);\n}\nexport default booleanParallel;\n"],"mappings":"AAAA,OAAOA,WAAW,MAAM,oBAAoB;AAC5C,OAAOC,WAAW,MAAM,oBAAoB;AAC5C,OAAOC,YAAY,MAAM,qBAAqB;AAC9C,SAASC,gBAAgB,QAAS,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,KAAK,EAAEC,KAAK,EAAE;EACnC;EACA,IAAI,CAACD,KAAK,EACN,MAAM,IAAIE,KAAK,CAAC,mBAAmB,CAAC;EACxC,IAAI,CAACD,KAAK,EACN,MAAM,IAAIC,KAAK,CAAC,mBAAmB,CAAC;EACxC,IAAIC,KAAK,GAAGC,OAAO,CAACJ,KAAK,EAAE,OAAO,CAAC;EACnC,IAAIG,KAAK,KAAK,YAAY,EACtB,MAAM,IAAID,KAAK,CAAC,4BAA4B,CAAC;EACjD,IAAIG,KAAK,GAAGD,OAAO,CAACH,KAAK,EAAE,OAAO,CAAC;EACnC,IAAII,KAAK,KAAK,YAAY,EACtB,MAAM,IAAIH,KAAK,CAAC,4BAA4B,CAAC;EACjD,IAAII,SAAS,GAAGV,WAAW,CAACD,WAAW,CAACK,KAAK,CAAC,CAAC,CAACO,QAAQ;EACxD,IAAIC,SAAS,GAAGZ,WAAW,CAACD,WAAW,CAACM,KAAK,CAAC,CAAC,CAACM,QAAQ;EACxD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACvC,IAAIE,QAAQ,GAAGL,SAAS,CAACG,CAAC,CAAC,CAACG,QAAQ,CAACC,WAAW;IAChD,IAAI,CAACL,SAAS,CAACC,CAAC,CAAC,EACb;IACJ,IAAIK,QAAQ,GAAGN,SAAS,CAACC,CAAC,CAAC,CAACG,QAAQ,CAACC,WAAW;IAChD,IAAI,CAACE,UAAU,CAACJ,QAAQ,EAAEG,QAAQ,CAAC,EAC/B,OAAO,KAAK;EACpB;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAACJ,QAAQ,EAAEG,QAAQ,EAAE;EACpC,IAAIE,MAAM,GAAGlB,gBAAgB,CAACD,YAAY,CAACc,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;EACrE,IAAIM,MAAM,GAAGnB,gBAAgB,CAACD,YAAY,CAACiB,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;EACrE,OAAOE,MAAM,KAAKC,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,OAAOA,CAACc,OAAO,EAAEC,IAAI,EAAE;EAC5B,IAAID,OAAO,CAACN,QAAQ,IAAIM,OAAO,CAACN,QAAQ,CAACQ,IAAI,EACzC,OAAOF,OAAO,CAACN,QAAQ,CAACQ,IAAI;EAChC,IAAIF,OAAO,CAACE,IAAI,EACZ,OAAOF,OAAO,CAACE,IAAI,CAAC,CAAC;EACzB,MAAM,IAAIlB,KAAK,CAAC,6BAA6B,GAAGiB,IAAI,CAAC;AACzD;AACA,eAAepB,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}