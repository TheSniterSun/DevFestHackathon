{"ast":null,"code":"import { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\n// To-Do => Improve Typescript GeoJSON handling\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @name cleanCoords\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(geojson, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Backwards compatible with v4.0\n  var mutate = typeof options === \"object\" ? options.mutate : options;\n  if (!geojson) throw new Error(\"geojson is required\");\n  var type = getType(geojson);\n  // Store new \"clean\" points in this Array\n  var newCoords = [];\n  switch (type) {\n    case \"LineString\":\n      newCoords = cleanLine(geojson);\n      break;\n    case \"MultiLineString\":\n    case \"Polygon\":\n      getCoords(geojson).forEach(function (line) {\n        newCoords.push(cleanLine(line));\n      });\n      break;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (polygons) {\n        var polyPoints = [];\n        polygons.forEach(function (ring) {\n          polyPoints.push(cleanLine(ring));\n        });\n        newCoords.push(polyPoints);\n      });\n      break;\n    case \"Point\":\n      return geojson;\n    case \"MultiPoint\":\n      var existing = {};\n      getCoords(geojson).forEach(function (coord) {\n        var key = coord.join(\"-\");\n        if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n          newCoords.push(coord);\n          existing[key] = true;\n        }\n      });\n      break;\n    default:\n      throw new Error(type + \" geometry not supported\");\n  }\n  // Support input mutation\n  if (geojson.coordinates) {\n    if (mutate === true) {\n      geojson.coordinates = newCoords;\n      return geojson;\n    }\n    return {\n      type: type,\n      coordinates: newCoords\n    };\n  } else {\n    if (mutate === true) {\n      geojson.geometry.coordinates = newCoords;\n      return geojson;\n    }\n    return feature({\n      type: type,\n      coordinates: newCoords\n    }, geojson.properties, {\n      bbox: geojson.bbox,\n      id: geojson.id\n    });\n  }\n}\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line) {\n  var points = getCoords(line);\n  // handle \"clean\" segment\n  if (points.length === 2 && !equals(points[0], points[1])) return points;\n  var newPoints = [];\n  var secondToLast = points.length - 1;\n  var newPointsLength = newPoints.length;\n  newPoints.push(points[0]);\n  for (var i = 1; i < secondToLast; i++) {\n    var prevAddedPoint = newPoints[newPoints.length - 1];\n    if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1]) continue;else {\n      newPoints.push(points[i]);\n      newPointsLength = newPoints.length;\n      if (newPointsLength > 2) {\n        if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);\n      }\n    }\n  }\n  newPoints.push(points[points.length - 1]);\n  newPointsLength = newPoints.length;\n  if (equals(points[0], points[points.length - 1]) && newPointsLength < 4) throw new Error(\"invalid polygon\");\n  if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);\n  return newPoints;\n}\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Position} pt1 point\n * @param {Position} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n/**\n * Returns if `point` is on the segment between `start` and `end`.\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\n *\n * @private\n * @param {Position} start coord pair of start of line\n * @param {Position} end coord pair of end of line\n * @param {Position} point coord pair of point to check\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(start, end, point) {\n  var x = point[0],\n    y = point[1];\n  var startX = start[0],\n    startY = start[1];\n  var endX = end[0],\n    endY = end[1];\n  var dxc = x - startX;\n  var dyc = y - startY;\n  var dxl = endX - startX;\n  var dyl = endY - startY;\n  var cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\nexport default cleanCoords;","map":{"version":3,"names":["feature","getCoords","getType","cleanCoords","geojson","options","mutate","Error","type","newCoords","cleanLine","forEach","line","push","polygons","polyPoints","ring","existing","coord","key","join","Object","prototype","hasOwnProperty","call","coordinates","geometry","properties","bbox","id","points","length","equals","newPoints","secondToLast","newPointsLength","i","prevAddedPoint","isPointOnLineSegment","splice","pt1","pt2","start","end","point","x","y","startX","startY","endX","endY","dxc","dyc","dxl","dyl","cross","Math","abs"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/clean-coords/dist/es/index.js"],"sourcesContent":["import { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\n// To-Do => Improve Typescript GeoJSON handling\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @name cleanCoords\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Backwards compatible with v4.0\n    var mutate = typeof options === \"object\" ? options.mutate : options;\n    if (!geojson)\n        throw new Error(\"geojson is required\");\n    var type = getType(geojson);\n    // Store new \"clean\" points in this Array\n    var newCoords = [];\n    switch (type) {\n        case \"LineString\":\n            newCoords = cleanLine(geojson);\n            break;\n        case \"MultiLineString\":\n        case \"Polygon\":\n            getCoords(geojson).forEach(function (line) {\n                newCoords.push(cleanLine(line));\n            });\n            break;\n        case \"MultiPolygon\":\n            getCoords(geojson).forEach(function (polygons) {\n                var polyPoints = [];\n                polygons.forEach(function (ring) {\n                    polyPoints.push(cleanLine(ring));\n                });\n                newCoords.push(polyPoints);\n            });\n            break;\n        case \"Point\":\n            return geojson;\n        case \"MultiPoint\":\n            var existing = {};\n            getCoords(geojson).forEach(function (coord) {\n                var key = coord.join(\"-\");\n                if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n                    newCoords.push(coord);\n                    existing[key] = true;\n                }\n            });\n            break;\n        default:\n            throw new Error(type + \" geometry not supported\");\n    }\n    // Support input mutation\n    if (geojson.coordinates) {\n        if (mutate === true) {\n            geojson.coordinates = newCoords;\n            return geojson;\n        }\n        return { type: type, coordinates: newCoords };\n    }\n    else {\n        if (mutate === true) {\n            geojson.geometry.coordinates = newCoords;\n            return geojson;\n        }\n        return feature({ type: type, coordinates: newCoords }, geojson.properties, {\n            bbox: geojson.bbox,\n            id: geojson.id,\n        });\n    }\n}\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line) {\n    var points = getCoords(line);\n    // handle \"clean\" segment\n    if (points.length === 2 && !equals(points[0], points[1]))\n        return points;\n    var newPoints = [];\n    var secondToLast = points.length - 1;\n    var newPointsLength = newPoints.length;\n    newPoints.push(points[0]);\n    for (var i = 1; i < secondToLast; i++) {\n        var prevAddedPoint = newPoints[newPoints.length - 1];\n        if (points[i][0] === prevAddedPoint[0] &&\n            points[i][1] === prevAddedPoint[1])\n            continue;\n        else {\n            newPoints.push(points[i]);\n            newPointsLength = newPoints.length;\n            if (newPointsLength > 2) {\n                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\n                    newPoints.splice(newPoints.length - 2, 1);\n            }\n        }\n    }\n    newPoints.push(points[points.length - 1]);\n    newPointsLength = newPoints.length;\n    if (equals(points[0], points[points.length - 1]) && newPointsLength < 4)\n        throw new Error(\"invalid polygon\");\n    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\n        newPoints.splice(newPoints.length - 2, 1);\n    return newPoints;\n}\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Position} pt1 point\n * @param {Position} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1, pt2) {\n    return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n/**\n * Returns if `point` is on the segment between `start` and `end`.\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\n *\n * @private\n * @param {Position} start coord pair of start of line\n * @param {Position} end coord pair of end of line\n * @param {Position} point coord pair of point to check\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(start, end, point) {\n    var x = point[0], y = point[1];\n    var startX = start[0], startY = start[1];\n    var endX = end[0], endY = end[1];\n    var dxc = x - startX;\n    var dyc = y - startY;\n    var dxl = endX - startX;\n    var dyl = endY - startY;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0)\n        return false;\n    else if (Math.abs(dxl) >= Math.abs(dyl))\n        return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;\n    else\n        return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\nexport default cleanCoords;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}