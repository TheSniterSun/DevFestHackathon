{"ast":null,"code":"import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nexport default function bearing(start, end, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Reverse calculation\n  if (options.final === true) {\n    return calculateFinalBearing(start, end);\n  }\n  var coordinates1 = getCoord(start);\n  var coordinates2 = getCoord(end);\n  var lon1 = degreesToRadians(coordinates1[0]);\n  var lon2 = degreesToRadians(coordinates2[0]);\n  var lat1 = degreesToRadians(coordinates1[1]);\n  var lat2 = degreesToRadians(coordinates2[1]);\n  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n  // Swap start & end\n  var bear = bearing(end, start);\n  bear = (bear + 180) % 360;\n  return bear;\n}","map":{"version":3,"names":["degreesToRadians","radiansToDegrees","getCoord","bearing","start","end","options","final","calculateFinalBearing","coordinates1","coordinates2","lon1","lon2","lat1","lat2","a","Math","sin","cos","b","atan2","bear"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/bearing/dist/es/index.js"],"sourcesContent":["import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nexport default function bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,gBAAgB,QAAQ,eAAe;AAClE,SAASC,QAAQ,QAAQ,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,OAAOA,CAACC,KAAK,EAAEC,GAAG,EAAEC,OAAO,EAAE;EACjD,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC;EACA,IAAIA,OAAO,CAACC,KAAK,KAAK,IAAI,EAAE;IACxB,OAAOC,qBAAqB,CAACJ,KAAK,EAAEC,GAAG,CAAC;EAC5C;EACA,IAAII,YAAY,GAAGP,QAAQ,CAACE,KAAK,CAAC;EAClC,IAAIM,YAAY,GAAGR,QAAQ,CAACG,GAAG,CAAC;EAChC,IAAIM,IAAI,GAAGX,gBAAgB,CAACS,YAAY,CAAC,CAAC,CAAC,CAAC;EAC5C,IAAIG,IAAI,GAAGZ,gBAAgB,CAACU,YAAY,CAAC,CAAC,CAAC,CAAC;EAC5C,IAAIG,IAAI,GAAGb,gBAAgB,CAACS,YAAY,CAAC,CAAC,CAAC,CAAC;EAC5C,IAAIK,IAAI,GAAGd,gBAAgB,CAACU,YAAY,CAAC,CAAC,CAAC,CAAC;EAC5C,IAAIK,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACL,IAAI,GAAGD,IAAI,CAAC,GAAGK,IAAI,CAACE,GAAG,CAACJ,IAAI,CAAC;EAC9C,IAAIK,CAAC,GAAGH,IAAI,CAACE,GAAG,CAACL,IAAI,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACH,IAAI,CAAC,GACnCE,IAAI,CAACC,GAAG,CAACJ,IAAI,CAAC,GAAGG,IAAI,CAACE,GAAG,CAACJ,IAAI,CAAC,GAAGE,IAAI,CAACE,GAAG,CAACN,IAAI,GAAGD,IAAI,CAAC;EAC3D,OAAOV,gBAAgB,CAACe,IAAI,CAACI,KAAK,CAACL,CAAC,EAAEI,CAAC,CAAC,CAAC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASX,qBAAqBA,CAACJ,KAAK,EAAEC,GAAG,EAAE;EACvC;EACA,IAAIgB,IAAI,GAAGlB,OAAO,CAACE,GAAG,EAAED,KAAK,CAAC;EAC9BiB,IAAI,GAAG,CAACA,IAAI,GAAG,GAAG,IAAI,GAAG;EACzB,OAAOA,IAAI;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}