{"ast":null,"code":"/**\r\n * DBSCAN - Density based clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n/**\r\n * DBSCAN class construcotr\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {DBSCAN}\r\n */\nfunction DBSCAN(dataset, epsilon, minPts, distanceFunction) {\n  /** @type {Array} */\n  this.dataset = [];\n  /** @type {number} */\n  this.epsilon = 1;\n  /** @type {number} */\n  this.minPts = 2;\n  /** @type {function} */\n  this.distance = this._euclideanDistance;\n  /** @type {Array} */\n  this.clusters = [];\n  /** @type {Array} */\n  this.noise = [];\n\n  // temporary variables used during computation\n\n  /** @type {Array} */\n  this._visited = [];\n  /** @type {Array} */\n  this._assigned = [];\n  /** @type {number} */\n  this._datasetLength = 0;\n  this._init(dataset, epsilon, minPts, distanceFunction);\n}\n;\n\n/******************************************************************************/\n// public functions\n\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {undefined}\r\n * @access public\r\n */\nDBSCAN.prototype.run = function (dataset, epsilon, minPts, distanceFunction) {\n  this._init(dataset, epsilon, minPts, distanceFunction);\n  for (var pointId = 0; pointId < this._datasetLength; pointId++) {\n    // if point is not visited, check if it forms a cluster\n    if (this._visited[pointId] !== 1) {\n      this._visited[pointId] = 1;\n\n      // if closest neighborhood is too small to form a cluster, mark as noise\n      var neighbors = this._regionQuery(pointId);\n      if (neighbors.length < this.minPts) {\n        this.noise.push(pointId);\n      } else {\n        // create new cluster and add point\n        var clusterId = this.clusters.length;\n        this.clusters.push([]);\n        this._addToCluster(pointId, clusterId);\n        this._expandCluster(clusterId, neighbors);\n      }\n    }\n  }\n  return this.clusters;\n};\n\n/******************************************************************************/\n// protected functions\n\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\nDBSCAN.prototype._init = function (dataset, epsilon, minPts, distance) {\n  if (dataset) {\n    if (!(dataset instanceof Array)) {\n      throw Error('Dataset must be of type array, ' + typeof dataset + ' given');\n    }\n    this.dataset = dataset;\n    this.clusters = [];\n    this.noise = [];\n    this._datasetLength = dataset.length;\n    this._visited = new Array(this._datasetLength);\n    this._assigned = new Array(this._datasetLength);\n  }\n  if (epsilon) {\n    this.epsilon = epsilon;\n  }\n  if (minPts) {\n    this.minPts = minPts;\n  }\n  if (distance) {\n    this.distance = distance;\n  }\n};\n\n/**\r\n * Expand cluster to closest points of given neighborhood\r\n *\r\n * @param {number} clusterId\r\n * @param {Array} neighbors\r\n * @returns {undefined}\r\n * @access protected\r\n */\nDBSCAN.prototype._expandCluster = function (clusterId, neighbors) {\n  /**\r\n   * It's very important to calculate length of neighbors array each time,\r\n   * as the number of elements changes over time\r\n   */\n  for (var i = 0; i < neighbors.length; i++) {\n    var pointId2 = neighbors[i];\n    if (this._visited[pointId2] !== 1) {\n      this._visited[pointId2] = 1;\n      var neighbors2 = this._regionQuery(pointId2);\n      if (neighbors2.length >= this.minPts) {\n        neighbors = this._mergeArrays(neighbors, neighbors2);\n      }\n    }\n\n    // add to cluster\n    if (this._assigned[pointId2] !== 1) {\n      this._addToCluster(pointId2, clusterId);\n    }\n  }\n};\n\n/**\r\n * Add new point to cluster\r\n *\r\n * @param {number} pointId\r\n * @param {number} clusterId\r\n */\nDBSCAN.prototype._addToCluster = function (pointId, clusterId) {\n  this.clusters[clusterId].push(pointId);\n  this._assigned[pointId] = 1;\n};\n\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId,\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\nDBSCAN.prototype._regionQuery = function (pointId) {\n  var neighbors = [];\n  for (var id = 0; id < this._datasetLength; id++) {\n    var dist = this.distance(this.dataset[pointId], this.dataset[id]);\n    if (dist < this.epsilon) {\n      neighbors.push(id);\n    }\n  }\n  return neighbors;\n};\n\n/******************************************************************************/\n// helpers\n\n/**\r\n * @param {Array} a\r\n * @param {Array} b\r\n * @returns {Array}\r\n * @access protected\r\n */\nDBSCAN.prototype._mergeArrays = function (a, b) {\n  var len = b.length;\n  for (var i = 0; i < len; i++) {\n    var P = b[i];\n    if (a.indexOf(P) < 0) {\n      a.push(P);\n    }\n  }\n  return a;\n};\n\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\nDBSCAN.prototype._euclideanDistance = function (p, q) {\n  var sum = 0;\n  var i = Math.min(p.length, q.length);\n  while (i--) {\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n  return Math.sqrt(sum);\n};\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = DBSCAN;\n}","map":{"version":3,"names":["DBSCAN","dataset","epsilon","minPts","distanceFunction","distance","_euclideanDistance","clusters","noise","_visited","_assigned","_datasetLength","_init","prototype","run","pointId","neighbors","_regionQuery","length","push","clusterId","_addToCluster","_expandCluster","Array","Error","i","pointId2","neighbors2","_mergeArrays","id","dist","a","b","len","P","indexOf","p","q","sum","Math","min","sqrt","module","exports"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/density-clustering/lib/DBSCAN.js"],"sourcesContent":["/**\r\n * DBSCAN - Density based clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * DBSCAN class construcotr\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {DBSCAN}\r\n */\r\nfunction DBSCAN(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {Array} */\r\n  this.dataset = [];\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 2;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n  /** @type {Array} */\r\n  this.clusters = [];\r\n  /** @type {Array} */\r\n  this.noise = [];\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._visited = [];\r\n  /** @type {Array} */\r\n  this._assigned = [];\r\n  /** @type {number} */\r\n  this._datasetLength = 0;\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n};\r\n\r\n/******************************************************************************/\r\n// public functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nDBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0; pointId < this._datasetLength; pointId++) {\r\n    // if point is not visited, check if it forms a cluster\r\n    if (this._visited[pointId] !== 1) {\r\n      this._visited[pointId] = 1;\r\n\r\n      // if closest neighborhood is too small to form a cluster, mark as noise\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      if (neighbors.length < this.minPts) {\r\n        this.noise.push(pointId);\r\n      } else {\r\n        // create new cluster and add point\r\n        var clusterId = this.clusters.length;\r\n        this.clusters.push([]);\r\n        this._addToCluster(pointId, clusterId);\r\n\r\n        this._expandCluster(clusterId, neighbors);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this.noise = [];\r\n\r\n    this._datasetLength = dataset.length;\r\n    this._visited = new Array(this._datasetLength);\r\n    this._assigned = new Array(this._datasetLength);\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Expand cluster to closest points of given neighborhood\r\n *\r\n * @param {number} clusterId\r\n * @param {Array} neighbors\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._expandCluster = function(clusterId, neighbors) {\r\n\r\n  /**\r\n   * It's very important to calculate length of neighbors array each time,\r\n   * as the number of elements changes over time\r\n   */\r\n  for (var i = 0; i < neighbors.length; i++) {\r\n    var pointId2 = neighbors[i];\r\n\r\n    if (this._visited[pointId2] !== 1) {\r\n      this._visited[pointId2] = 1;\r\n      var neighbors2 = this._regionQuery(pointId2);\r\n\r\n      if (neighbors2.length >= this.minPts) {\r\n        neighbors = this._mergeArrays(neighbors, neighbors2);\r\n      }\r\n    }\r\n\r\n    // add to cluster\r\n    if (this._assigned[pointId2] !== 1) {\r\n      this._addToCluster(pointId2, clusterId);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Add new point to cluster\r\n *\r\n * @param {number} pointId\r\n * @param {number} clusterId\r\n */\r\nDBSCAN.prototype._addToCluster = function(pointId, clusterId) {\r\n  this.clusters[clusterId].push(pointId);\r\n  this._assigned[pointId] = 1;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId,\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._regionQuery = function(pointId) {\r\n  var neighbors = [];\r\n\r\n  for (var id = 0; id < this._datasetLength; id++) {\r\n    var dist = this.distance(this.dataset[pointId], this.dataset[id]);\r\n    if (dist < this.epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * @param {Array} a\r\n * @param {Array} b\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._mergeArrays = function(a, b) {\r\n  var len = b.length;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var P = b[i];\r\n    if (a.indexOf(P) < 0) {\r\n      a.push(P);\r\n    }\r\n  }\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = DBSCAN;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}