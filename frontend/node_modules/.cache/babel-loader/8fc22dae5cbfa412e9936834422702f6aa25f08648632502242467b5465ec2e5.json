{"ast":null,"code":"import length from '@turf/length';\nimport lineSliceAlong from '@turf/line-slice-along';\nimport { flattenEach } from '@turf/meta';\nimport { isObject, featureCollection } from '@turf/helpers';\n\n/**\n * Divides a {@link LineString} into chunks of a specified length.\n * If the line is shorter than the segment length then the original line is returned.\n *\n * @name lineChunk\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split\n * @param {number} segmentLength how long to make each segment\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end\n * @returns {FeatureCollection<LineString>} collection of line segments\n * @example\n * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);\n *\n * var chunk = turf.lineChunk(line, 15, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [chunk];\n */\nfunction lineChunk(geojson, segmentLength, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var reverse = options.reverse;\n\n  // Validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (segmentLength <= 0) throw new Error(\"segmentLength must be greater than 0\");\n\n  // Container\n  var results = [];\n\n  // Flatten each feature to simple LineString\n  flattenEach(geojson, function (feature) {\n    // reverses coordinates to start the first chunked segment at the end\n    if (reverse) feature.geometry.coordinates = feature.geometry.coordinates.reverse();\n    sliceLineSegments(feature, segmentLength, units, function (segment) {\n      results.push(segment);\n    });\n  });\n  return featureCollection(results);\n}\n\n/**\n * Slice Line Segments\n *\n * @private\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {number} segmentLength how long to make each segment\n * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {Function} callback iterate over sliced line segments\n * @returns {void}\n */\nfunction sliceLineSegments(line, segmentLength, units, callback) {\n  var lineLength = length(line, {\n    units: units\n  });\n\n  // If the line is shorter than the segment length then the orginal line is returned.\n  if (lineLength <= segmentLength) return callback(line);\n  var numberOfSegments = lineLength / segmentLength;\n\n  // If numberOfSegments is integer, no need to plus 1\n  if (!Number.isInteger(numberOfSegments)) {\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\n  }\n  for (var i = 0; i < numberOfSegments; i++) {\n    var outline = lineSliceAlong(line, segmentLength * i, segmentLength * (i + 1), {\n      units: units\n    });\n    callback(outline, i);\n  }\n}\nexport default lineChunk;","map":{"version":3,"names":["length","lineSliceAlong","flattenEach","isObject","featureCollection","lineChunk","geojson","segmentLength","options","Error","units","reverse","results","feature","geometry","coordinates","sliceLineSegments","segment","push","line","callback","lineLength","numberOfSegments","Number","isInteger","Math","floor","i","outline"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/line-chunk/dist/es/index.js"],"sourcesContent":["import length from '@turf/length';\nimport lineSliceAlong from '@turf/line-slice-along';\nimport { flattenEach } from '@turf/meta';\nimport { isObject, featureCollection } from '@turf/helpers';\n\n/**\n * Divides a {@link LineString} into chunks of a specified length.\n * If the line is shorter than the segment length then the original line is returned.\n *\n * @name lineChunk\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geojson the lines to split\n * @param {number} segmentLength how long to make each segment\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.reverse=false] reverses coordinates to start the first chunked segment at the end\n * @returns {FeatureCollection<LineString>} collection of line segments\n * @example\n * var line = turf.lineString([[-95, 40], [-93, 45], [-85, 50]]);\n *\n * var chunk = turf.lineChunk(line, 15, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [chunk];\n */\nfunction lineChunk(geojson, segmentLength, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var reverse = options.reverse;\n\n  // Validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (segmentLength <= 0)\n    throw new Error(\"segmentLength must be greater than 0\");\n\n  // Container\n  var results = [];\n\n  // Flatten each feature to simple LineString\n  flattenEach(geojson, function (feature) {\n    // reverses coordinates to start the first chunked segment at the end\n    if (reverse)\n      feature.geometry.coordinates = feature.geometry.coordinates.reverse();\n\n    sliceLineSegments(feature, segmentLength, units, function (segment) {\n      results.push(segment);\n    });\n  });\n  return featureCollection(results);\n}\n\n/**\n * Slice Line Segments\n *\n * @private\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {number} segmentLength how long to make each segment\n * @param {string}[units='kilometers'] units can be degrees, radians, miles, or kilometers\n * @param {Function} callback iterate over sliced line segments\n * @returns {void}\n */\nfunction sliceLineSegments(line, segmentLength, units, callback) {\n  var lineLength = length(line, { units: units });\n\n  // If the line is shorter than the segment length then the orginal line is returned.\n  if (lineLength <= segmentLength) return callback(line);\n\n  var numberOfSegments = lineLength / segmentLength;\n\n  // If numberOfSegments is integer, no need to plus 1\n  if (!Number.isInteger(numberOfSegments)) {\n    numberOfSegments = Math.floor(numberOfSegments) + 1;\n  }\n\n  for (var i = 0; i < numberOfSegments; i++) {\n    var outline = lineSliceAlong(\n      line,\n      segmentLength * i,\n      segmentLength * (i + 1),\n      { units: units }\n    );\n    callback(outline, i);\n  }\n}\n\nexport default lineChunk;\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,cAAc;AACjC,OAAOC,cAAc,MAAM,wBAAwB;AACnD,SAASC,WAAW,QAAQ,YAAY;AACxC,SAASC,QAAQ,EAAEC,iBAAiB,QAAQ,eAAe;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACC,OAAO,EAAEC,aAAa,EAAEC,OAAO,EAAE;EAClD;EACAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAI,CAACL,QAAQ,CAACK,OAAO,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EAC7D,IAAIC,KAAK,GAAGF,OAAO,CAACE,KAAK;EACzB,IAAIC,OAAO,GAAGH,OAAO,CAACG,OAAO;;EAE7B;EACA,IAAI,CAACL,OAAO,EAAE,MAAM,IAAIG,KAAK,CAAC,qBAAqB,CAAC;EACpD,IAAIF,aAAa,IAAI,CAAC,EACpB,MAAM,IAAIE,KAAK,CAAC,sCAAsC,CAAC;;EAEzD;EACA,IAAIG,OAAO,GAAG,EAAE;;EAEhB;EACAV,WAAW,CAACI,OAAO,EAAE,UAAUO,OAAO,EAAE;IACtC;IACA,IAAIF,OAAO,EACTE,OAAO,CAACC,QAAQ,CAACC,WAAW,GAAGF,OAAO,CAACC,QAAQ,CAACC,WAAW,CAACJ,OAAO,CAAC,CAAC;IAEvEK,iBAAiB,CAACH,OAAO,EAAEN,aAAa,EAAEG,KAAK,EAAE,UAAUO,OAAO,EAAE;MAClEL,OAAO,CAACM,IAAI,CAACD,OAAO,CAAC;IACvB,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOb,iBAAiB,CAACQ,OAAO,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,iBAAiBA,CAACG,IAAI,EAAEZ,aAAa,EAAEG,KAAK,EAAEU,QAAQ,EAAE;EAC/D,IAAIC,UAAU,GAAGrB,MAAM,CAACmB,IAAI,EAAE;IAAET,KAAK,EAAEA;EAAM,CAAC,CAAC;;EAE/C;EACA,IAAIW,UAAU,IAAId,aAAa,EAAE,OAAOa,QAAQ,CAACD,IAAI,CAAC;EAEtD,IAAIG,gBAAgB,GAAGD,UAAU,GAAGd,aAAa;;EAEjD;EACA,IAAI,CAACgB,MAAM,CAACC,SAAS,CAACF,gBAAgB,CAAC,EAAE;IACvCA,gBAAgB,GAAGG,IAAI,CAACC,KAAK,CAACJ,gBAAgB,CAAC,GAAG,CAAC;EACrD;EAEA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,gBAAgB,EAAEK,CAAC,EAAE,EAAE;IACzC,IAAIC,OAAO,GAAG3B,cAAc,CAC1BkB,IAAI,EACJZ,aAAa,GAAGoB,CAAC,EACjBpB,aAAa,IAAIoB,CAAC,GAAG,CAAC,CAAC,EACvB;MAAEjB,KAAK,EAAEA;IAAM,CACjB,CAAC;IACDU,QAAQ,CAACQ,OAAO,EAAED,CAAC,CAAC;EACtB;AACF;AAEA,eAAetB,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}