{"ast":null,"code":"import { geomReduce } from \"@turf/meta\";\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nexport default function area(geojson) {\n  return geomReduce(geojson, function (value, geom) {\n    return value + calculateArea(geom);\n  }, 0);\n}\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n  var total = 0;\n  var i;\n  switch (geom.type) {\n    case \"Polygon\":\n      return polygonArea(geom.coordinates);\n    case \"MultiPolygon\":\n      for (i = 0; i < geom.coordinates.length; i++) {\n        total += polygonArea(geom.coordinates[i]);\n      }\n      return total;\n    case \"Point\":\n    case \"MultiPoint\":\n    case \"LineString\":\n    case \"MultiLineString\":\n      return 0;\n  }\n  return 0;\n}\nfunction polygonArea(coords) {\n  var total = 0;\n  if (coords && coords.length > 0) {\n    total += Math.abs(ringArea(coords[0]));\n    for (var i = 1; i < coords.length; i++) {\n      total -= Math.abs(ringArea(coords[i]));\n    }\n  }\n  return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n  var p1;\n  var p2;\n  var p3;\n  var lowerIndex;\n  var middleIndex;\n  var upperIndex;\n  var i;\n  var total = 0;\n  var coordsLength = coords.length;\n  if (coordsLength > 2) {\n    for (i = 0; i < coordsLength; i++) {\n      if (i === coordsLength - 2) {\n        // i = N-2\n        lowerIndex = coordsLength - 2;\n        middleIndex = coordsLength - 1;\n        upperIndex = 0;\n      } else if (i === coordsLength - 1) {\n        // i = N-1\n        lowerIndex = coordsLength - 1;\n        middleIndex = 0;\n        upperIndex = 1;\n      } else {\n        // i = 0 to N-3\n        lowerIndex = i;\n        middleIndex = i + 1;\n        upperIndex = i + 2;\n      }\n      p1 = coords[lowerIndex];\n      p2 = coords[middleIndex];\n      p3 = coords[upperIndex];\n      total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n    }\n    total = total * RADIUS * RADIUS / 2;\n  }\n  return total;\n}\nfunction rad(num) {\n  return num * Math.PI / 180;\n}","map":{"version":3,"names":["geomReduce","RADIUS","area","geojson","value","geom","calculateArea","total","i","type","polygonArea","coordinates","length","coords","Math","abs","ringArea","p1","p2","p3","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","num","PI"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/area/dist/es/index.js"],"sourcesContent":["import { geomReduce } from \"@turf/meta\";\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nexport default function area(geojson) {\n    return geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                // i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                // i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = (total * RADIUS * RADIUS) / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return (num * Math.PI) / 180;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}