{"ast":null,"code":"import clone from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\n *\n * @name clustersKmeans\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var options = {numberOfClusters: 7};\n * var clustered = turf.clustersKmeans(points, options);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersKmeans(points, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Default Params\n  var count = points.features.length;\n  options.numberOfClusters = options.numberOfClusters || Math.round(Math.sqrt(count / 2));\n  // numberOfClusters can't be greater than the number of points\n  // fallbacks to count\n  if (options.numberOfClusters > count) options.numberOfClusters = count;\n  // Clone points to prevent any mutations (enabled by default)\n  if (options.mutate !== true) points = clone(points);\n  // collect points coordinates\n  var data = coordAll(points);\n  // create seed to avoid skmeans to drift\n  var initialCentroids = data.slice(0, options.numberOfClusters);\n  // create skmeans clusters\n  var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids);\n  // store centroids {clusterId: [number, number]}\n  var centroids = {};\n  skmeansResult.centroids.forEach(function (coord, idx) {\n    centroids[idx] = coord;\n  });\n  // add associated cluster number\n  featureEach(points, function (point, index) {\n    var clusterId = skmeansResult.idxs[index];\n    point.properties.cluster = clusterId;\n    point.properties.centroid = centroids[clusterId];\n  });\n  return points;\n}\nexport default clustersKmeans;","map":{"version":3,"names":["clone","coordAll","featureEach","skmeans","clustersKmeans","points","options","count","features","length","numberOfClusters","Math","round","sqrt","mutate","data","initialCentroids","slice","skmeansResult","centroids","forEach","coord","idx","point","index","clusterId","idxs","properties","cluster","centroid"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/clusters-kmeans/dist/es/index.js"],"sourcesContent":["import clone from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\n *\n * @name clustersKmeans\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var options = {numberOfClusters: 7};\n * var clustered = turf.clustersKmeans(points, options);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersKmeans(points, options) {\n    if (options === void 0) { options = {}; }\n    // Default Params\n    var count = points.features.length;\n    options.numberOfClusters =\n        options.numberOfClusters || Math.round(Math.sqrt(count / 2));\n    // numberOfClusters can't be greater than the number of points\n    // fallbacks to count\n    if (options.numberOfClusters > count)\n        options.numberOfClusters = count;\n    // Clone points to prevent any mutations (enabled by default)\n    if (options.mutate !== true)\n        points = clone(points);\n    // collect points coordinates\n    var data = coordAll(points);\n    // create seed to avoid skmeans to drift\n    var initialCentroids = data.slice(0, options.numberOfClusters);\n    // create skmeans clusters\n    var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids);\n    // store centroids {clusterId: [number, number]}\n    var centroids = {};\n    skmeansResult.centroids.forEach(function (coord, idx) {\n        centroids[idx] = coord;\n    });\n    // add associated cluster number\n    featureEach(points, function (point, index) {\n        var clusterId = skmeansResult.idxs[index];\n        point.properties.cluster = clusterId;\n        point.properties.centroid = centroids[clusterId];\n    });\n    return points;\n}\nexport default clustersKmeans;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,aAAa;AAC/B,SAASC,QAAQ,EAAEC,WAAW,QAAQ,YAAY;AAClD,OAAOC,OAAO,MAAM,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,MAAM,EAAEC,OAAO,EAAE;EACrC,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC;EACA,IAAIC,KAAK,GAAGF,MAAM,CAACG,QAAQ,CAACC,MAAM;EAClCH,OAAO,CAACI,gBAAgB,GACpBJ,OAAO,CAACI,gBAAgB,IAAIC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,IAAI,CAACN,KAAK,GAAG,CAAC,CAAC,CAAC;EAChE;EACA;EACA,IAAID,OAAO,CAACI,gBAAgB,GAAGH,KAAK,EAChCD,OAAO,CAACI,gBAAgB,GAAGH,KAAK;EACpC;EACA,IAAID,OAAO,CAACQ,MAAM,KAAK,IAAI,EACvBT,MAAM,GAAGL,KAAK,CAACK,MAAM,CAAC;EAC1B;EACA,IAAIU,IAAI,GAAGd,QAAQ,CAACI,MAAM,CAAC;EAC3B;EACA,IAAIW,gBAAgB,GAAGD,IAAI,CAACE,KAAK,CAAC,CAAC,EAAEX,OAAO,CAACI,gBAAgB,CAAC;EAC9D;EACA,IAAIQ,aAAa,GAAGf,OAAO,CAACY,IAAI,EAAET,OAAO,CAACI,gBAAgB,EAAEM,gBAAgB,CAAC;EAC7E;EACA,IAAIG,SAAS,GAAG,CAAC,CAAC;EAClBD,aAAa,CAACC,SAAS,CAACC,OAAO,CAAC,UAAUC,KAAK,EAAEC,GAAG,EAAE;IAClDH,SAAS,CAACG,GAAG,CAAC,GAAGD,KAAK;EAC1B,CAAC,CAAC;EACF;EACAnB,WAAW,CAACG,MAAM,EAAE,UAAUkB,KAAK,EAAEC,KAAK,EAAE;IACxC,IAAIC,SAAS,GAAGP,aAAa,CAACQ,IAAI,CAACF,KAAK,CAAC;IACzCD,KAAK,CAACI,UAAU,CAACC,OAAO,GAAGH,SAAS;IACpCF,KAAK,CAACI,UAAU,CAACE,QAAQ,GAAGV,SAAS,CAACM,SAAS,CAAC;EACpD,CAAC,CAAC;EACF,OAAOpB,MAAM;AACjB;AACA,eAAeD,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}