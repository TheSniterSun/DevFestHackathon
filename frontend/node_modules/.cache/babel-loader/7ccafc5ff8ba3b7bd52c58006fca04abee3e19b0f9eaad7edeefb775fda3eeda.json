{"ast":null,"code":"import spatialWeight from \"@turf/distance-weight\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * Moran's I measures patterns of attribute values associated with features.\n * The method reveal whether similar values tend to occur near each other,\n * or whether high or low values are interspersed.\n *\n * Moran's I > 0 means a clusterd pattern.\n * Moran's I < 0 means a dispersed pattern.\n * Moran's I = 0 means a random pattern.\n *\n * In order to test the significance of the result. The z score is calculated.\n * A positive enough z-score (ex. >1.96) indicates clustering,\n * while a negative enough z-score (ex. <-1.96) indicates a dispersed pattern.\n *\n * the z-score can be calculated based on a normal or random assumption.\n *\n * **Bibliography***\n *\n * 1. [Moran's I](https://en.wikipedia.org/wiki/Moran%27s_I)\n *\n * 2. [pysal](http://pysal.readthedocs.io/en/latest/index.html)\n *\n * 3. Andy Mitchell, The ESRI Guide to GIS Analysis Volume 2: Spatial Measurements & Statistics.\n *\n * @name moranIndex\n * @param {FeatureCollection<any>} fc\n * @param {Object} options\n * @param {string} options.inputField the property name, must contain numeric values\n * @param {number} [options.threshold=100000] the distance threshold\n * @param {number} [options.p=2] the Minkowski p-norm distance parameter\n * @param {boolean} [options.binary=false] whether transfrom the distance to binary\n * @param {number} [options.alpha=-1] the distance decay parameter\n * @param {boolean} [options.standardization=true] wheter row standardization the distance\n * @returns {MoranIndex}\n * @example\n *\n * const bbox = [-65, 40, -63, 42];\n * const dataset = turf.randomPoint(100, { bbox: bbox });\n *\n * const result = turf.moranIndex(dataset, {\n *   inputField: 'CRIME',\n * });\n */\nexport default function (fc, options) {\n  var inputField = options.inputField;\n  var threshold = options.threshold || 100000;\n  var p = options.p || 2;\n  var binary = options.binary || false;\n  var alpha = options.alpha || -1;\n  var standardization = options.standardization || true;\n  var weight = spatialWeight(fc, {\n    alpha: alpha,\n    binary: binary,\n    p: p,\n    standardization: standardization,\n    threshold: threshold\n  });\n  var y = [];\n  featureEach(fc, function (feature) {\n    var feaProperties = feature.properties || {};\n    // validate inputField exists\n    y.push(feaProperties[inputField]);\n  });\n  var yMean = mean(y);\n  var yVar = variance(y);\n  var weightSum = 0;\n  var s0 = 0;\n  var s1 = 0;\n  var s2 = 0;\n  var n = weight.length;\n  // validate y.length is the same as weight.length\n  for (var i = 0; i < n; i++) {\n    var subS2 = 0;\n    for (var j = 0; j < n; j++) {\n      weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);\n      s0 += weight[i][j];\n      s1 += Math.pow(weight[i][j] + weight[j][i], 2);\n      subS2 += weight[i][j] + weight[j][i];\n    }\n    s2 += Math.pow(subS2, 2);\n  }\n  s1 = 0.5 * s1;\n  var moranIndex = weightSum / s0 / yVar;\n  var expectedMoranIndex = -1 / (n - 1);\n  var vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);\n  var vDen = (n - 1) * (n + 1) * (s0 * s0);\n  var vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;\n  var stdNorm = Math.sqrt(vNorm);\n  var zNorm = (moranIndex - expectedMoranIndex) / stdNorm;\n  return {\n    expectedMoranIndex: expectedMoranIndex,\n    moranIndex: moranIndex,\n    stdNorm: stdNorm,\n    zNorm: zNorm\n  };\n}\n/**\n * get mean of a list\n * @param {number[]} y\n * @returns {number}\n *\n */\nfunction mean(y) {\n  var sum = 0;\n  for (var _i = 0, y_1 = y; _i < y_1.length; _i++) {\n    var item = y_1[_i];\n    sum += item;\n  }\n  return sum / y.length;\n}\n/**\n * get variance of a list\n * @param {number[]} y\n * @returns {number}\n *\n */\nfunction variance(y) {\n  var yMean = mean(y);\n  var sum = 0;\n  for (var _i = 0, y_2 = y; _i < y_2.length; _i++) {\n    var item = y_2[_i];\n    sum += Math.pow(item - yMean, 2);\n  }\n  return sum / y.length;\n}\n/**\n * @typedef {Object} MoranIndex\n * @property {number} moranIndex the moran's Index of the observed feature set\n * @property {number} expectedMoranIndex the moran's Index of the random distribution\n * @property {number} stdNorm the standard devitaion of the random distribution\n * @property {number} zNorm the z-score of the observe samples with regard to the random distribution\n */","map":{"version":3,"names":["spatialWeight","featureEach","fc","options","inputField","threshold","p","binary","alpha","standardization","weight","y","feature","feaProperties","properties","push","yMean","mean","yVar","variance","weightSum","s0","s1","s2","n","length","i","subS2","j","Math","pow","moranIndex","expectedMoranIndex","vNum","vDen","vNorm","stdNorm","sqrt","zNorm","sum","_i","y_1","item","y_2"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/moran-index/dist/es/index.js"],"sourcesContent":["import spatialWeight from \"@turf/distance-weight\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * Moran's I measures patterns of attribute values associated with features.\n * The method reveal whether similar values tend to occur near each other,\n * or whether high or low values are interspersed.\n *\n * Moran's I > 0 means a clusterd pattern.\n * Moran's I < 0 means a dispersed pattern.\n * Moran's I = 0 means a random pattern.\n *\n * In order to test the significance of the result. The z score is calculated.\n * A positive enough z-score (ex. >1.96) indicates clustering,\n * while a negative enough z-score (ex. <-1.96) indicates a dispersed pattern.\n *\n * the z-score can be calculated based on a normal or random assumption.\n *\n * **Bibliography***\n *\n * 1. [Moran's I](https://en.wikipedia.org/wiki/Moran%27s_I)\n *\n * 2. [pysal](http://pysal.readthedocs.io/en/latest/index.html)\n *\n * 3. Andy Mitchell, The ESRI Guide to GIS Analysis Volume 2: Spatial Measurements & Statistics.\n *\n * @name moranIndex\n * @param {FeatureCollection<any>} fc\n * @param {Object} options\n * @param {string} options.inputField the property name, must contain numeric values\n * @param {number} [options.threshold=100000] the distance threshold\n * @param {number} [options.p=2] the Minkowski p-norm distance parameter\n * @param {boolean} [options.binary=false] whether transfrom the distance to binary\n * @param {number} [options.alpha=-1] the distance decay parameter\n * @param {boolean} [options.standardization=true] wheter row standardization the distance\n * @returns {MoranIndex}\n * @example\n *\n * const bbox = [-65, 40, -63, 42];\n * const dataset = turf.randomPoint(100, { bbox: bbox });\n *\n * const result = turf.moranIndex(dataset, {\n *   inputField: 'CRIME',\n * });\n */\nexport default function (fc, options) {\n    var inputField = options.inputField;\n    var threshold = options.threshold || 100000;\n    var p = options.p || 2;\n    var binary = options.binary || false;\n    var alpha = options.alpha || -1;\n    var standardization = options.standardization || true;\n    var weight = spatialWeight(fc, {\n        alpha: alpha,\n        binary: binary,\n        p: p,\n        standardization: standardization,\n        threshold: threshold,\n    });\n    var y = [];\n    featureEach(fc, function (feature) {\n        var feaProperties = feature.properties || {};\n        // validate inputField exists\n        y.push(feaProperties[inputField]);\n    });\n    var yMean = mean(y);\n    var yVar = variance(y);\n    var weightSum = 0;\n    var s0 = 0;\n    var s1 = 0;\n    var s2 = 0;\n    var n = weight.length;\n    // validate y.length is the same as weight.length\n    for (var i = 0; i < n; i++) {\n        var subS2 = 0;\n        for (var j = 0; j < n; j++) {\n            weightSum += weight[i][j] * (y[i] - yMean) * (y[j] - yMean);\n            s0 += weight[i][j];\n            s1 += Math.pow(weight[i][j] + weight[j][i], 2);\n            subS2 += weight[i][j] + weight[j][i];\n        }\n        s2 += Math.pow(subS2, 2);\n    }\n    s1 = 0.5 * s1;\n    var moranIndex = weightSum / s0 / yVar;\n    var expectedMoranIndex = -1 / (n - 1);\n    var vNum = n * n * s1 - n * s2 + 3 * (s0 * s0);\n    var vDen = (n - 1) * (n + 1) * (s0 * s0);\n    var vNorm = vNum / vDen - expectedMoranIndex * expectedMoranIndex;\n    var stdNorm = Math.sqrt(vNorm);\n    var zNorm = (moranIndex - expectedMoranIndex) / stdNorm;\n    return {\n        expectedMoranIndex: expectedMoranIndex,\n        moranIndex: moranIndex,\n        stdNorm: stdNorm,\n        zNorm: zNorm,\n    };\n}\n/**\n * get mean of a list\n * @param {number[]} y\n * @returns {number}\n *\n */\nfunction mean(y) {\n    var sum = 0;\n    for (var _i = 0, y_1 = y; _i < y_1.length; _i++) {\n        var item = y_1[_i];\n        sum += item;\n    }\n    return sum / y.length;\n}\n/**\n * get variance of a list\n * @param {number[]} y\n * @returns {number}\n *\n */\nfunction variance(y) {\n    var yMean = mean(y);\n    var sum = 0;\n    for (var _i = 0, y_2 = y; _i < y_2.length; _i++) {\n        var item = y_2[_i];\n        sum += Math.pow(item - yMean, 2);\n    }\n    return sum / y.length;\n}\n/**\n * @typedef {Object} MoranIndex\n * @property {number} moranIndex the moran's Index of the observed feature set\n * @property {number} expectedMoranIndex the moran's Index of the random distribution\n * @property {number} stdNorm the standard devitaion of the random distribution\n * @property {number} zNorm the z-score of the observe samples with regard to the random distribution\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}