{"ast":null,"code":"import { coordEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport clone from '@turf/clone';\nimport rhumbDestination from '@turf/rhumb-destination';\n\n/**\n * Moves any geojson Feature or Geometry of a specified distance along a Rhumb Line\n * on the provided direction angle.\n *\n * @name transformTranslate\n * @param {GeoJSON} geojson object to be translated\n * @param {number} distance length of the motion; negative values determine motion in opposite direction\n * @param {number} direction of the motion; angle from North in decimal degrees, positive clockwise\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] in which `distance` will be express; miles, kilometers, degrees, or radians\n * @param {number} [options.zTranslation=0] length of the vertical motion, same unit of distance\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} the translated GeoJSON object\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var translatedPoly = turf.transformTranslate(poly, 100, 35);\n *\n * //addToMap\n * var addToMap = [poly, translatedPoly];\n * translatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformTranslate(geojson, distance, direction, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var zTranslation = options.zTranslation;\n  var mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance)) throw new Error(\"distance is required\");\n  if (zTranslation && typeof zTranslation !== \"number\" && isNaN(zTranslation)) throw new Error(\"zTranslation is not a number\");\n\n  // Shortcut no-motion\n  zTranslation = zTranslation !== undefined ? zTranslation : 0;\n  if (distance === 0 && zTranslation === 0) return geojson;\n  if (direction === undefined || direction === null || isNaN(direction)) throw new Error(\"direction is required\");\n\n  // Invert with negative distances\n  if (distance < 0) {\n    distance = -distance;\n    direction = direction + 180;\n  }\n\n  // Clone geojson to avoid side effects\n  if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n  // Translate each coordinate\n  coordEach(geojson, function (pointCoords) {\n    var newCoords = getCoords(rhumbDestination(pointCoords, distance, direction, {\n      units: units\n    }));\n    pointCoords[0] = newCoords[0];\n    pointCoords[1] = newCoords[1];\n    if (zTranslation && pointCoords.length === 3) pointCoords[2] += zTranslation;\n  });\n  return geojson;\n}\nexport default transformTranslate;","map":{"version":3,"names":["coordEach","isObject","getCoords","clone","rhumbDestination","transformTranslate","geojson","distance","direction","options","Error","units","zTranslation","mutate","undefined","isNaN","pointCoords","newCoords","length"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/transform-translate/dist/es/index.js"],"sourcesContent":["import { coordEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport clone from '@turf/clone';\nimport rhumbDestination from '@turf/rhumb-destination';\n\n/**\n * Moves any geojson Feature or Geometry of a specified distance along a Rhumb Line\n * on the provided direction angle.\n *\n * @name transformTranslate\n * @param {GeoJSON} geojson object to be translated\n * @param {number} distance length of the motion; negative values determine motion in opposite direction\n * @param {number} direction of the motion; angle from North in decimal degrees, positive clockwise\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] in which `distance` will be express; miles, kilometers, degrees, or radians\n * @param {number} [options.zTranslation=0] length of the vertical motion, same unit of distance\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} the translated GeoJSON object\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var translatedPoly = turf.transformTranslate(poly, 100, 35);\n *\n * //addToMap\n * var addToMap = [poly, translatedPoly];\n * translatedPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformTranslate(geojson, distance, direction, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n  var zTranslation = options.zTranslation;\n  var mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n  if (zTranslation && typeof zTranslation !== \"number\" && isNaN(zTranslation))\n    throw new Error(\"zTranslation is not a number\");\n\n  // Shortcut no-motion\n  zTranslation = zTranslation !== undefined ? zTranslation : 0;\n  if (distance === 0 && zTranslation === 0) return geojson;\n\n  if (direction === undefined || direction === null || isNaN(direction))\n    throw new Error(\"direction is required\");\n\n  // Invert with negative distances\n  if (distance < 0) {\n    distance = -distance;\n    direction = direction + 180;\n  }\n\n  // Clone geojson to avoid side effects\n  if (mutate === false || mutate === undefined) geojson = clone(geojson);\n\n  // Translate each coordinate\n  coordEach(geojson, function (pointCoords) {\n    var newCoords = getCoords(\n      rhumbDestination(pointCoords, distance, direction, { units: units })\n    );\n    pointCoords[0] = newCoords[0];\n    pointCoords[1] = newCoords[1];\n    if (zTranslation && pointCoords.length === 3)\n      pointCoords[2] += zTranslation;\n  });\n  return geojson;\n}\n\nexport default transformTranslate;\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,YAAY;AACtC,SAASC,QAAQ,QAAQ,eAAe;AACxC,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,OAAOC,KAAK,MAAM,aAAa;AAC/B,OAAOC,gBAAgB,MAAM,yBAAyB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,OAAO,EAAE;EACjE;EACAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAI,CAACR,QAAQ,CAACQ,OAAO,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EAC7D,IAAIC,KAAK,GAAGF,OAAO,CAACE,KAAK;EACzB,IAAIC,YAAY,GAAGH,OAAO,CAACG,YAAY;EACvC,IAAIC,MAAM,GAAGJ,OAAO,CAACI,MAAM;;EAE3B;EACA,IAAI,CAACP,OAAO,EAAE,MAAM,IAAII,KAAK,CAAC,qBAAqB,CAAC;EACpD,IAAIH,QAAQ,KAAKO,SAAS,IAAIP,QAAQ,KAAK,IAAI,IAAIQ,KAAK,CAACR,QAAQ,CAAC,EAChE,MAAM,IAAIG,KAAK,CAAC,sBAAsB,CAAC;EACzC,IAAIE,YAAY,IAAI,OAAOA,YAAY,KAAK,QAAQ,IAAIG,KAAK,CAACH,YAAY,CAAC,EACzE,MAAM,IAAIF,KAAK,CAAC,8BAA8B,CAAC;;EAEjD;EACAE,YAAY,GAAGA,YAAY,KAAKE,SAAS,GAAGF,YAAY,GAAG,CAAC;EAC5D,IAAIL,QAAQ,KAAK,CAAC,IAAIK,YAAY,KAAK,CAAC,EAAE,OAAON,OAAO;EAExD,IAAIE,SAAS,KAAKM,SAAS,IAAIN,SAAS,KAAK,IAAI,IAAIO,KAAK,CAACP,SAAS,CAAC,EACnE,MAAM,IAAIE,KAAK,CAAC,uBAAuB,CAAC;;EAE1C;EACA,IAAIH,QAAQ,GAAG,CAAC,EAAE;IAChBA,QAAQ,GAAG,CAACA,QAAQ;IACpBC,SAAS,GAAGA,SAAS,GAAG,GAAG;EAC7B;;EAEA;EACA,IAAIK,MAAM,KAAK,KAAK,IAAIA,MAAM,KAAKC,SAAS,EAAER,OAAO,GAAGH,KAAK,CAACG,OAAO,CAAC;;EAEtE;EACAN,SAAS,CAACM,OAAO,EAAE,UAAUU,WAAW,EAAE;IACxC,IAAIC,SAAS,GAAGf,SAAS,CACvBE,gBAAgB,CAACY,WAAW,EAAET,QAAQ,EAAEC,SAAS,EAAE;MAAEG,KAAK,EAAEA;IAAM,CAAC,CACrE,CAAC;IACDK,WAAW,CAAC,CAAC,CAAC,GAAGC,SAAS,CAAC,CAAC,CAAC;IAC7BD,WAAW,CAAC,CAAC,CAAC,GAAGC,SAAS,CAAC,CAAC,CAAC;IAC7B,IAAIL,YAAY,IAAII,WAAW,CAACE,MAAM,KAAK,CAAC,EAC1CF,WAAW,CAAC,CAAC,CAAC,IAAIJ,YAAY;EAClC,CAAC,CAAC;EACF,OAAON,OAAO;AAChB;AAEA,eAAeD,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}