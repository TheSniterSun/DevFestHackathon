{"ast":null,"code":"import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * Takes a reference {@link Point|point} and a FeatureCollection of Features\n * with Point geometries and returns the\n * point from the FeatureCollection closest to the reference. This calculation\n * is geodesic.\n *\n * @name nearestPoint\n * @param {Coord} targetPoint the reference point\n * @param {FeatureCollection<Point>} points against input point set\n * @returns {Feature<Point>} the closest point in the set to the reference point\n * @example\n * var targetPoint = turf.point([28.965797, 41.010086], {\"marker-color\": \"#0F0\"});\n * var points = turf.featureCollection([\n *     turf.point([28.973865, 41.011122]),\n *     turf.point([28.948459, 41.024204]),\n *     turf.point([28.938674, 41.013324])\n * ]);\n *\n * var nearest = turf.nearestPoint(targetPoint, points);\n *\n * //addToMap\n * var addToMap = [targetPoint, points, nearest];\n * nearest.properties['marker-color'] = '#F00';\n */\nfunction nearestPoint(targetPoint, points) {\n  // Input validation\n  if (!targetPoint) throw new Error(\"targetPoint is required\");\n  if (!points) throw new Error(\"points is required\");\n  var nearest;\n  var minDist = Infinity;\n  var bestFeatureIndex = 0;\n  featureEach(points, function (pt, featureIndex) {\n    var distanceToPoint = distance(targetPoint, pt);\n    if (distanceToPoint < minDist) {\n      bestFeatureIndex = featureIndex;\n      minDist = distanceToPoint;\n    }\n  });\n  nearest = clone(points.features[bestFeatureIndex]);\n  nearest.properties.featureIndex = bestFeatureIndex;\n  nearest.properties.distanceToPoint = minDist;\n  return nearest;\n}\nexport default nearestPoint;","map":{"version":3,"names":["clone","distance","featureEach","nearestPoint","targetPoint","points","Error","nearest","minDist","Infinity","bestFeatureIndex","pt","featureIndex","distanceToPoint","features","properties"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/nearest-point/dist/es/index.js"],"sourcesContent":["import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * Takes a reference {@link Point|point} and a FeatureCollection of Features\n * with Point geometries and returns the\n * point from the FeatureCollection closest to the reference. This calculation\n * is geodesic.\n *\n * @name nearestPoint\n * @param {Coord} targetPoint the reference point\n * @param {FeatureCollection<Point>} points against input point set\n * @returns {Feature<Point>} the closest point in the set to the reference point\n * @example\n * var targetPoint = turf.point([28.965797, 41.010086], {\"marker-color\": \"#0F0\"});\n * var points = turf.featureCollection([\n *     turf.point([28.973865, 41.011122]),\n *     turf.point([28.948459, 41.024204]),\n *     turf.point([28.938674, 41.013324])\n * ]);\n *\n * var nearest = turf.nearestPoint(targetPoint, points);\n *\n * //addToMap\n * var addToMap = [targetPoint, points, nearest];\n * nearest.properties['marker-color'] = '#F00';\n */\nfunction nearestPoint(targetPoint, points) {\n    // Input validation\n    if (!targetPoint)\n        throw new Error(\"targetPoint is required\");\n    if (!points)\n        throw new Error(\"points is required\");\n    var nearest;\n    var minDist = Infinity;\n    var bestFeatureIndex = 0;\n    featureEach(points, function (pt, featureIndex) {\n        var distanceToPoint = distance(targetPoint, pt);\n        if (distanceToPoint < minDist) {\n            bestFeatureIndex = featureIndex;\n            minDist = distanceToPoint;\n        }\n    });\n    nearest = clone(points.features[bestFeatureIndex]);\n    nearest.properties.featureIndex = bestFeatureIndex;\n    nearest.properties.distanceToPoint = minDist;\n    return nearest;\n}\nexport default nearestPoint;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,aAAa;AAC/B,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,SAASC,WAAW,QAAQ,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,WAAW,EAAEC,MAAM,EAAE;EACvC;EACA,IAAI,CAACD,WAAW,EACZ,MAAM,IAAIE,KAAK,CAAC,yBAAyB,CAAC;EAC9C,IAAI,CAACD,MAAM,EACP,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EACzC,IAAIC,OAAO;EACX,IAAIC,OAAO,GAAGC,QAAQ;EACtB,IAAIC,gBAAgB,GAAG,CAAC;EACxBR,WAAW,CAACG,MAAM,EAAE,UAAUM,EAAE,EAAEC,YAAY,EAAE;IAC5C,IAAIC,eAAe,GAAGZ,QAAQ,CAACG,WAAW,EAAEO,EAAE,CAAC;IAC/C,IAAIE,eAAe,GAAGL,OAAO,EAAE;MAC3BE,gBAAgB,GAAGE,YAAY;MAC/BJ,OAAO,GAAGK,eAAe;IAC7B;EACJ,CAAC,CAAC;EACFN,OAAO,GAAGP,KAAK,CAACK,MAAM,CAACS,QAAQ,CAACJ,gBAAgB,CAAC,CAAC;EAClDH,OAAO,CAACQ,UAAU,CAACH,YAAY,GAAGF,gBAAgB;EAClDH,OAAO,CAACQ,UAAU,CAACF,eAAe,GAAGL,OAAO;EAC5C,OAAOD,OAAO;AAClB;AACA,eAAeJ,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}