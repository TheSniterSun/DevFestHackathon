{"ast":null,"code":"import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Normalize inputs\n  var ptCoords = getCoord(pt);\n  var lineCoords = getCoords(line);\n  // Main\n  for (var i = 0; i < lineCoords.length - 1; i++) {\n    var ignoreBoundary = false;\n    if (options.ignoreEndVertices) {\n      if (i === 0) {\n        ignoreBoundary = \"start\";\n      }\n      if (i === lineCoords.length - 2) {\n        ignoreBoundary = \"end\";\n      }\n      if (i === 0 && i + 1 === lineCoords.length - 1) {\n        ignoreBoundary = \"both\";\n      }\n    }\n    if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n      return true;\n    }\n  }\n  return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n  var x = pt[0];\n  var y = pt[1];\n  var x1 = lineSegmentStart[0];\n  var y1 = lineSegmentStart[1];\n  var x2 = lineSegmentEnd[0];\n  var y2 = lineSegmentEnd[1];\n  var dxc = pt[0] - x1;\n  var dyc = pt[1] - y1;\n  var dxl = x2 - x1;\n  var dyl = y2 - y1;\n  var cross = dxc * dyl - dyc * dxl;\n  if (epsilon !== null) {\n    if (Math.abs(cross) > epsilon) {\n      return false;\n    }\n  } else if (cross !== 0) {\n    return false;\n  }\n  if (!excludeBoundary) {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n    }\n    return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n  } else if (excludeBoundary === \"start\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n    }\n    return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n  } else if (excludeBoundary === \"end\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n    }\n    return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n  } else if (excludeBoundary === \"both\") {\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n      return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n    }\n    return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n  }\n  return false;\n}\nexport default booleanPointOnLine;","map":{"version":3,"names":["getCoord","getCoords","booleanPointOnLine","pt","line","options","ptCoords","lineCoords","i","length","ignoreBoundary","ignoreEndVertices","isPointOnLineSegment","epsilon","lineSegmentStart","lineSegmentEnd","excludeBoundary","x","y","x1","y1","x2","y2","dxc","dyc","dxl","dyl","cross","Math","abs"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/boolean-point-on-line/dist/es/index.js"],"sourcesContent":["import { getCoord, getCoords } from \"@turf/invariant\";\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @param {number} [options.epsilon] Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = getCoord(pt);\n    var lineCoords = getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary, typeof options.epsilon === \"undefined\" ? null : options.epsilon)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n// See https://stackoverflow.com/a/328122/1048847\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * @param {number} epsilon Fractional number to compare with the cross product result. Useful for dealing with floating points such as lng/lat points\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (epsilon !== null) {\n        if (Math.abs(cross) > epsilon) {\n            return false;\n        }\n    }\n    else if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexport default booleanPointOnLine;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}