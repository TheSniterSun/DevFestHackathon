{"ast":null,"code":"function objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function (name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function (row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n    columns = [];\n  rows.forEach(function (row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n  return columns;\n}\nexport default function (delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n    delimiterCode = delimiter.charCodeAt(0);\n  function parse(text, f) {\n    var convert,\n      columns,\n      rows = parseRows(text, function (row, i) {\n        if (convert) return convert(row, i - 1);\n        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n      });\n    rows.columns = columns;\n    return rows;\n  }\n  function parseRows(text, f) {\n    var EOL = {},\n      // sentinel value for end-of-line\n      EOF = {},\n      // sentinel value for end-of-file\n      rows = [],\n      // output rows\n      N = text.length,\n      I = 0,\n      // current character index\n      n = 0,\n      // the current line number\n      t,\n      // the current token\n      eol; // is the current token followed by EOL?\n\n    function token() {\n      if (I >= N) return EOF; // special case: end of file\n      if (eol) return eol = false, EOL; // special case: end of line\n\n      // special case: quotes\n      var j = I,\n        c;\n      if (text.charCodeAt(j) === 34) {\n        var i = j;\n        while (i++ < N) {\n          if (text.charCodeAt(i) === 34) {\n            if (text.charCodeAt(i + 1) !== 34) break;\n            ++i;\n          }\n        }\n        I = i + 2;\n        c = text.charCodeAt(i + 1);\n        if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(i + 2) === 10) ++I;\n        } else if (c === 10) {\n          eol = true;\n        }\n        return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // common case: find next delimiter or newline\n      while (I < N) {\n        var k = 1;\n        c = text.charCodeAt(I++);\n        if (c === 10) eol = true; // \\n\n        else if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(I) === 10) ++I, ++k;\n        } // \\r|\\r\\n\n        else if (c !== delimiterCode) continue;\n        return text.slice(j, I - k);\n      }\n\n      // special case: last token before EOF\n      return text.slice(j);\n    }\n    while ((t = token()) !== EOF) {\n      var a = [];\n      while (t !== EOL && t !== EOF) {\n        a.push(t);\n        t = token();\n      }\n      if (f && (a = f(a, n++)) == null) continue;\n      rows.push(a);\n    }\n    return rows;\n  }\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {\n      return columns.map(function (column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n  function formatValue(text) {\n    return text == null ? \"\" : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\" : text;\n  }\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}","map":{"version":3,"names":["objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","object","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","delimiter","reFormat","RegExp","delimiterCode","charCodeAt","parse","text","convert","parseRows","EOL","EOF","N","length","I","n","t","eol","token","j","c","slice","replace","k","a","format","formatValue","concat","formatRows","formatRow","test"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/d3-dsv/src/dsv.js"],"sourcesContent":["function objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n      delimiterCode = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns;\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var EOL = {}, // sentinel value for end-of-line\n        EOF = {}, // sentinel value for end-of-file\n        rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // the current line number\n        t, // the current token\n        eol; // is the current token followed by EOL?\n\n    function token() {\n      if (I >= N) return EOF; // special case: end of file\n      if (eol) return eol = false, EOL; // special case: end of line\n\n      // special case: quotes\n      var j = I, c;\n      if (text.charCodeAt(j) === 34) {\n        var i = j;\n        while (i++ < N) {\n          if (text.charCodeAt(i) === 34) {\n            if (text.charCodeAt(i + 1) !== 34) break;\n            ++i;\n          }\n        }\n        I = i + 2;\n        c = text.charCodeAt(i + 1);\n        if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(i + 2) === 10) ++I;\n        } else if (c === 10) {\n          eol = true;\n        }\n        return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // common case: find next delimiter or newline\n      while (I < N) {\n        var k = 1;\n        c = text.charCodeAt(I++);\n        if (c === 10) eol = true; // \\n\n        else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n        else if (c !== delimiterCode) continue;\n        return text.slice(j, I - k);\n      }\n\n      // special case: last token before EOF\n      return text.slice(j);\n    }\n\n    while ((t = token()) !== EOF) {\n      var a = [];\n      while (t !== EOL && t !== EOF) {\n        a.push(t);\n        t = token();\n      }\n      if (f && (a = f(a, n++)) == null) continue;\n      rows.push(a);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}