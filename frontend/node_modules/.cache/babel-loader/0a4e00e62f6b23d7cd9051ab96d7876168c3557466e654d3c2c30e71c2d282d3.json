{"ast":null,"code":"import rbush from 'geojson-rbush';\nimport square from '@turf/square';\nimport bbox from '@turf/bbox';\nimport truncate from '@turf/truncate';\nimport lineSegment from '@turf/line-segment';\nimport lineIntersect from '@turf/line-intersect';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { getType, getCoords, getCoord } from '@turf/invariant';\nimport { flattenEach, featureEach, featureReduce } from '@turf/meta';\nimport { featureCollection, lineString } from '@turf/helpers';\n\n/**\n * Split a LineString by another GeoJSON Feature.\n *\n * @name lineSplit\n * @param {Feature<LineString>} line LineString Feature to split\n * @param {Feature<any>} splitter Feature used to split line\n * @returns {FeatureCollection<LineString>} Split LineStrings\n * @example\n * var line = turf.lineString([[120, -25], [145, -25]]);\n * var splitter = turf.lineString([[130, -15], [130, -35]]);\n *\n * var split = turf.lineSplit(line, splitter);\n *\n * //addToMap\n * var addToMap = [line, splitter]\n */\nfunction lineSplit(line, splitter) {\n  if (!line) throw new Error(\"line is required\");\n  if (!splitter) throw new Error(\"splitter is required\");\n  var lineType = getType(line);\n  var splitterType = getType(splitter);\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\n  if (splitterType === \"FeatureCollection\") throw new Error(\"splitter cannot be a FeatureCollection\");\n  if (splitterType === \"GeometryCollection\") throw new Error(\"splitter cannot be a GeometryCollection\");\n\n  // remove excessive decimals from splitter\n  // to avoid possible approximation issues in rbush\n  var truncatedSplitter = truncate(splitter, {\n    precision: 7\n  });\n  switch (splitterType) {\n    case \"Point\":\n      return splitLineWithPoint(line, truncatedSplitter);\n    case \"MultiPoint\":\n      return splitLineWithPoints(line, truncatedSplitter);\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter));\n  }\n}\n\n/**\n * Split LineString with MultiPoint\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {FeatureCollection<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoints(line, splitter) {\n  var results = [];\n  var tree = rbush();\n  flattenEach(splitter, function (point) {\n    // Add index/id to features (needed for filter)\n    results.forEach(function (feature, index) {\n      feature.id = index;\n    });\n    // First Point - doesn't need to handle any previous line results\n    if (!results.length) {\n      results = splitLineWithPoint(line, point).features;\n\n      // Add Square BBox to each feature for GeoJSON-RBush\n      results.forEach(function (feature) {\n        if (!feature.bbox) feature.bbox = square(bbox(feature));\n      });\n      tree.load(featureCollection(results));\n      // Split with remaining points - lines might needed to be split multiple times\n    } else {\n      // Find all lines that are within the splitter's bbox\n      var search = tree.search(point);\n      if (search.features.length) {\n        // RBush might return multiple lines - only process the closest line to splitter\n        var closestLine = findClosestFeature(point, search);\n\n        // Remove closest line from results since this will be split into two lines\n        // This removes any duplicates inside the results & index\n        results = results.filter(function (feature) {\n          return feature.id !== closestLine.id;\n        });\n        tree.remove(closestLine);\n\n        // Append the two newly split lines into the results\n        featureEach(splitLineWithPoint(closestLine, point), function (line) {\n          results.push(line);\n          tree.insert(line);\n        });\n      }\n    }\n  });\n  return featureCollection(results);\n}\n\n/**\n * Split LineString with Point\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoint(line, splitter) {\n  var results = [];\n\n  // handle endpoints\n  var startPoint = getCoords(line)[0];\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n  if (pointsEquals(startPoint, getCoord(splitter)) || pointsEquals(endPoint, getCoord(splitter))) return featureCollection([line]);\n\n  // Create spatial index\n  var tree = rbush();\n  var segments = lineSegment(line);\n  tree.load(segments);\n\n  // Find all segments that are within bbox of splitter\n  var search = tree.search(splitter);\n\n  // Return itself if point is not within spatial index\n  if (!search.features.length) return featureCollection([line]);\n\n  // RBush might return multiple lines - only process the closest line to splitter\n  var closestSegment = findClosestFeature(splitter, search);\n\n  // Initial value is the first point of the first segments (beginning of line)\n  var initialValue = [startPoint];\n  var lastCoords = featureReduce(segments, function (previous, current, index) {\n    var currentCoords = getCoords(current)[1];\n    var splitterCoords = getCoord(splitter);\n\n    // Location where segment intersects with line\n    if (index === closestSegment.id) {\n      previous.push(splitterCoords);\n      results.push(lineString(previous));\n      // Don't duplicate splitter coordinate (Issue #688)\n      if (pointsEquals(splitterCoords, currentCoords)) return [splitterCoords];\n      return [splitterCoords, currentCoords];\n\n      // Keep iterating over coords until finished or intersection is found\n    } else {\n      previous.push(currentCoords);\n      return previous;\n    }\n  }, initialValue);\n  // Append last line to final split results\n  if (lastCoords.length > 1) {\n    results.push(lineString(lastCoords));\n  }\n  return featureCollection(results);\n}\n\n/**\n * Find Closest Feature\n *\n * @private\n * @param {Feature<Point>} point Feature must be closest to this point\n * @param {FeatureCollection<LineString>} lines Collection of Features\n * @returns {Feature<LineString>} closest LineString\n */\nfunction findClosestFeature(point, lines) {\n  if (!lines.features.length) throw new Error(\"lines must contain features\");\n  // Filter to one segment that is the closest to the line\n  if (lines.features.length === 1) return lines.features[0];\n  var closestFeature;\n  var closestDistance = Infinity;\n  featureEach(lines, function (segment) {\n    var pt = nearestPointOnLine(segment, point);\n    var dist = pt.properties.dist;\n    if (dist < closestDistance) {\n      closestFeature = segment;\n      closestDistance = dist;\n    }\n  });\n  return closestFeature;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Array<number>} pt1 point\n * @param {Array<number>} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction pointsEquals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\nexport default lineSplit;","map":{"version":3,"names":["rbush","square","bbox","truncate","lineSegment","lineIntersect","nearestPointOnLine","getType","getCoords","getCoord","flattenEach","featureEach","featureReduce","featureCollection","lineString","lineSplit","line","splitter","Error","lineType","splitterType","truncatedSplitter","precision","splitLineWithPoint","splitLineWithPoints","results","tree","point","forEach","feature","index","id","length","features","load","search","closestLine","findClosestFeature","filter","remove","push","insert","startPoint","endPoint","geometry","coordinates","pointsEquals","segments","closestSegment","initialValue","lastCoords","previous","current","currentCoords","splitterCoords","lines","closestFeature","closestDistance","Infinity","segment","pt","dist","properties","pt1","pt2"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/line-split/dist/es/index.js"],"sourcesContent":["import rbush from 'geojson-rbush';\nimport square from '@turf/square';\nimport bbox from '@turf/bbox';\nimport truncate from '@turf/truncate';\nimport lineSegment from '@turf/line-segment';\nimport lineIntersect from '@turf/line-intersect';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { getType, getCoords, getCoord } from '@turf/invariant';\nimport { flattenEach, featureEach, featureReduce } from '@turf/meta';\nimport { featureCollection, lineString } from '@turf/helpers';\n\n/**\n * Split a LineString by another GeoJSON Feature.\n *\n * @name lineSplit\n * @param {Feature<LineString>} line LineString Feature to split\n * @param {Feature<any>} splitter Feature used to split line\n * @returns {FeatureCollection<LineString>} Split LineStrings\n * @example\n * var line = turf.lineString([[120, -25], [145, -25]]);\n * var splitter = turf.lineString([[130, -15], [130, -35]]);\n *\n * var split = turf.lineSplit(line, splitter);\n *\n * //addToMap\n * var addToMap = [line, splitter]\n */\nfunction lineSplit(line, splitter) {\n  if (!line) throw new Error(\"line is required\");\n  if (!splitter) throw new Error(\"splitter is required\");\n\n  var lineType = getType(line);\n  var splitterType = getType(splitter);\n\n  if (lineType !== \"LineString\") throw new Error(\"line must be LineString\");\n  if (splitterType === \"FeatureCollection\")\n    throw new Error(\"splitter cannot be a FeatureCollection\");\n  if (splitterType === \"GeometryCollection\")\n    throw new Error(\"splitter cannot be a GeometryCollection\");\n\n  // remove excessive decimals from splitter\n  // to avoid possible approximation issues in rbush\n  var truncatedSplitter = truncate(splitter, { precision: 7 });\n\n  switch (splitterType) {\n    case \"Point\":\n      return splitLineWithPoint(line, truncatedSplitter);\n    case \"MultiPoint\":\n      return splitLineWithPoints(line, truncatedSplitter);\n    case \"LineString\":\n    case \"MultiLineString\":\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      return splitLineWithPoints(line, lineIntersect(line, truncatedSplitter));\n  }\n}\n\n/**\n * Split LineString with MultiPoint\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {FeatureCollection<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoints(line, splitter) {\n  var results = [];\n  var tree = rbush();\n\n  flattenEach(splitter, function (point) {\n    // Add index/id to features (needed for filter)\n    results.forEach(function (feature, index) {\n      feature.id = index;\n    });\n    // First Point - doesn't need to handle any previous line results\n    if (!results.length) {\n      results = splitLineWithPoint(line, point).features;\n\n      // Add Square BBox to each feature for GeoJSON-RBush\n      results.forEach(function (feature) {\n        if (!feature.bbox) feature.bbox = square(bbox(feature));\n      });\n      tree.load(featureCollection(results));\n      // Split with remaining points - lines might needed to be split multiple times\n    } else {\n      // Find all lines that are within the splitter's bbox\n      var search = tree.search(point);\n\n      if (search.features.length) {\n        // RBush might return multiple lines - only process the closest line to splitter\n        var closestLine = findClosestFeature(point, search);\n\n        // Remove closest line from results since this will be split into two lines\n        // This removes any duplicates inside the results & index\n        results = results.filter(function (feature) {\n          return feature.id !== closestLine.id;\n        });\n        tree.remove(closestLine);\n\n        // Append the two newly split lines into the results\n        featureEach(splitLineWithPoint(closestLine, point), function (line) {\n          results.push(line);\n          tree.insert(line);\n        });\n      }\n    }\n  });\n  return featureCollection(results);\n}\n\n/**\n * Split LineString with Point\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<Point>} splitter Point\n * @returns {FeatureCollection<LineString>} split LineStrings\n */\nfunction splitLineWithPoint(line, splitter) {\n  var results = [];\n\n  // handle endpoints\n  var startPoint = getCoords(line)[0];\n  var endPoint = getCoords(line)[line.geometry.coordinates.length - 1];\n  if (\n    pointsEquals(startPoint, getCoord(splitter)) ||\n    pointsEquals(endPoint, getCoord(splitter))\n  )\n    return featureCollection([line]);\n\n  // Create spatial index\n  var tree = rbush();\n  var segments = lineSegment(line);\n  tree.load(segments);\n\n  // Find all segments that are within bbox of splitter\n  var search = tree.search(splitter);\n\n  // Return itself if point is not within spatial index\n  if (!search.features.length) return featureCollection([line]);\n\n  // RBush might return multiple lines - only process the closest line to splitter\n  var closestSegment = findClosestFeature(splitter, search);\n\n  // Initial value is the first point of the first segments (beginning of line)\n  var initialValue = [startPoint];\n  var lastCoords = featureReduce(\n    segments,\n    function (previous, current, index) {\n      var currentCoords = getCoords(current)[1];\n      var splitterCoords = getCoord(splitter);\n\n      // Location where segment intersects with line\n      if (index === closestSegment.id) {\n        previous.push(splitterCoords);\n        results.push(lineString(previous));\n        // Don't duplicate splitter coordinate (Issue #688)\n        if (pointsEquals(splitterCoords, currentCoords))\n          return [splitterCoords];\n        return [splitterCoords, currentCoords];\n\n        // Keep iterating over coords until finished or intersection is found\n      } else {\n        previous.push(currentCoords);\n        return previous;\n      }\n    },\n    initialValue\n  );\n  // Append last line to final split results\n  if (lastCoords.length > 1) {\n    results.push(lineString(lastCoords));\n  }\n  return featureCollection(results);\n}\n\n/**\n * Find Closest Feature\n *\n * @private\n * @param {Feature<Point>} point Feature must be closest to this point\n * @param {FeatureCollection<LineString>} lines Collection of Features\n * @returns {Feature<LineString>} closest LineString\n */\nfunction findClosestFeature(point, lines) {\n  if (!lines.features.length) throw new Error(\"lines must contain features\");\n  // Filter to one segment that is the closest to the line\n  if (lines.features.length === 1) return lines.features[0];\n\n  var closestFeature;\n  var closestDistance = Infinity;\n  featureEach(lines, function (segment) {\n    var pt = nearestPointOnLine(segment, point);\n    var dist = pt.properties.dist;\n    if (dist < closestDistance) {\n      closestFeature = segment;\n      closestDistance = dist;\n    }\n  });\n  return closestFeature;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Array<number>} pt1 point\n * @param {Array<number>} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction pointsEquals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\nexport default lineSplit;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}