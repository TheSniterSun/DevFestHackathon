{"ast":null,"code":"import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { coordAll } from \"@turf/meta\";\nimport { convertLength } from \"@turf/helpers\";\nimport clustering from \"density-clustering\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.\n *\n * @name clustersDbscan\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var maxDistance = 100;\n * var clustered = turf.clustersDbscan(points, maxDistance);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersDbscan(points, maxDistance, options) {\n  // Input validation being handled by Typescript\n  // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n  // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n  // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n  // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n  if (options === void 0) {\n    options = {};\n  }\n  // Clone points to prevent any mutations\n  if (options.mutate !== true) points = clone(points);\n  // Defaults\n  options.minPoints = options.minPoints || 3;\n  // create clustered ids\n  var dbscan = new clustering.DBSCAN();\n  var clusteredIds = dbscan.run(coordAll(points), convertLength(maxDistance, options.units), options.minPoints, distance);\n  // Tag points to Clusters ID\n  var clusterId = -1;\n  clusteredIds.forEach(function (clusterIds) {\n    clusterId++;\n    // assign cluster ids to input points\n    clusterIds.forEach(function (idx) {\n      var clusterPoint = points.features[idx];\n      if (!clusterPoint.properties) clusterPoint.properties = {};\n      clusterPoint.properties.cluster = clusterId;\n      clusterPoint.properties.dbscan = \"core\";\n    });\n  });\n  // handle noise points, if any\n  // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can \"reach\" less than 'minPoints' number of points\n  dbscan.noise.forEach(function (noiseId) {\n    var noisePoint = points.features[noiseId];\n    if (!noisePoint.properties) noisePoint.properties = {};\n    if (noisePoint.properties.cluster) noisePoint.properties.dbscan = \"edge\";else noisePoint.properties.dbscan = \"noise\";\n  });\n  return points;\n}\nexport default clustersDbscan;","map":{"version":3,"names":["clone","distance","coordAll","convertLength","clustering","clustersDbscan","points","maxDistance","options","mutate","minPoints","dbscan","DBSCAN","clusteredIds","run","units","clusterId","forEach","clusterIds","idx","clusterPoint","features","properties","cluster","noise","noiseId","noisePoint"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/clusters-dbscan/dist/es/index.js"],"sourcesContent":["import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { coordAll } from \"@turf/meta\";\nimport { convertLength, } from \"@turf/helpers\";\nimport clustering from \"density-clustering\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.\n *\n * @name clustersDbscan\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var maxDistance = 100;\n * var clustered = turf.clustersDbscan(points, maxDistance);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersDbscan(points, maxDistance, options) {\n    // Input validation being handled by Typescript\n    // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n    // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n    // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n    // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n    if (options === void 0) { options = {}; }\n    // Clone points to prevent any mutations\n    if (options.mutate !== true)\n        points = clone(points);\n    // Defaults\n    options.minPoints = options.minPoints || 3;\n    // create clustered ids\n    var dbscan = new clustering.DBSCAN();\n    var clusteredIds = dbscan.run(coordAll(points), convertLength(maxDistance, options.units), options.minPoints, distance);\n    // Tag points to Clusters ID\n    var clusterId = -1;\n    clusteredIds.forEach(function (clusterIds) {\n        clusterId++;\n        // assign cluster ids to input points\n        clusterIds.forEach(function (idx) {\n            var clusterPoint = points.features[idx];\n            if (!clusterPoint.properties)\n                clusterPoint.properties = {};\n            clusterPoint.properties.cluster = clusterId;\n            clusterPoint.properties.dbscan = \"core\";\n        });\n    });\n    // handle noise points, if any\n    // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can \"reach\" less than 'minPoints' number of points\n    dbscan.noise.forEach(function (noiseId) {\n        var noisePoint = points.features[noiseId];\n        if (!noisePoint.properties)\n            noisePoint.properties = {};\n        if (noisePoint.properties.cluster)\n            noisePoint.properties.dbscan = \"edge\";\n        else\n            noisePoint.properties.dbscan = \"noise\";\n    });\n    return points;\n}\nexport default clustersDbscan;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,aAAa;AAC/B,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,aAAa,QAAS,eAAe;AAC9C,OAAOC,UAAU,MAAM,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,MAAM,EAAEC,WAAW,EAAEC,OAAO,EAAE;EAClD;EACA;EACA;EACA;EACA;EACA,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC;EACA,IAAIA,OAAO,CAACC,MAAM,KAAK,IAAI,EACvBH,MAAM,GAAGN,KAAK,CAACM,MAAM,CAAC;EAC1B;EACAE,OAAO,CAACE,SAAS,GAAGF,OAAO,CAACE,SAAS,IAAI,CAAC;EAC1C;EACA,IAAIC,MAAM,GAAG,IAAIP,UAAU,CAACQ,MAAM,CAAC,CAAC;EACpC,IAAIC,YAAY,GAAGF,MAAM,CAACG,GAAG,CAACZ,QAAQ,CAACI,MAAM,CAAC,EAAEH,aAAa,CAACI,WAAW,EAAEC,OAAO,CAACO,KAAK,CAAC,EAAEP,OAAO,CAACE,SAAS,EAAET,QAAQ,CAAC;EACvH;EACA,IAAIe,SAAS,GAAG,CAAC,CAAC;EAClBH,YAAY,CAACI,OAAO,CAAC,UAAUC,UAAU,EAAE;IACvCF,SAAS,EAAE;IACX;IACAE,UAAU,CAACD,OAAO,CAAC,UAAUE,GAAG,EAAE;MAC9B,IAAIC,YAAY,GAAGd,MAAM,CAACe,QAAQ,CAACF,GAAG,CAAC;MACvC,IAAI,CAACC,YAAY,CAACE,UAAU,EACxBF,YAAY,CAACE,UAAU,GAAG,CAAC,CAAC;MAChCF,YAAY,CAACE,UAAU,CAACC,OAAO,GAAGP,SAAS;MAC3CI,YAAY,CAACE,UAAU,CAACX,MAAM,GAAG,MAAM;IAC3C,CAAC,CAAC;EACN,CAAC,CAAC;EACF;EACA;EACAA,MAAM,CAACa,KAAK,CAACP,OAAO,CAAC,UAAUQ,OAAO,EAAE;IACpC,IAAIC,UAAU,GAAGpB,MAAM,CAACe,QAAQ,CAACI,OAAO,CAAC;IACzC,IAAI,CAACC,UAAU,CAACJ,UAAU,EACtBI,UAAU,CAACJ,UAAU,GAAG,CAAC,CAAC;IAC9B,IAAII,UAAU,CAACJ,UAAU,CAACC,OAAO,EAC7BG,UAAU,CAACJ,UAAU,CAACX,MAAM,GAAG,MAAM,CAAC,KAEtCe,UAAU,CAACJ,UAAU,CAACX,MAAM,GAAG,OAAO;EAC9C,CAAC,CAAC;EACF,OAAOL,MAAM;AACjB;AACA,eAAeD,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}