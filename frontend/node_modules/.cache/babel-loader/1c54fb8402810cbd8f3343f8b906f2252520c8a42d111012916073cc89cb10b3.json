{"ast":null,"code":"import calcBbox from \"@turf/bbox\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Boolean-within returns true if the first geometry is completely within the second geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a)\n * must not intersect the exterior of the secondary (geometry b).\n * Boolean-within returns the exact opposite result of the `@turf/boolean-contains`.\n *\n * @name booleanWithin\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanWithin(point, line);\n * //=true\n */\nfunction booleanWithin(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n  switch (type1) {\n    case \"Point\":\n      switch (type2) {\n        case \"MultiPoint\":\n          return isPointInMultiPoint(geom1, geom2);\n        case \"LineString\":\n          return booleanPointOnLine(geom1, geom2, {\n            ignoreEndVertices: true\n          });\n        case \"Polygon\":\n        case \"MultiPolygon\":\n          return booleanPointInPolygon(geom1, geom2, {\n            ignoreBoundary: true\n          });\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"MultiPoint\":\n      switch (type2) {\n        case \"MultiPoint\":\n          return isMultiPointInMultiPoint(geom1, geom2);\n        case \"LineString\":\n          return isMultiPointOnLine(geom1, geom2);\n        case \"Polygon\":\n        case \"MultiPolygon\":\n          return isMultiPointInPoly(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"LineString\":\n      switch (type2) {\n        case \"LineString\":\n          return isLineOnLine(geom1, geom2);\n        case \"Polygon\":\n        case \"MultiPolygon\":\n          return isLineInPoly(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    case \"Polygon\":\n      switch (type2) {\n        case \"Polygon\":\n        case \"MultiPolygon\":\n          return isPolyInPoly(geom1, geom2);\n        default:\n          throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n      }\n    default:\n      throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n  }\n}\nfunction isPointInMultiPoint(point, multiPoint) {\n  var i;\n  var output = false;\n  for (i = 0; i < multiPoint.coordinates.length; i++) {\n    if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {\n      output = true;\n      break;\n    }\n  }\n  return output;\n}\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n  for (var i = 0; i < multiPoint1.coordinates.length; i++) {\n    var anyMatch = false;\n    for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {\n      if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {\n        anyMatch = true;\n      }\n    }\n    if (!anyMatch) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isMultiPointOnLine(multiPoint, lineString) {\n  var foundInsidePoint = false;\n  for (var i = 0; i < multiPoint.coordinates.length; i++) {\n    if (!booleanPointOnLine(multiPoint.coordinates[i], lineString)) {\n      return false;\n    }\n    if (!foundInsidePoint) {\n      foundInsidePoint = booleanPointOnLine(multiPoint.coordinates[i], lineString, {\n        ignoreEndVertices: true\n      });\n    }\n  }\n  return foundInsidePoint;\n}\nfunction isMultiPointInPoly(multiPoint, polygon) {\n  var output = true;\n  var oneInside = false;\n  var isInside = false;\n  for (var i = 0; i < multiPoint.coordinates.length; i++) {\n    isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon);\n    if (!isInside) {\n      output = false;\n      break;\n    }\n    if (!oneInside) {\n      isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon, {\n        ignoreBoundary: true\n      });\n    }\n  }\n  return output && isInside;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n  for (var i = 0; i < lineString1.coordinates.length; i++) {\n    if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isLineInPoly(linestring, polygon) {\n  var polyBbox = calcBbox(polygon);\n  var lineBbox = calcBbox(linestring);\n  if (!doBBoxOverlap(polyBbox, lineBbox)) {\n    return false;\n  }\n  var foundInsidePoint = false;\n  for (var i = 0; i < linestring.coordinates.length - 1; i++) {\n    if (!booleanPointInPolygon(linestring.coordinates[i], polygon)) {\n      return false;\n    }\n    if (!foundInsidePoint) {\n      foundInsidePoint = booleanPointInPolygon(linestring.coordinates[i], polygon, {\n        ignoreBoundary: true\n      });\n    }\n    if (!foundInsidePoint) {\n      var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n      foundInsidePoint = booleanPointInPolygon(midpoint, polygon, {\n        ignoreBoundary: true\n      });\n    }\n  }\n  return foundInsidePoint;\n}\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Polygon} geometry1\n * @param {Polygon|MultiPolygon} geometry2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(geometry1, geometry2) {\n  var poly1Bbox = calcBbox(geometry1);\n  var poly2Bbox = calcBbox(geometry2);\n  if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {\n    return false;\n  }\n  for (var i = 0; i < geometry1.coordinates[0].length; i++) {\n    if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction doBBoxOverlap(bbox1, bbox2) {\n  if (bbox1[0] > bbox2[0]) return false;\n  if (bbox1[2] < bbox2[2]) return false;\n  if (bbox1[1] > bbox2[1]) return false;\n  if (bbox1[3] < bbox2[3]) return false;\n  return true;\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n/**\n * getMidpoint\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {Position} midpoint of pair1 and pair2\n */\nfunction getMidpoint(pair1, pair2) {\n  return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexport default booleanWithin;","map":{"version":3,"names":["calcBbox","booleanPointOnLine","booleanPointInPolygon","getGeom","booleanWithin","feature1","feature2","geom1","geom2","type1","type","type2","isPointInMultiPoint","ignoreEndVertices","ignoreBoundary","Error","isMultiPointInMultiPoint","isMultiPointOnLine","isMultiPointInPoly","isLineOnLine","isLineInPoly","isPolyInPoly","point","multiPoint","i","output","coordinates","length","compareCoords","multiPoint1","multiPoint2","anyMatch","i2","lineString","foundInsidePoint","polygon","oneInside","isInside","lineString1","lineString2","linestring","polyBbox","lineBbox","doBBoxOverlap","midpoint","getMidpoint","geometry1","geometry2","poly1Bbox","poly2Bbox","bbox1","bbox2","pair1","pair2"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/boolean-within/dist/es/index.js"],"sourcesContent":["import calcBbox from \"@turf/bbox\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Boolean-within returns true if the first geometry is completely within the second geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the primary (geometry a)\n * must not intersect the exterior of the secondary (geometry b).\n * Boolean-within returns the exact opposite result of the `@turf/boolean-contains`.\n *\n * @name booleanWithin\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanWithin(point, line);\n * //=true\n */\nfunction booleanWithin(feature1, feature2) {\n    var geom1 = getGeom(feature1);\n    var geom2 = getGeom(feature2);\n    var type1 = geom1.type;\n    var type2 = geom2.type;\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"MultiPoint\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"LineString\":\n                    return booleanPointOnLine(geom1, geom2, { ignoreEndVertices: true });\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                case \"LineString\":\n                    return isMultiPointOnLine(geom1, geom2);\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isLineInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Polygon\":\n                case \"MultiPolygon\":\n                    return isPolyInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nfunction isPointInMultiPoint(point, multiPoint) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], point.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var i = 0; i < multiPoint1.coordinates.length; i++) {\n        var anyMatch = false;\n        for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {\n            if (compareCoords(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {\n                anyMatch = true;\n            }\n        }\n        if (!anyMatch) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isMultiPointOnLine(multiPoint, lineString) {\n    var foundInsidePoint = false;\n    for (var i = 0; i < multiPoint.coordinates.length; i++) {\n        if (!booleanPointOnLine(multiPoint.coordinates[i], lineString)) {\n            return false;\n        }\n        if (!foundInsidePoint) {\n            foundInsidePoint = booleanPointOnLine(multiPoint.coordinates[i], lineString, { ignoreEndVertices: true });\n        }\n    }\n    return foundInsidePoint;\n}\nfunction isMultiPointInPoly(multiPoint, polygon) {\n    var output = true;\n    var oneInside = false;\n    var isInside = false;\n    for (var i = 0; i < multiPoint.coordinates.length; i++) {\n        isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon);\n        if (!isInside) {\n            output = false;\n            break;\n        }\n        if (!oneInside) {\n            isInside = booleanPointInPolygon(multiPoint.coordinates[1], polygon, {\n                ignoreBoundary: true,\n            });\n        }\n    }\n    return output && isInside;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    for (var i = 0; i < lineString1.coordinates.length; i++) {\n        if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isLineInPoly(linestring, polygon) {\n    var polyBbox = calcBbox(polygon);\n    var lineBbox = calcBbox(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    var foundInsidePoint = false;\n    for (var i = 0; i < linestring.coordinates.length - 1; i++) {\n        if (!booleanPointInPolygon(linestring.coordinates[i], polygon)) {\n            return false;\n        }\n        if (!foundInsidePoint) {\n            foundInsidePoint = booleanPointInPolygon(linestring.coordinates[i], polygon, { ignoreBoundary: true });\n        }\n        if (!foundInsidePoint) {\n            var midpoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n            foundInsidePoint = booleanPointInPolygon(midpoint, polygon, {\n                ignoreBoundary: true,\n            });\n        }\n    }\n    return foundInsidePoint;\n}\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Polygon} geometry1\n * @param {Polygon|MultiPolygon} geometry2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(geometry1, geometry2) {\n    var poly1Bbox = calcBbox(geometry1);\n    var poly2Bbox = calcBbox(geometry2);\n    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {\n        return false;\n    }\n    for (var i = 0; i < geometry1.coordinates[0].length; i++) {\n        if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0])\n        return false;\n    if (bbox1[2] < bbox2[2])\n        return false;\n    if (bbox1[1] > bbox2[1])\n        return false;\n    if (bbox1[3] < bbox2[3])\n        return false;\n    return true;\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\n/**\n * getMidpoint\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {Position} midpoint of pair1 and pair2\n */\nfunction getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexport default booleanWithin;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}