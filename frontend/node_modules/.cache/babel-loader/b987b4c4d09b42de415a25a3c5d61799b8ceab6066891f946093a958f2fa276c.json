{"ast":null,"code":"import distance from \"@turf/distance\";\nimport { feature, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nimport tin from \"@turf/tin\";\nimport dissolve from \"./lib/turf-dissolve.js\";\n/**\n * Takes a set of {@link Point|points} and returns a concave hull Polygon or MultiPolygon.\n * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.\n *\n * @name concave\n * @param {FeatureCollection<Point>} points input points\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.maxEdge=Infinity] the length (in 'units') of an edge necessary for part of the\n * hull to become concave.\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<(Polygon|MultiPolygon)>|null} a concave hull (null value is returned if unable to compute hull)\n * @example\n * var points = turf.featureCollection([\n *   turf.point([-63.601226, 44.642643]),\n *   turf.point([-63.591442, 44.651436]),\n *   turf.point([-63.580799, 44.648749]),\n *   turf.point([-63.573589, 44.641788]),\n *   turf.point([-63.587665, 44.64533]),\n *   turf.point([-63.595218, 44.64765])\n * ]);\n * var options = {units: 'miles', maxEdge: 1};\n *\n * var hull = turf.concave(points, options);\n *\n * //addToMap\n * var addToMap = [points, hull]\n */\nfunction concave(points, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var maxEdge = options.maxEdge || Infinity;\n  var cleaned = removeDuplicates(points);\n  var tinPolys = tin(cleaned);\n  // calculate length of all edges and area of all triangles\n  // and remove triangles that fail the max length test\n  tinPolys.features = tinPolys.features.filter(function (triangle) {\n    var pt1 = triangle.geometry.coordinates[0][0];\n    var pt2 = triangle.geometry.coordinates[0][1];\n    var pt3 = triangle.geometry.coordinates[0][2];\n    var dist1 = distance(pt1, pt2, options);\n    var dist2 = distance(pt2, pt3, options);\n    var dist3 = distance(pt1, pt3, options);\n    return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;\n  });\n  if (tinPolys.features.length < 1) {\n    return null;\n  }\n  // merge the adjacent triangles\n  var dissolved = dissolve(tinPolys);\n  // geojson-dissolve always returns a MultiPolygon\n  if (dissolved.coordinates.length === 1) {\n    dissolved.coordinates = dissolved.coordinates[0];\n    dissolved.type = \"Polygon\";\n  }\n  return feature(dissolved);\n}\n/**\n * Removes duplicated points in a collection returning a new collection\n *\n * @private\n * @param {FeatureCollection<Point>} points to be cleaned\n * @returns {FeatureCollection<Point>} cleaned set of points\n */\nfunction removeDuplicates(points) {\n  var cleaned = [];\n  var existing = {};\n  featureEach(points, function (pt) {\n    if (!pt.geometry) {\n      return;\n    }\n    var key = pt.geometry.coordinates.join(\"-\");\n    if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n      cleaned.push(pt);\n      existing[key] = true;\n    }\n  });\n  return featureCollection(cleaned);\n}\nexport default concave;","map":{"version":3,"names":["distance","feature","featureCollection","featureEach","tin","dissolve","concave","points","options","maxEdge","Infinity","cleaned","removeDuplicates","tinPolys","features","filter","triangle","pt1","geometry","coordinates","pt2","pt3","dist1","dist2","dist3","length","dissolved","type","existing","pt","key","join","Object","prototype","hasOwnProperty","call","push"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/concave/dist/es/index.js"],"sourcesContent":["import distance from \"@turf/distance\";\nimport { feature, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\nimport tin from \"@turf/tin\";\nimport dissolve from \"./lib/turf-dissolve.js\";\n/**\n * Takes a set of {@link Point|points} and returns a concave hull Polygon or MultiPolygon.\n * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.\n *\n * @name concave\n * @param {FeatureCollection<Point>} points input points\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.maxEdge=Infinity] the length (in 'units') of an edge necessary for part of the\n * hull to become concave.\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<(Polygon|MultiPolygon)>|null} a concave hull (null value is returned if unable to compute hull)\n * @example\n * var points = turf.featureCollection([\n *   turf.point([-63.601226, 44.642643]),\n *   turf.point([-63.591442, 44.651436]),\n *   turf.point([-63.580799, 44.648749]),\n *   turf.point([-63.573589, 44.641788]),\n *   turf.point([-63.587665, 44.64533]),\n *   turf.point([-63.595218, 44.64765])\n * ]);\n * var options = {units: 'miles', maxEdge: 1};\n *\n * var hull = turf.concave(points, options);\n *\n * //addToMap\n * var addToMap = [points, hull]\n */\nfunction concave(points, options) {\n    if (options === void 0) { options = {}; }\n    var maxEdge = options.maxEdge || Infinity;\n    var cleaned = removeDuplicates(points);\n    var tinPolys = tin(cleaned);\n    // calculate length of all edges and area of all triangles\n    // and remove triangles that fail the max length test\n    tinPolys.features = tinPolys.features.filter(function (triangle) {\n        var pt1 = triangle.geometry.coordinates[0][0];\n        var pt2 = triangle.geometry.coordinates[0][1];\n        var pt3 = triangle.geometry.coordinates[0][2];\n        var dist1 = distance(pt1, pt2, options);\n        var dist2 = distance(pt2, pt3, options);\n        var dist3 = distance(pt1, pt3, options);\n        return dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge;\n    });\n    if (tinPolys.features.length < 1) {\n        return null;\n    }\n    // merge the adjacent triangles\n    var dissolved = dissolve(tinPolys);\n    // geojson-dissolve always returns a MultiPolygon\n    if (dissolved.coordinates.length === 1) {\n        dissolved.coordinates = dissolved.coordinates[0];\n        dissolved.type = \"Polygon\";\n    }\n    return feature(dissolved);\n}\n/**\n * Removes duplicated points in a collection returning a new collection\n *\n * @private\n * @param {FeatureCollection<Point>} points to be cleaned\n * @returns {FeatureCollection<Point>} cleaned set of points\n */\nfunction removeDuplicates(points) {\n    var cleaned = [];\n    var existing = {};\n    featureEach(points, function (pt) {\n        if (!pt.geometry) {\n            return;\n        }\n        var key = pt.geometry.coordinates.join(\"-\");\n        if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n            cleaned.push(pt);\n            existing[key] = true;\n        }\n    });\n    return featureCollection(cleaned);\n}\nexport default concave;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}