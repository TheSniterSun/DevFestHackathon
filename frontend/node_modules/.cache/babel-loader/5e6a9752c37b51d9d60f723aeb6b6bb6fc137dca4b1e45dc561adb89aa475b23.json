{"ast":null,"code":"import bbox from '@turf/bbox';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport distance from '@turf/distance';\nimport scale from '@turf/transform-scale';\nimport cleanCoords from '@turf/clean-coords';\nimport bboxPolygon from '@turf/bbox-polygon';\nimport { getCoord, getType, getGeom } from '@turf/invariant';\nimport { isObject, featureCollection, isNumber, point, feature, lineString } from '@turf/helpers';\n\n// javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\nfunction pathTo(node) {\n  var curr = node,\n    path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\nfunction getHeap() {\n  return new BinaryHeap(function (node) {\n    return node.f;\n  });\n}\n\n/**\n * Astar\n * @private\n */\nvar astar = {\n  /**\n   * Perform an A* Search on a graph given a start and end node.\n   *\n   * @private\n   * @memberof astar\n   * @param {Graph} graph Graph\n   * @param {GridNode} start Start\n   * @param {GridNode} end End\n   * @param {Object} [options] Options\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\n   * @returns {Object} Search\n   */\n  search: function (graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan,\n      closest = options.closest || false;\n    var openHeap = getHeap(),\n      closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n    openHeap.push(start);\n    while (openHeap.size() > 0) {\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\n          beenVisited = neighbor.visited;\n        if (!beenVisited || gScore < neighbor.g) {\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {\n              closestNode = neighbor;\n            }\n          }\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function (pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function (pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n    }\n  },\n  cleanNode: function (node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\n\n/**\n * A graph memory structure\n *\n * @private\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options] Options\n * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed\n * @returns {void} Graph\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\nGraph.prototype.init = function () {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\nGraph.prototype.cleanDirty = function () {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\nGraph.prototype.markDirty = function (node) {\n  this.dirtyNodes.push(node);\n};\nGraph.prototype.neighbors = function (node) {\n  var ret = [],\n    x = node.x,\n    y = node.y,\n    grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n  return ret;\n};\nGraph.prototype.toString = function () {\n  var graphString = [],\n    nodes = this.grid,\n    // when using grid\n    rowDebug,\n    row,\n    y,\n    l;\n  for (var x = 0, len = nodes.length; x < len; x++) {\n    rowDebug = [];\n    row = nodes[x];\n    for (y = 0, l = row.length; y < l; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\nGridNode.prototype.toString = function () {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\nGridNode.prototype.getCost = function (fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\nGridNode.prototype.isWall = function () {\n  return this.weight === 0;\n};\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\nBinaryHeap.prototype = {\n  push: function (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function () {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function (node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function () {\n    return this.content.length;\n  },\n  rescoreElement: function (node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function (n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = (n + 1 >> 1) - 1,\n        parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n        // Found a parent that is less, no need to sink any further.\n      } else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function (n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = n + 1 << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null,\n        child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n        // Otherwise, we are done.\n      } else {\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with\n * any {@link Feature} in {@link FeatureCollection<Polygon>| obstacles}\n *\n * @name shortestPath\n * @param {Coord} start point\n * @param {Coord} end point\n * @param {Object} [options={}] optional parameters\n * @param {Geometry|Feature|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel\n * @param {number} [options.minDistance] minimum distance between shortest path and obstacles\n * @param {string} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; it can be degrees, radians, miles, kilometers, ...\n * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated\n * @returns {Feature<LineString>} shortest path between start and end\n * @example\n * var start = [-5, -6];\n * var end = [9, -6];\n * var options = {\n *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]])\n * };\n *\n * var path = turf.shortestPath(start, end, options);\n *\n * //addToMap\n * var addToMap = [start, end, options.obstacles, path];\n */\nfunction shortestPath(start, end, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var resolution = options.resolution;\n  var minDistance = options.minDistance;\n  var obstacles = options.obstacles || featureCollection([]);\n\n  // validation\n  if (!start) throw new Error(\"start is required\");\n  if (!end) throw new Error(\"end is required\");\n  if (resolution && !isNumber(resolution) || resolution <= 0) throw new Error(\"options.resolution must be a number, greater than 0\");\n  if (minDistance) throw new Error(\"options.minDistance is not yet implemented\");\n\n  // Normalize Inputs\n  var startCoord = getCoord(start);\n  var endCoord = getCoord(end);\n  start = point(startCoord);\n  end = point(endCoord);\n\n  // Handle obstacles\n  switch (getType(obstacles)) {\n    case \"FeatureCollection\":\n      if (obstacles.features.length === 0) return lineString([startCoord, endCoord]);\n      break;\n    case \"Polygon\":\n      obstacles = featureCollection([feature(getGeom(obstacles))]);\n      break;\n    default:\n      throw new Error(\"invalid obstacles\");\n  }\n\n  // define path grid area\n  var collection = obstacles;\n  collection.features.push(start);\n  collection.features.push(end);\n  var box = bbox(scale(bboxPolygon(bbox(collection)), 1.15)); // extend 15%\n  if (!resolution) {\n    var width = distance([box[0], box[1]], [box[2], box[1]], options);\n    resolution = width / 100;\n  }\n  collection.features.pop();\n  collection.features.pop();\n  var west = box[0];\n  var south = box[1];\n  var east = box[2];\n  var north = box[3];\n  var xFraction = resolution / distance([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = resolution / distance([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n  var bboxHorizontalSide = east - west;\n  var bboxVerticalSide = north - south;\n  var columns = Math.floor(bboxHorizontalSide / cellWidth);\n  var rows = Math.floor(bboxVerticalSide / cellHeight);\n  // adjust origin of the grid\n  var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;\n  var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;\n\n  // loop through points only once to speed up process\n  // define matrix grid for A-star algorithm\n  var pointMatrix = [];\n  var matrix = [];\n  var closestToStart = [];\n  var closestToEnd = [];\n  var minDistStart = Infinity;\n  var minDistEnd = Infinity;\n  var currentY = north - deltaY;\n  var r = 0;\n  while (currentY >= south) {\n    // var currentY = south + deltaY;\n    var matrixRow = [];\n    var pointMatrixRow = [];\n    var currentX = west + deltaX;\n    var c = 0;\n    while (currentX <= east) {\n      var pt = point([currentX, currentY]);\n      var isInsideObstacle = isInside(pt, obstacles);\n      // feed obstacles matrix\n      matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar\n      // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea\n      // map point's coords\n      pointMatrixRow.push(currentX + \"|\" + currentY);\n      // set closest points\n      var distStart = distance(pt, start);\n      // if (distStart < minDistStart) {\n      if (!isInsideObstacle && distStart < minDistStart) {\n        minDistStart = distStart;\n        closestToStart = {\n          x: c,\n          y: r\n        };\n      }\n      var distEnd = distance(pt, end);\n      // if (distEnd < minDistEnd) {\n      if (!isInsideObstacle && distEnd < minDistEnd) {\n        minDistEnd = distEnd;\n        closestToEnd = {\n          x: c,\n          y: r\n        };\n      }\n      currentX += cellWidth;\n      c++;\n    }\n    matrix.push(matrixRow);\n    pointMatrix.push(pointMatrixRow);\n    currentY -= cellHeight;\n    r++;\n  }\n\n  // find path on matrix grid\n\n  // javascript-astar ----------------------\n  var graph = new Graph(matrix, {\n    diagonal: true\n  });\n  var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];\n  var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];\n  var result = astar.search(graph, startOnMatrix, endOnMatrix);\n  var path = [startCoord];\n  result.forEach(function (coord) {\n    var coords = pointMatrix[coord.x][coord.y].split(\"|\");\n    path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  });\n  path.push(endCoord);\n  // ---------------------------------------\n\n  // astar-andrea ------------------------\n  // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');\n  // var path = [start.geometry.coordinates];\n  // result.forEach(function (coord) {\n  //     var coords = pointMatrix[coord[1]][coord[0]].split('|');\n  //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  // });\n  // path.push(end.geometry.coordinates);\n  // ---------------------------------------\n\n  return cleanCoords(lineString(path));\n}\n\n/**\n * Checks if Point is inside any of the Polygons\n *\n * @private\n * @param {Feature<Point>} pt to check\n * @param {FeatureCollection<Polygon>} polygons features\n * @returns {boolean} if inside or not\n */\nfunction isInside(pt, polygons) {\n  for (var i = 0; i < polygons.features.length; i++) {\n    if (booleanPointInPolygon(pt, polygons.features[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nexport default shortestPath;","map":{"version":3,"names":["bbox","booleanPointInPolygon","distance","scale","cleanCoords","bboxPolygon","getCoord","getType","getGeom","isObject","featureCollection","isNumber","point","feature","lineString","pathTo","node","curr","path","parent","unshift","getHeap","BinaryHeap","f","astar","search","graph","start","end","options","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","closestNode","h","push","size","currentNode","pop","closed","neighbors","i","il","length","neighbor","isWall","gScore","g","getCost","beenVisited","visited","markDirty","rescoreElement","pos0","pos1","d1","Math","abs","x","d2","y","diagonal","D","D2","sqrt","min","cleanNode","Graph","gridIn","nodes","grid","row","GridNode","init","prototype","dirtyNodes","ret","toString","graphString","rowDebug","l","len","weight","join","fromNeighbor","scoreFunction","content","element","sinkDown","result","bubbleUp","remove","indexOf","n","parentN","elemScore","child2N","child1N","swap","child1Score","child1","child2","child2Score","shortestPath","Error","resolution","minDistance","obstacles","startCoord","endCoord","features","collection","box","width","west","south","east","north","xFraction","cellWidth","yFraction","cellHeight","bboxHorizontalSide","bboxVerticalSide","columns","floor","rows","deltaX","deltaY","pointMatrix","matrix","closestToStart","closestToEnd","minDistStart","Infinity","minDistEnd","currentY","r","matrixRow","pointMatrixRow","currentX","c","pt","isInsideObstacle","isInside","distStart","distEnd","startOnMatrix","endOnMatrix","forEach","coord","coords","split","polygons"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/shortest-path/dist/es/index.js"],"sourcesContent":["import bbox from '@turf/bbox';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport distance from '@turf/distance';\nimport scale from '@turf/transform-scale';\nimport cleanCoords from '@turf/clean-coords';\nimport bboxPolygon from '@turf/bbox-polygon';\nimport { getCoord, getType, getGeom } from '@turf/invariant';\nimport { isObject, featureCollection, isNumber, point, feature, lineString } from '@turf/helpers';\n\n// javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\nfunction pathTo(node) {\n  var curr = node,\n    path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function (node) {\n    return node.f;\n  });\n}\n\n/**\n * Astar\n * @private\n */\nvar astar = {\n  /**\n   * Perform an A* Search on a graph given a start and end node.\n   *\n   * @private\n   * @memberof astar\n   * @param {Graph} graph Graph\n   * @param {GridNode} start Start\n   * @param {GridNode} end End\n   * @param {Object} [options] Options\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\n   * @returns {Object} Search\n   */\n  search: function (graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan,\n      closest = options.closest || false;\n\n    var openHeap = getHeap(),\n      closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\n          beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (\n              neighbor.h < closestNode.h ||\n              (neighbor.h === closestNode.h && neighbor.g < closestNode.g)\n            ) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function (pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function (pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n    },\n  },\n  cleanNode: function (node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  },\n};\n\n/**\n * A graph memory structure\n *\n * @private\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options] Options\n * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed\n * @returns {void} Graph\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function () {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function () {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function (node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function (node) {\n  var ret = [],\n    x = node.x,\n    y = node.y,\n    grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function () {\n  var graphString = [],\n    nodes = this.grid, // when using grid\n    rowDebug,\n    row,\n    y,\n    l;\n  for (var x = 0, len = nodes.length; x < len; x++) {\n    rowDebug = [];\n    row = nodes[x];\n    for (y = 0, l = row.length; y < l; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function () {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function (fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function () {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function () {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function (node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function () {\n    return this.content.length;\n  },\n  rescoreElement: function (node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function (n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1,\n        parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n        // Found a parent that is less, no need to sink any further.\n      } else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function (n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null,\n        child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n        // Otherwise, we are done.\n      } else {\n        break;\n      }\n    }\n  },\n};\n\n/**\n * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with\n * any {@link Feature} in {@link FeatureCollection<Polygon>| obstacles}\n *\n * @name shortestPath\n * @param {Coord} start point\n * @param {Coord} end point\n * @param {Object} [options={}] optional parameters\n * @param {Geometry|Feature|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel\n * @param {number} [options.minDistance] minimum distance between shortest path and obstacles\n * @param {string} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; it can be degrees, radians, miles, kilometers, ...\n * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated\n * @returns {Feature<LineString>} shortest path between start and end\n * @example\n * var start = [-5, -6];\n * var end = [9, -6];\n * var options = {\n *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]])\n * };\n *\n * var path = turf.shortestPath(start, end, options);\n *\n * //addToMap\n * var addToMap = [start, end, options.obstacles, path];\n */\nfunction shortestPath(start, end, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var resolution = options.resolution;\n  var minDistance = options.minDistance;\n  var obstacles = options.obstacles || featureCollection([]);\n\n  // validation\n  if (!start) throw new Error(\"start is required\");\n  if (!end) throw new Error(\"end is required\");\n  if ((resolution && !isNumber(resolution)) || resolution <= 0)\n    throw new Error(\"options.resolution must be a number, greater than 0\");\n  if (minDistance)\n    throw new Error(\"options.minDistance is not yet implemented\");\n\n  // Normalize Inputs\n  var startCoord = getCoord(start);\n  var endCoord = getCoord(end);\n  start = point(startCoord);\n  end = point(endCoord);\n\n  // Handle obstacles\n  switch (getType(obstacles)) {\n    case \"FeatureCollection\":\n      if (obstacles.features.length === 0)\n        return lineString([startCoord, endCoord]);\n      break;\n    case \"Polygon\":\n      obstacles = featureCollection([feature(getGeom(obstacles))]);\n      break;\n    default:\n      throw new Error(\"invalid obstacles\");\n  }\n\n  // define path grid area\n  var collection = obstacles;\n  collection.features.push(start);\n  collection.features.push(end);\n  var box = bbox(scale(bboxPolygon(bbox(collection)), 1.15)); // extend 15%\n  if (!resolution) {\n    var width = distance([box[0], box[1]], [box[2], box[1]], options);\n    resolution = width / 100;\n  }\n  collection.features.pop();\n  collection.features.pop();\n\n  var west = box[0];\n  var south = box[1];\n  var east = box[2];\n  var north = box[3];\n\n  var xFraction = resolution / distance([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = resolution / distance([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n\n  var bboxHorizontalSide = east - west;\n  var bboxVerticalSide = north - south;\n  var columns = Math.floor(bboxHorizontalSide / cellWidth);\n  var rows = Math.floor(bboxVerticalSide / cellHeight);\n  // adjust origin of the grid\n  var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;\n  var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;\n\n  // loop through points only once to speed up process\n  // define matrix grid for A-star algorithm\n  var pointMatrix = [];\n  var matrix = [];\n\n  var closestToStart = [];\n  var closestToEnd = [];\n  var minDistStart = Infinity;\n  var minDistEnd = Infinity;\n  var currentY = north - deltaY;\n  var r = 0;\n  while (currentY >= south) {\n    // var currentY = south + deltaY;\n    var matrixRow = [];\n    var pointMatrixRow = [];\n    var currentX = west + deltaX;\n    var c = 0;\n    while (currentX <= east) {\n      var pt = point([currentX, currentY]);\n      var isInsideObstacle = isInside(pt, obstacles);\n      // feed obstacles matrix\n      matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar\n      // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea\n      // map point's coords\n      pointMatrixRow.push(currentX + \"|\" + currentY);\n      // set closest points\n      var distStart = distance(pt, start);\n      // if (distStart < minDistStart) {\n      if (!isInsideObstacle && distStart < minDistStart) {\n        minDistStart = distStart;\n        closestToStart = { x: c, y: r };\n      }\n      var distEnd = distance(pt, end);\n      // if (distEnd < minDistEnd) {\n      if (!isInsideObstacle && distEnd < minDistEnd) {\n        minDistEnd = distEnd;\n        closestToEnd = { x: c, y: r };\n      }\n      currentX += cellWidth;\n      c++;\n    }\n    matrix.push(matrixRow);\n    pointMatrix.push(pointMatrixRow);\n    currentY -= cellHeight;\n    r++;\n  }\n\n  // find path on matrix grid\n\n  // javascript-astar ----------------------\n  var graph = new Graph(matrix, { diagonal: true });\n  var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];\n  var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];\n  var result = astar.search(graph, startOnMatrix, endOnMatrix);\n\n  var path = [startCoord];\n  result.forEach(function (coord) {\n    var coords = pointMatrix[coord.x][coord.y].split(\"|\");\n    path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  });\n  path.push(endCoord);\n  // ---------------------------------------\n\n  // astar-andrea ------------------------\n  // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');\n  // var path = [start.geometry.coordinates];\n  // result.forEach(function (coord) {\n  //     var coords = pointMatrix[coord[1]][coord[0]].split('|');\n  //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  // });\n  // path.push(end.geometry.coordinates);\n  // ---------------------------------------\n\n  return cleanCoords(lineString(path));\n}\n\n/**\n * Checks if Point is inside any of the Polygons\n *\n * @private\n * @param {Feature<Point>} pt to check\n * @param {FeatureCollection<Polygon>} polygons features\n * @returns {boolean} if inside or not\n */\nfunction isInside(pt, polygons) {\n  for (var i = 0; i < polygons.features.length; i++) {\n    if (booleanPointInPolygon(pt, polygons.features[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport default shortestPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}