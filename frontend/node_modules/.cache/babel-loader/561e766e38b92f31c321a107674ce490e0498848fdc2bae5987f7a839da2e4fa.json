{"ast":null,"code":"import clone from '@turf/clone';\nimport booleanClockwise from '@turf/boolean-clockwise';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { getCoords } from '@turf/invariant';\nimport { isObject, featureCollection } from '@turf/helpers';\n\n/**\n * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).\n *\n * @name rewind\n * @param {GeoJSON} geojson input GeoJSON Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.reverse=false] enable reverse winding\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} rewind Polygon\n * @example\n * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);\n *\n * var rewind = turf.rewind(polygon);\n *\n * //addToMap\n * var addToMap = [rewind];\n */\nfunction rewind(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var reverse = options.reverse || false;\n  var mutate = options.mutate || false;\n\n  // validation\n  if (!geojson) throw new Error(\"<geojson> is required\");\n  if (typeof reverse !== \"boolean\") throw new Error(\"<reverse> must be a boolean\");\n  if (typeof mutate !== \"boolean\") throw new Error(\"<mutate> must be a boolean\");\n\n  // prevent input mutation\n  if (mutate === false) geojson = clone(geojson);\n\n  // Support Feature Collection or Geometry Collection\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        featureEach(rewindFeature(feature, reverse), function (result) {\n          results.push(result);\n        });\n      });\n      return featureCollection(results);\n  }\n  // Support Feature or Geometry Objects\n  return rewindFeature(geojson, reverse);\n}\n\n/**\n * Rewind\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {Geometry|Feature<any>} rewind Geometry or Feature\n */\nfunction rewindFeature(geojson, reverse) {\n  var type = geojson.type === \"Feature\" ? geojson.geometry.type : geojson.type;\n\n  // Support all GeoJSON Geometry Objects\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"LineString\":\n      rewindLineString(getCoords(geojson), reverse);\n      return geojson;\n    case \"Polygon\":\n      rewindPolygon(getCoords(geojson), reverse);\n      return geojson;\n    case \"MultiLineString\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindLineString(lineCoords, reverse);\n      });\n      return geojson;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindPolygon(lineCoords, reverse);\n      });\n      return geojson;\n    case \"Point\":\n    case \"MultiPoint\":\n      return geojson;\n  }\n}\n\n/**\n * Rewind LineString - outer ring clockwise\n *\n * @private\n * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindLineString(coords, reverse) {\n  if (booleanClockwise(coords) === reverse) coords.reverse();\n}\n\n/**\n * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.\n *\n * @private\n * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindPolygon(coords, reverse) {\n  // outer ring\n  if (booleanClockwise(coords[0]) !== reverse) {\n    coords[0].reverse();\n  }\n  // inner rings\n  for (var i = 1; i < coords.length; i++) {\n    if (booleanClockwise(coords[i]) === reverse) {\n      coords[i].reverse();\n    }\n  }\n}\nexport default rewind;","map":{"version":3,"names":["clone","booleanClockwise","featureEach","geomEach","getCoords","isObject","featureCollection","rewind","geojson","options","Error","reverse","mutate","results","type","geometry","rewindFeature","feature","result","push","rewindLineString","rewindPolygon","forEach","lineCoords","coords","i","length"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/rewind/dist/es/index.js"],"sourcesContent":["import clone from '@turf/clone';\nimport booleanClockwise from '@turf/boolean-clockwise';\nimport { featureEach, geomEach } from '@turf/meta';\nimport { getCoords } from '@turf/invariant';\nimport { isObject, featureCollection } from '@turf/helpers';\n\n/**\n * Rewind {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon} outer ring counterclockwise and inner rings clockwise (Uses {@link http://en.wikipedia.org/wiki/Shoelace_formula|Shoelace Formula}).\n *\n * @name rewind\n * @param {GeoJSON} geojson input GeoJSON Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.reverse=false] enable reverse winding\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} rewind Polygon\n * @example\n * var polygon = turf.polygon([[[121, -29], [138, -29], [138, -18], [121, -18], [121, -29]]]);\n *\n * var rewind = turf.rewind(polygon);\n *\n * //addToMap\n * var addToMap = [rewind];\n */\nfunction rewind(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var reverse = options.reverse || false;\n  var mutate = options.mutate || false;\n\n  // validation\n  if (!geojson) throw new Error(\"<geojson> is required\");\n  if (typeof reverse !== \"boolean\")\n    throw new Error(\"<reverse> must be a boolean\");\n  if (typeof mutate !== \"boolean\")\n    throw new Error(\"<mutate> must be a boolean\");\n\n  // prevent input mutation\n  if (mutate === false) geojson = clone(geojson);\n\n  // Support Feature Collection or Geometry Collection\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"FeatureCollection\":\n      featureEach(geojson, function (feature) {\n        featureEach(rewindFeature(feature, reverse), function (result) {\n          results.push(result);\n        });\n      });\n      return featureCollection(results);\n  }\n  // Support Feature or Geometry Objects\n  return rewindFeature(geojson, reverse);\n}\n\n/**\n * Rewind\n *\n * @private\n * @param {Geometry|Feature<any>} geojson Geometry or Feature\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {Geometry|Feature<any>} rewind Geometry or Feature\n */\nfunction rewindFeature(geojson, reverse) {\n  var type = geojson.type === \"Feature\" ? geojson.geometry.type : geojson.type;\n\n  // Support all GeoJSON Geometry Objects\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function (geometry) {\n        rewindFeature(geometry, reverse);\n      });\n      return geojson;\n    case \"LineString\":\n      rewindLineString(getCoords(geojson), reverse);\n      return geojson;\n    case \"Polygon\":\n      rewindPolygon(getCoords(geojson), reverse);\n      return geojson;\n    case \"MultiLineString\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindLineString(lineCoords, reverse);\n      });\n      return geojson;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (lineCoords) {\n        rewindPolygon(lineCoords, reverse);\n      });\n      return geojson;\n    case \"Point\":\n    case \"MultiPoint\":\n      return geojson;\n  }\n}\n\n/**\n * Rewind LineString - outer ring clockwise\n *\n * @private\n * @param {Array<Array<number>>} coords GeoJSON LineString geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindLineString(coords, reverse) {\n  if (booleanClockwise(coords) === reverse) coords.reverse();\n}\n\n/**\n * Rewind Polygon - outer ring counterclockwise and inner rings clockwise.\n *\n * @private\n * @param {Array<Array<Array<number>>>} coords GeoJSON Polygon geometry coordinates\n * @param {Boolean} [reverse=false] enable reverse winding\n * @returns {void} mutates coordinates\n */\nfunction rewindPolygon(coords, reverse) {\n  // outer ring\n  if (booleanClockwise(coords[0]) !== reverse) {\n    coords[0].reverse();\n  }\n  // inner rings\n  for (var i = 1; i < coords.length; i++) {\n    if (booleanClockwise(coords[i]) === reverse) {\n      coords[i].reverse();\n    }\n  }\n}\n\nexport default rewind;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}