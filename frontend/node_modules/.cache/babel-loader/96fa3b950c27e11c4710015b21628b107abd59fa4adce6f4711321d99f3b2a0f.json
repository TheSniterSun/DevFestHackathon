{"ast":null,"code":"import explode from '@turf/explode';\nimport centroid from '@turf/center';\nimport nearestPoint from '@turf/nearest-point';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { featureCollection, point, feature } from '@turf/helpers';\n\n/**\n * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @name pointOnFeature\n * @param {GeoJSON} geojson any Feature or FeatureCollection\n * @returns {Feature<Point>} a point on the surface of `input`\n * @example\n * var polygon = turf.polygon([[\n *   [116, -36],\n *   [131, -32],\n *   [146, -43],\n *   [155, -25],\n *   [133, -9],\n *   [111, -22],\n *   [116, -36]\n * ]]);\n *\n * var pointOnPolygon = turf.pointOnFeature(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, pointOnPolygon];\n */\nfunction pointOnFeature(geojson) {\n  // normalize\n  var fc = normalize(geojson);\n\n  // get centroid\n  var cent = centroid(fc);\n\n  // check to see if centroid is on surface\n  var onSurface = false;\n  var i = 0;\n  while (!onSurface && i < fc.features.length) {\n    var geom = fc.features[i].geometry;\n    var x, y, x1, y1, x2, y2, k;\n    var onLine = false;\n    if (geom.type === \"Point\") {\n      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      var onMultiPoint = false;\n      k = 0;\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      k = 0;\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      var j = 0;\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        k = 0;\n        var line = geom.coordinates[j];\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n          k++;\n        }\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n    i++;\n  }\n  if (onSurface) {\n    return cent;\n  } else {\n    var vertices = featureCollection([]);\n    for (i = 0; i < fc.features.length; i++) {\n      vertices.features = vertices.features.concat(explode(fc.features[i]).features);\n    }\n    // Remove distanceToPoint properties from nearestPoint()\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\n\n/**\n * Normalizes any GeoJSON to a FeatureCollection\n *\n * @private\n * @name normalize\n * @param {GeoJSON} geojson Any GeoJSON\n * @returns {FeatureCollection} FeatureCollection\n */\nfunction normalize(geojson) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n    return featureCollection([geojson]);\n  }\n  return geojson;\n}\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\nexport default pointOnFeature;","map":{"version":3,"names":["explode","centroid","nearestPoint","booleanPointInPolygon","featureCollection","point","feature","pointOnFeature","geojson","fc","normalize","cent","onSurface","i","features","length","geom","geometry","x","y","x1","y1","x2","y2","k","onLine","type","coordinates","onMultiPoint","pointOnSegment","j","line","vertices","concat","ab","Math","sqrt","ap","pb"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/point-on-feature/dist/es/index.js"],"sourcesContent":["import explode from '@turf/explode';\nimport centroid from '@turf/center';\nimport nearestPoint from '@turf/nearest-point';\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { featureCollection, point, feature } from '@turf/helpers';\n\n/**\n * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @name pointOnFeature\n * @param {GeoJSON} geojson any Feature or FeatureCollection\n * @returns {Feature<Point>} a point on the surface of `input`\n * @example\n * var polygon = turf.polygon([[\n *   [116, -36],\n *   [131, -32],\n *   [146, -43],\n *   [155, -25],\n *   [133, -9],\n *   [111, -22],\n *   [116, -36]\n * ]]);\n *\n * var pointOnPolygon = turf.pointOnFeature(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, pointOnPolygon];\n */\nfunction pointOnFeature(geojson) {\n  // normalize\n  var fc = normalize(geojson);\n\n  // get centroid\n  var cent = centroid(fc);\n\n  // check to see if centroid is on surface\n  var onSurface = false;\n  var i = 0;\n  while (!onSurface && i < fc.features.length) {\n    var geom = fc.features[i].geometry;\n    var x, y, x1, y1, x2, y2, k;\n    var onLine = false;\n    if (geom.type === \"Point\") {\n      if (\n        cent.geometry.coordinates[0] === geom.coordinates[0] &&\n        cent.geometry.coordinates[1] === geom.coordinates[1]\n      ) {\n        onSurface = true;\n      }\n    } else if (geom.type === \"MultiPoint\") {\n      var onMultiPoint = false;\n      k = 0;\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (\n          cent.geometry.coordinates[0] === geom.coordinates[k][0] &&\n          cent.geometry.coordinates[1] === geom.coordinates[k][1]\n        ) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"LineString\") {\n      k = 0;\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n        k++;\n      }\n    } else if (geom.type === \"MultiLineString\") {\n      var j = 0;\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        k = 0;\n        var line = geom.coordinates[j];\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n          k++;\n        }\n        j++;\n      }\n    } else if (geom.type === \"Polygon\" || geom.type === \"MultiPolygon\") {\n      if (booleanPointInPolygon(cent, geom)) {\n        onSurface = true;\n      }\n    }\n    i++;\n  }\n  if (onSurface) {\n    return cent;\n  } else {\n    var vertices = featureCollection([]);\n    for (i = 0; i < fc.features.length; i++) {\n      vertices.features = vertices.features.concat(\n        explode(fc.features[i]).features\n      );\n    }\n    // Remove distanceToPoint properties from nearestPoint()\n    return point(nearestPoint(cent, vertices).geometry.coordinates);\n  }\n}\n\n/**\n * Normalizes any GeoJSON to a FeatureCollection\n *\n * @private\n * @name normalize\n * @param {GeoJSON} geojson Any GeoJSON\n * @returns {FeatureCollection} FeatureCollection\n */\nfunction normalize(geojson) {\n  if (geojson.type !== \"FeatureCollection\") {\n    if (geojson.type !== \"Feature\") {\n      return featureCollection([feature(geojson)]);\n    }\n    return featureCollection([geojson]);\n  }\n  return geojson;\n}\n\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n  return ab === ap + pb;\n}\n\nexport default pointOnFeature;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}