{"ast":null,"code":"import { flattenEach } from '@turf/meta';\nimport { getType, getCoords } from '@turf/invariant';\nimport { isObject, lineString, multiLineString, lengthToDegrees } from '@turf/helpers';\n\n/**\n * https://github.com/rook2pawn/node-intersection\n *\n * Author @rook2pawn\n */\n\n/**\n * AB\n *\n * @private\n * @param {Array<Array<number>>} segment - 2 vertex line segment\n * @returns {Array<number>} coordinates [x, y]\n */\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\n\n/**\n * Cross Product\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Cross Product\n */\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n\n/**\n * Add\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Add\n */\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n\n/**\n * Sub\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Sub\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * scalarMult\n *\n * @private\n * @param {number} s scalar\n * @param {Array<number>} v coordinates [x, y]\n * @returns {Array<number>} scalarMult\n */\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\n\n/**\n * Intersect Segments\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>} intersection\n */\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection = add(p, scalarMult(t, r));\n  return intersection;\n}\n\n/**\n * Is Parallel\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {boolean} true if a and b are parallel (or co-linear)\n */\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\n\n/**\n * Intersection\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)\n */\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\n/**\n * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.\n *\n * @name lineOffset\n * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters\n * @returns {Feature<LineString|MultiLineString>} Line offset from the input line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { \"stroke\": \"#F00\" });\n *\n * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [offsetLine, line]\n * offsetLine.properties.stroke = \"#00F\"\n */\nfunction lineOffset(geojson, distance, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n\n  // Valdiation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance)) throw new Error(\"distance is required\");\n  var type = getType(geojson);\n  var properties = geojson.properties;\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(lineOffsetFeature(feature, distance, units).geometry.coordinates);\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Line Offset\n *\n * @private\n * @param {Geometry|Feature<LineString>} line input line\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {string} [units=kilometers] units\n * @returns {Feature<LineString>} Line offset from the input line\n */\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(currentCoords, coords[index + 1], offsetDegrees);\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n\n        // Handling for line segments that aren't straight\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      // Handling for lines that only have 1 segment\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\n\n/**\n * Process Segment\n * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line\n *\n * @private\n * @param {Array<number>} point1 Point coordinates\n * @param {Array<number>} point2 Point coordinates\n * @param {number} offset Offset\n * @returns {Array<Array<number>>} offset points\n */\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));\n  var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;\n  var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;\n  var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;\n  var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;\n  return [[out1x, out1y], [out2x, out2y]];\n}\nexport default lineOffset;","map":{"version":3,"names":["flattenEach","getType","getCoords","isObject","lineString","multiLineString","lengthToDegrees","ab","segment","start","end","crossProduct","v1","v2","add","sub","scalarMult","s","v","intersectSegments","a","b","p","r","q","cross","qmp","numerator","t","intersection","isParallel","lineOffset","geojson","distance","options","Error","units","undefined","isNaN","type","properties","lineOffsetFeature","coords","feature","push","geometry","coordinates","line","segments","offsetDegrees","finalCoords","forEach","currentCoords","index","length","processSegment","seg2Coords","intersects","point1","point2","offset","L","Math","sqrt","out1x","out2x","out1y","out2y"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/line-offset/dist/es/index.js"],"sourcesContent":["import { flattenEach } from '@turf/meta';\nimport { getType, getCoords } from '@turf/invariant';\nimport { isObject, lineString, multiLineString, lengthToDegrees } from '@turf/helpers';\n\n/**\n * https://github.com/rook2pawn/node-intersection\n *\n * Author @rook2pawn\n */\n\n/**\n * AB\n *\n * @private\n * @param {Array<Array<number>>} segment - 2 vertex line segment\n * @returns {Array<number>} coordinates [x, y]\n */\nfunction ab(segment) {\n  var start = segment[0];\n  var end = segment[1];\n  return [end[0] - start[0], end[1] - start[1]];\n}\n\n/**\n * Cross Product\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Cross Product\n */\nfunction crossProduct(v1, v2) {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n\n/**\n * Add\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Add\n */\nfunction add(v1, v2) {\n  return [v1[0] + v2[0], v1[1] + v2[1]];\n}\n\n/**\n * Sub\n *\n * @private\n * @param {Array<number>} v1 coordinates [x, y]\n * @param {Array<number>} v2 coordinates [x, y]\n * @returns {Array<number>} Sub\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * scalarMult\n *\n * @private\n * @param {number} s scalar\n * @param {Array<number>} v coordinates [x, y]\n * @returns {Array<number>} scalarMult\n */\nfunction scalarMult(s, v) {\n  return [s * v[0], s * v[1]];\n}\n\n/**\n * Intersect Segments\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>} intersection\n */\nfunction intersectSegments(a, b) {\n  var p = a[0];\n  var r = ab(a);\n  var q = b[0];\n  var s = ab(b);\n\n  var cross = crossProduct(r, s);\n  var qmp = sub(q, p);\n  var numerator = crossProduct(qmp, s);\n  var t = numerator / cross;\n  var intersection = add(p, scalarMult(t, r));\n  return intersection;\n}\n\n/**\n * Is Parallel\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {boolean} true if a and b are parallel (or co-linear)\n */\nfunction isParallel(a, b) {\n  var r = ab(a);\n  var s = ab(b);\n  return crossProduct(r, s) === 0;\n}\n\n/**\n * Intersection\n *\n * @private\n * @param {Array<number>} a coordinates [x, y]\n * @param {Array<number>} b coordinates [x, y]\n * @returns {Array<number>|boolean} true if a and b are parallel (or co-linear)\n */\nfunction intersection(a, b) {\n  if (isParallel(a, b)) return false;\n  return intersectSegments(a, b);\n}\n\n/**\n * Takes a {@link LineString|line} and returns a {@link LineString|line} at offset by the specified distance.\n *\n * @name lineOffset\n * @param {Geometry|Feature<LineString|MultiLineString>} geojson input GeoJSON\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, kilometers, inches, yards, meters\n * @returns {Feature<LineString|MultiLineString>} Line offset from the input line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]], { \"stroke\": \"#F00\" });\n *\n * var offsetLine = turf.lineOffset(line, 2, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [offsetLine, line]\n * offsetLine.properties.stroke = \"#00F\"\n */\nfunction lineOffset(geojson, distance, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var units = options.units;\n\n  // Valdiation\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (distance === undefined || distance === null || isNaN(distance))\n    throw new Error(\"distance is required\");\n\n  var type = getType(geojson);\n  var properties = geojson.properties;\n\n  switch (type) {\n    case \"LineString\":\n      return lineOffsetFeature(geojson, distance, units);\n    case \"MultiLineString\":\n      var coords = [];\n      flattenEach(geojson, function (feature) {\n        coords.push(\n          lineOffsetFeature(feature, distance, units).geometry.coordinates\n        );\n      });\n      return multiLineString(coords, properties);\n    default:\n      throw new Error(\"geometry \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Line Offset\n *\n * @private\n * @param {Geometry|Feature<LineString>} line input line\n * @param {number} distance distance to offset the line (can be of negative value)\n * @param {string} [units=kilometers] units\n * @returns {Feature<LineString>} Line offset from the input line\n */\nfunction lineOffsetFeature(line, distance, units) {\n  var segments = [];\n  var offsetDegrees = lengthToDegrees(distance, units);\n  var coords = getCoords(line);\n  var finalCoords = [];\n  coords.forEach(function (currentCoords, index) {\n    if (index !== coords.length - 1) {\n      var segment = processSegment(\n        currentCoords,\n        coords[index + 1],\n        offsetDegrees\n      );\n      segments.push(segment);\n      if (index > 0) {\n        var seg2Coords = segments[index - 1];\n        var intersects = intersection(segment, seg2Coords);\n\n        // Handling for line segments that aren't straight\n        if (intersects !== false) {\n          seg2Coords[1] = intersects;\n          segment[0] = intersects;\n        }\n\n        finalCoords.push(seg2Coords[0]);\n        if (index === coords.length - 2) {\n          finalCoords.push(segment[0]);\n          finalCoords.push(segment[1]);\n        }\n      }\n      // Handling for lines that only have 1 segment\n      if (coords.length === 2) {\n        finalCoords.push(segment[0]);\n        finalCoords.push(segment[1]);\n      }\n    }\n  });\n  return lineString(finalCoords, line.properties);\n}\n\n/**\n * Process Segment\n * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line\n *\n * @private\n * @param {Array<number>} point1 Point coordinates\n * @param {Array<number>} point2 Point coordinates\n * @param {number} offset Offset\n * @returns {Array<Array<number>>} offset points\n */\nfunction processSegment(point1, point2, offset) {\n  var L = Math.sqrt(\n    (point1[0] - point2[0]) * (point1[0] - point2[0]) +\n      (point1[1] - point2[1]) * (point1[1] - point2[1])\n  );\n\n  var out1x = point1[0] + (offset * (point2[1] - point1[1])) / L;\n  var out2x = point2[0] + (offset * (point2[1] - point1[1])) / L;\n  var out1y = point1[1] + (offset * (point1[0] - point2[0])) / L;\n  var out2y = point2[1] + (offset * (point1[0] - point2[0])) / L;\n  return [\n    [out1x, out1y],\n    [out2x, out2y],\n  ];\n}\n\nexport default lineOffset;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}