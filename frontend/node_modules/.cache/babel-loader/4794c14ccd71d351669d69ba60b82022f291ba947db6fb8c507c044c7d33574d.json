{"ast":null,"code":"// Cohen-Sutherland line clipping algorithm, adapted to efficiently\n// handle polylines rather than just segments\nexport function lineclip(points, bbox, result) {\n  var len = points.length,\n    codeA = bitCode(points[0], bbox),\n    part = [],\n    i,\n    codeB,\n    lastCode;\n  var a;\n  var b;\n  if (!result) result = [];\n  for (i = 1; i < len; i++) {\n    a = points[i - 1];\n    b = points[i];\n    codeB = lastCode = bitCode(b, bbox);\n    while (true) {\n      if (!(codeA | codeB)) {\n        // accept\n        part.push(a);\n        if (codeB !== lastCode) {\n          // segment went outside\n          part.push(b);\n          if (i < len - 1) {\n            // start a new line\n            result.push(part);\n            part = [];\n          }\n        } else if (i === len - 1) {\n          part.push(b);\n        }\n        break;\n      } else if (codeA & codeB) {\n        // trivial reject\n        break;\n      } else if (codeA) {\n        // a outside, intersect with clip edge\n        a = intersect(a, b, codeA, bbox);\n        codeA = bitCode(a, bbox);\n      } else {\n        // b outside\n        b = intersect(a, b, codeB, bbox);\n        codeB = bitCode(b, bbox);\n      }\n    }\n    codeA = lastCode;\n  }\n  if (part.length) result.push(part);\n  return result;\n}\n// Sutherland-Hodgeman polygon clipping algorithm\nexport function polygonclip(points, bbox) {\n  var result, edge, prev, prevInside, i, p, inside;\n  // clip against each side of the clip rectangle\n  for (edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = points[points.length - 1];\n    prevInside = !(bitCode(prev, bbox) & edge);\n    for (i = 0; i < points.length; i++) {\n      p = points[i];\n      inside = !(bitCode(p, bbox) & edge);\n      // if segment goes through the clip window, add an intersection\n      if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));\n      if (inside) result.push(p); // add a point if it's inside\n      prev = p;\n      prevInside = inside;\n    }\n    points = result;\n    if (!points.length) break;\n  }\n  return result;\n}\n// intersect a segment against one of the 4 lines that make up the bbox\nfunction intersect(a, b, edge, bbox) {\n  return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] // top\n  : edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] // bottom\n  : edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] // right\n  : edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] // left\n  : null;\n}\n// bit code reflects the point position relative to the bbox:\n//         left  mid  right\n//    top  1001  1000  1010\n//    mid  0001  0000  0010\n// bottom  0101  0100  0110\nfunction bitCode(p, bbox) {\n  var code = 0;\n  if (p[0] < bbox[0]) code |= 1;\n  // left\n  else if (p[0] > bbox[2]) code |= 2; // right\n  if (p[1] < bbox[1]) code |= 4;\n  // bottom\n  else if (p[1] > bbox[3]) code |= 8; // top\n  return code;\n}","map":{"version":3,"names":["lineclip","points","bbox","result","len","length","codeA","bitCode","part","i","codeB","lastCode","a","b","push","intersect","polygonclip","edge","prev","prevInside","p","inside","code"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/bbox-clip/dist/es/lib/lineclip.js"],"sourcesContent":["// Cohen-Sutherland line clipping algorithm, adapted to efficiently\n// handle polylines rather than just segments\nexport function lineclip(points, bbox, result) {\n    var len = points.length, codeA = bitCode(points[0], bbox), part = [], i, codeB, lastCode;\n    var a;\n    var b;\n    if (!result)\n        result = [];\n    for (i = 1; i < len; i++) {\n        a = points[i - 1];\n        b = points[i];\n        codeB = lastCode = bitCode(b, bbox);\n        while (true) {\n            if (!(codeA | codeB)) {\n                // accept\n                part.push(a);\n                if (codeB !== lastCode) {\n                    // segment went outside\n                    part.push(b);\n                    if (i < len - 1) {\n                        // start a new line\n                        result.push(part);\n                        part = [];\n                    }\n                }\n                else if (i === len - 1) {\n                    part.push(b);\n                }\n                break;\n            }\n            else if (codeA & codeB) {\n                // trivial reject\n                break;\n            }\n            else if (codeA) {\n                // a outside, intersect with clip edge\n                a = intersect(a, b, codeA, bbox);\n                codeA = bitCode(a, bbox);\n            }\n            else {\n                // b outside\n                b = intersect(a, b, codeB, bbox);\n                codeB = bitCode(b, bbox);\n            }\n        }\n        codeA = lastCode;\n    }\n    if (part.length)\n        result.push(part);\n    return result;\n}\n// Sutherland-Hodgeman polygon clipping algorithm\nexport function polygonclip(points, bbox) {\n    var result, edge, prev, prevInside, i, p, inside;\n    // clip against each side of the clip rectangle\n    for (edge = 1; edge <= 8; edge *= 2) {\n        result = [];\n        prev = points[points.length - 1];\n        prevInside = !(bitCode(prev, bbox) & edge);\n        for (i = 0; i < points.length; i++) {\n            p = points[i];\n            inside = !(bitCode(p, bbox) & edge);\n            // if segment goes through the clip window, add an intersection\n            if (inside !== prevInside)\n                result.push(intersect(prev, p, edge, bbox));\n            if (inside)\n                result.push(p); // add a point if it's inside\n            prev = p;\n            prevInside = inside;\n        }\n        points = result;\n        if (!points.length)\n            break;\n    }\n    return result;\n}\n// intersect a segment against one of the 4 lines that make up the bbox\nfunction intersect(a, b, edge, bbox) {\n    return edge & 8\n        ? [a[0] + ((b[0] - a[0]) * (bbox[3] - a[1])) / (b[1] - a[1]), bbox[3]] // top\n        : edge & 4\n            ? [a[0] + ((b[0] - a[0]) * (bbox[1] - a[1])) / (b[1] - a[1]), bbox[1]] // bottom\n            : edge & 2\n                ? [bbox[2], a[1] + ((b[1] - a[1]) * (bbox[2] - a[0])) / (b[0] - a[0])] // right\n                : edge & 1\n                    ? [bbox[0], a[1] + ((b[1] - a[1]) * (bbox[0] - a[0])) / (b[0] - a[0])] // left\n                    : null;\n}\n// bit code reflects the point position relative to the bbox:\n//         left  mid  right\n//    top  1001  1000  1010\n//    mid  0001  0000  0010\n// bottom  0101  0100  0110\nfunction bitCode(p, bbox) {\n    var code = 0;\n    if (p[0] < bbox[0])\n        code |= 1;\n    // left\n    else if (p[0] > bbox[2])\n        code |= 2; // right\n    if (p[1] < bbox[1])\n        code |= 4;\n    // bottom\n    else if (p[1] > bbox[3])\n        code |= 8; // top\n    return code;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}