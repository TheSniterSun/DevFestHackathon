{"ast":null,"code":"import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n  var bool = true;\n  flattenEach(feature1, function (flatten1) {\n    flattenEach(feature2, function (flatten2) {\n      if (bool === false) {\n        return false;\n      }\n      bool = disjoint(flatten1.geometry, flatten2.geometry);\n    });\n  });\n  return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n  switch (geom1.type) {\n    case \"Point\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !compareCoords(geom1.coordinates, geom2.coordinates);\n        case \"LineString\":\n          return !isPointOnLine(geom2, geom1);\n        case \"Polygon\":\n          return !booleanPointInPolygon(geom1, geom2);\n      }\n      /* istanbul ignore next */\n      break;\n    case \"LineString\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !isPointOnLine(geom1, geom2);\n        case \"LineString\":\n          return !isLineOnLine(geom1, geom2);\n        case \"Polygon\":\n          return !isLineInPoly(geom2, geom1);\n      }\n      /* istanbul ignore next */\n      break;\n    case \"Polygon\":\n      switch (geom2.type) {\n        case \"Point\":\n          return !booleanPointInPolygon(geom2, geom1);\n        case \"LineString\":\n          return !isLineInPoly(geom1, geom2);\n        case \"Polygon\":\n          return !isPolyInPoly(geom2, geom1);\n      }\n  }\n  return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n  for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n    if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n  var doLinesIntersect = lineIntersect(lineString1, lineString2);\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n  for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n    var coord = _a[_i];\n    if (booleanPointInPolygon(coord, polygon)) {\n      return true;\n    }\n  }\n  var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n  for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n    var coord1 = _a[_i];\n    if (booleanPointInPolygon(coord1, feature2)) {\n      return true;\n    }\n  }\n  for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n    var coord2 = _c[_b];\n    if (booleanPointInPolygon(coord2, feature1)) {\n      return true;\n    }\n  }\n  var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n  if (doLinesIntersect.features.length > 0) {\n    return true;\n  }\n  return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n  var dxc = pt[0] - lineSegmentStart[0];\n  var dyc = pt[1] - lineSegmentStart[1];\n  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n  var cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) {\n    return false;\n  }\n  if (Math.abs(dxl) >= Math.abs(dyl)) {\n    if (dxl > 0) {\n      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n    } else {\n      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n    }\n  } else if (dyl > 0) {\n    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n  } else {\n    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n  }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n  return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;","map":{"version":3,"names":["booleanPointInPolygon","lineIntersect","flattenEach","polygonToLine","booleanDisjoint","feature1","feature2","bool","flatten1","flatten2","disjoint","geometry","geom1","geom2","type","compareCoords","coordinates","isPointOnLine","isLineOnLine","isLineInPoly","isPolyInPoly","lineString","pt","i","length","isPointOnLineSegment","lineString1","lineString2","doLinesIntersect","features","polygon","_i","_a","coord","coord1","_b","_c","coord2","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","cross","Math","abs","pair1","pair2"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/boolean-disjoint/dist/es/index.js"],"sourcesContent":["import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}