{"ast":null,"code":"import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport { isObject, lineString } from '@turf/helpers';\n\n/**\n * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},\n * and a specified  distance along the line to a stop point\n * and returns a subsection of the line in-between those points.\n *\n * This can be useful for extracting only the part of a route between two distances.\n *\n * @name lineSliceAlong\n * @param {Feature<LineString>|LineString} line input line\n * @param {number} startDist distance along the line to starting point\n * @param {number} stopDist distance along the line to ending point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);\n * var start = 12.5;\n * var stop = 25;\n * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, start, stop, sliced]\n */\nfunction lineSliceAlong(line, startDist, stopDist, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var coords;\n  var slice = [];\n\n  // Validation\n  if (line.type === \"Feature\") coords = line.geometry.coordinates;else if (line.type === \"LineString\") coords = line.coordinates;else throw new Error(\"input must be a LineString Feature or Geometry\");\n  var origCoordsLength = coords.length;\n  var travelled = 0;\n  var overshot, direction, interpolated;\n  for (var i = 0; i < coords.length; i++) {\n    if (startDist >= travelled && i === coords.length - 1) break;else if (travelled > startDist && slice.length === 0) {\n      overshot = startDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n    }\n    if (travelled >= stopDist) {\n      overshot = stopDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n      return lineString(slice);\n    }\n    if (travelled >= startDist) {\n      slice.push(coords[i]);\n    }\n    if (i === coords.length - 1) {\n      return lineString(slice);\n    }\n    travelled += distance(coords[i], coords[i + 1], options);\n  }\n  if (travelled < startDist && coords.length === origCoordsLength) throw new Error(\"Start position is beyond line\");\n  var last = coords[coords.length - 1];\n  return lineString([last, last]);\n}\nexport default lineSliceAlong;","map":{"version":3,"names":["bearing","distance","destination","isObject","lineString","lineSliceAlong","line","startDist","stopDist","options","Error","coords","slice","type","geometry","coordinates","origCoordsLength","length","travelled","overshot","direction","interpolated","i","push","last"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/line-slice-along/dist/es/index.js"],"sourcesContent":["import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport { isObject, lineString } from '@turf/helpers';\n\n/**\n * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},\n * and a specified  distance along the line to a stop point\n * and returns a subsection of the line in-between those points.\n *\n * This can be useful for extracting only the part of a route between two distances.\n *\n * @name lineSliceAlong\n * @param {Feature<LineString>|LineString} line input line\n * @param {number} startDist distance along the line to starting point\n * @param {number} stopDist distance along the line to ending point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);\n * var start = 12.5;\n * var stop = 25;\n * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, start, stop, sliced]\n */\nfunction lineSliceAlong(line, startDist, stopDist, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n\n  var coords;\n  var slice = [];\n\n  // Validation\n  if (line.type === \"Feature\") coords = line.geometry.coordinates;\n  else if (line.type === \"LineString\") coords = line.coordinates;\n  else throw new Error(\"input must be a LineString Feature or Geometry\");\n  var origCoordsLength = coords.length;\n  var travelled = 0;\n  var overshot, direction, interpolated;\n  for (var i = 0; i < coords.length; i++) {\n    if (startDist >= travelled && i === coords.length - 1) break;\n    else if (travelled > startDist && slice.length === 0) {\n      overshot = startDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n    }\n\n    if (travelled >= stopDist) {\n      overshot = stopDist - travelled;\n      if (!overshot) {\n        slice.push(coords[i]);\n        return lineString(slice);\n      }\n      direction = bearing(coords[i], coords[i - 1]) - 180;\n      interpolated = destination(coords[i], overshot, direction, options);\n      slice.push(interpolated.geometry.coordinates);\n      return lineString(slice);\n    }\n\n    if (travelled >= startDist) {\n      slice.push(coords[i]);\n    }\n\n    if (i === coords.length - 1) {\n      return lineString(slice);\n    }\n\n    travelled += distance(coords[i], coords[i + 1], options);\n  }\n\n  if (travelled < startDist && coords.length === origCoordsLength)\n    throw new Error(\"Start position is beyond line\");\n\n  var last = coords[coords.length - 1];\n  return lineString([last, last]);\n}\n\nexport default lineSliceAlong;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}