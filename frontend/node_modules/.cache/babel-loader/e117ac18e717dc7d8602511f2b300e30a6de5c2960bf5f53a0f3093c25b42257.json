{"ast":null,"code":"import { geomEach, coordEach } from '@turf/meta';\nimport { multiPolygon, polygon, featureCollection } from '@turf/helpers';\n\n/**\n * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).\n * Warning: may create degenerate polygons.\n *\n * @name polygonSmooth\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} inputPolys (Multi)Polygon(s) to smooth\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.iterations=1] THe number of times to smooth the polygon. A higher value means a smoother polygon.\n * @returns {FeatureCollection<Polygon>} FeatureCollection containing the smoothed polygon/poylgons\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n *\n * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})\n *\n * //addToMap\n * var addToMap = [smoothed, polygon];\n */\nfunction polygonSmooth(inputPolys, options) {\n  var outPolys = [];\n  // Optional parameters\n  var iterations = options.iterations || 1;\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    var outCoords;\n    var poly;\n    var tempOutput;\n    switch (geom.type) {\n      case \"Polygon\":\n        outCoords = [[]];\n        for (var i = 0; i < iterations; i++) {\n          tempOutput = [[]];\n          poly = geom;\n          if (i > 0) poly = polygon(outCoords).geometry;\n          processPolygon(poly, tempOutput);\n          outCoords = tempOutput.slice(0);\n        }\n        outPolys.push(polygon(outCoords, properties));\n        break;\n      case \"MultiPolygon\":\n        outCoords = [[[]]];\n        for (var y = 0; y < iterations; y++) {\n          tempOutput = [[[]]];\n          poly = geom;\n          if (y > 0) poly = multiPolygon(outCoords).geometry;\n          processMultiPolygon(poly, tempOutput);\n          outCoords = tempOutput.slice(0);\n        }\n        outPolys.push(multiPolygon(outCoords, properties));\n        break;\n      default:\n        throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n  return featureCollection(outPolys);\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processPolygon(poly, tempOutput) {\n  var prevGeomIndex = 0;\n  var subtractCoordIndex = 0;\n  coordEach(poly, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (geometryIndex > prevGeomIndex) {\n      prevGeomIndex = geometryIndex;\n      subtractCoordIndex = coordIndex;\n      tempOutput.push([]);\n    }\n    var realCoordIndex = coordIndex - subtractCoordIndex;\n    var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];\n    var p0x = currentCoord[0];\n    var p0y = currentCoord[1];\n    var p1x = p1[0];\n    var p1y = p1[1];\n    tempOutput[geometryIndex].push([0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y]);\n    tempOutput[geometryIndex].push([0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y]);\n  }, true);\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processMultiPolygon(poly, tempOutput) {\n  var prevGeomIndex = 0;\n  var subtractCoordIndex = 0;\n  var prevMultiIndex = 0;\n  coordEach(poly, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n    if (multiFeatureIndex > prevMultiIndex) {\n      prevMultiIndex = multiFeatureIndex;\n      subtractCoordIndex = coordIndex;\n      tempOutput.push([[]]);\n    }\n    if (geometryIndex > prevGeomIndex) {\n      prevGeomIndex = geometryIndex;\n      subtractCoordIndex = coordIndex;\n      tempOutput[multiFeatureIndex].push([]);\n    }\n    var realCoordIndex = coordIndex - subtractCoordIndex;\n    var p1 = poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];\n    var p0x = currentCoord[0];\n    var p0y = currentCoord[1];\n    var p1x = p1[0];\n    var p1y = p1[1];\n    tempOutput[multiFeatureIndex][geometryIndex].push([0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y]);\n    tempOutput[multiFeatureIndex][geometryIndex].push([0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y]);\n  }, true);\n  tempOutput.forEach(function (poly) {\n    poly.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\nexport default polygonSmooth;","map":{"version":3,"names":["geomEach","coordEach","multiPolygon","polygon","featureCollection","polygonSmooth","inputPolys","options","outPolys","iterations","Error","geom","geomIndex","properties","outCoords","poly","tempOutput","type","i","geometry","processPolygon","slice","push","y","processMultiPolygon","prevGeomIndex","subtractCoordIndex","currentCoord","coordIndex","featureIndex","multiFeatureIndex","geometryIndex","realCoordIndex","p1","coordinates","p0x","p0y","p1x","p1y","forEach","ring","prevMultiIndex"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/polygon-smooth/dist/es/index.js"],"sourcesContent":["import { geomEach, coordEach } from '@turf/meta';\nimport { multiPolygon, polygon, featureCollection } from '@turf/helpers';\n\n/**\n * Smooths a {@link Polygon} or {@link MultiPolygon}. Based on [Chaikin's algorithm](http://graphics.cs.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html).\n * Warning: may create degenerate polygons.\n *\n * @name polygonSmooth\n * @param {FeatureCollection|Feature<Polygon|MultiPolygon>} inputPolys (Multi)Polygon(s) to smooth\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.iterations=1] THe number of times to smooth the polygon. A higher value means a smoother polygon.\n * @returns {FeatureCollection<Polygon>} FeatureCollection containing the smoothed polygon/poylgons\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n *\n * var smoothed = turf.polygonSmooth(polygon, {iterations: 3})\n *\n * //addToMap\n * var addToMap = [smoothed, polygon];\n */\nfunction polygonSmooth(inputPolys, options) {\n  var outPolys = [];\n  // Optional parameters\n  var iterations = options.iterations || 1;\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n\n  geomEach(inputPolys, function (geom, geomIndex, properties) {\n    var outCoords;\n    var poly;\n    var tempOutput;\n\n    switch (geom.type) {\n      case \"Polygon\":\n        outCoords = [[]];\n        for (var i = 0; i < iterations; i++) {\n          tempOutput = [[]];\n          poly = geom;\n          if (i > 0) poly = polygon(outCoords).geometry;\n          processPolygon(poly, tempOutput);\n          outCoords = tempOutput.slice(0);\n        }\n        outPolys.push(polygon(outCoords, properties));\n        break;\n      case \"MultiPolygon\":\n        outCoords = [[[]]];\n        for (var y = 0; y < iterations; y++) {\n          tempOutput = [[[]]];\n          poly = geom;\n          if (y > 0) poly = multiPolygon(outCoords).geometry;\n          processMultiPolygon(poly, tempOutput);\n          outCoords = tempOutput.slice(0);\n        }\n        outPolys.push(multiPolygon(outCoords, properties));\n        break;\n      default:\n        throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n  return featureCollection(outPolys);\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processPolygon(poly, tempOutput) {\n  var prevGeomIndex = 0;\n  var subtractCoordIndex = 0;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (geometryIndex > prevGeomIndex) {\n        prevGeomIndex = geometryIndex;\n        subtractCoordIndex = coordIndex;\n        tempOutput.push([]);\n      }\n      var realCoordIndex = coordIndex - subtractCoordIndex;\n      var p1 = poly.coordinates[geometryIndex][realCoordIndex + 1];\n      var p0x = currentCoord[0];\n      var p0y = currentCoord[1];\n      var p1x = p1[0];\n      var p1y = p1[1];\n      tempOutput[geometryIndex].push([\n        0.75 * p0x + 0.25 * p1x,\n        0.75 * p0y + 0.25 * p1y,\n      ]);\n      tempOutput[geometryIndex].push([\n        0.25 * p0x + 0.75 * p1x,\n        0.25 * p0y + 0.75 * p1y,\n      ]);\n    },\n    true\n  );\n  tempOutput.forEach(function (ring) {\n    ring.push(ring[0]);\n  });\n}\n\n/**\n * @param {poly} poly to process\n * @param {poly} tempOutput to place the results in\n * @private\n */\nfunction processMultiPolygon(poly, tempOutput) {\n  var prevGeomIndex = 0;\n  var subtractCoordIndex = 0;\n  var prevMultiIndex = 0;\n\n  coordEach(\n    poly,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (multiFeatureIndex > prevMultiIndex) {\n        prevMultiIndex = multiFeatureIndex;\n        subtractCoordIndex = coordIndex;\n        tempOutput.push([[]]);\n      }\n      if (geometryIndex > prevGeomIndex) {\n        prevGeomIndex = geometryIndex;\n        subtractCoordIndex = coordIndex;\n        tempOutput[multiFeatureIndex].push([]);\n      }\n      var realCoordIndex = coordIndex - subtractCoordIndex;\n      var p1 =\n        poly.coordinates[multiFeatureIndex][geometryIndex][realCoordIndex + 1];\n      var p0x = currentCoord[0];\n      var p0y = currentCoord[1];\n      var p1x = p1[0];\n      var p1y = p1[1];\n      tempOutput[multiFeatureIndex][geometryIndex].push([\n        0.75 * p0x + 0.25 * p1x,\n        0.75 * p0y + 0.25 * p1y,\n      ]);\n      tempOutput[multiFeatureIndex][geometryIndex].push([\n        0.25 * p0x + 0.75 * p1x,\n        0.25 * p0y + 0.75 * p1y,\n      ]);\n    },\n    true\n  );\n\n  tempOutput.forEach(function (poly) {\n    poly.forEach(function (ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\n\nexport default polygonSmooth;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}