{"ast":null,"code":"import { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport pointToLineDistance from \"@turf/point-to-line-distance\";\nimport objectAssign from \"object-assign\";\n/**\n * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,\n * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.\n *\n * @name nearestPointToLine\n * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection\n * @param {Feature|Geometry<LineString>} line Line Feature\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units='kilometers'] unit of the output distance property\n * (eg: degrees, radians, miles, or kilometers)\n * @param {Object} [options.properties={}] Translate Properties to Point\n * @returns {Feature<Point>} the closest point\n * @example\n * var pt1 = turf.point([0, 0]);\n * var pt2 = turf.point([0.5, 0.5]);\n * var points = turf.featureCollection([pt1, pt2]);\n * var line = turf.lineString([[1,1], [-1,1]]);\n *\n * var nearest = turf.nearestPointToLine(points, line);\n *\n * //addToMap\n * var addToMap = [nearest, line];\n */\nfunction nearestPointToLine(points, line, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var units = options.units;\n  var properties = options.properties || {};\n  // validation\n  var pts = normalize(points);\n  if (!pts.features.length) {\n    throw new Error(\"points must contain features\");\n  }\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (getType(line) !== \"LineString\") {\n    throw new Error(\"line must be a LineString\");\n  }\n  var dist = Infinity;\n  var pt = null;\n  featureEach(pts, function (point) {\n    var d = pointToLineDistance(point, line, {\n      units: units\n    });\n    if (d < dist) {\n      dist = d;\n      pt = point;\n    }\n  });\n  /**\n   * Translate Properties to final Point, priorities:\n   * 1. options.properties\n   * 2. inherent Point properties\n   * 3. dist custom properties created by NearestPointToLine\n   */\n  if (pt) {\n    pt.properties = objectAssign({\n      dist: dist\n    }, pt.properties, properties);\n  }\n  // if (pt) { pt.properties = objectAssign({dist}, pt.properties, properties); }\n  return pt;\n}\n/**\n * Convert Collection to FeatureCollection\n *\n * @private\n * @param {FeatureCollection|GeometryCollection} points Points\n * @returns {FeatureCollection<Point>} points\n */\nfunction normalize(points) {\n  var features = [];\n  var type = points.geometry ? points.geometry.type : points.type;\n  switch (type) {\n    case \"GeometryCollection\":\n      geomEach(points, function (geom) {\n        if (geom.type === \"Point\") {\n          features.push({\n            type: \"Feature\",\n            properties: {},\n            geometry: geom\n          });\n        }\n      });\n      return {\n        type: \"FeatureCollection\",\n        features: features\n      };\n    case \"FeatureCollection\":\n      points.features = points.features.filter(function (feature) {\n        return feature.geometry.type === \"Point\";\n      });\n      return points;\n    default:\n      throw new Error(\"points must be a Point Collection\");\n  }\n}\nexport default nearestPointToLine;","map":{"version":3,"names":["getType","featureEach","geomEach","pointToLineDistance","objectAssign","nearestPointToLine","points","line","options","units","properties","pts","normalize","features","length","Error","dist","Infinity","pt","point","d","type","geometry","geom","push","filter","feature"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/nearest-point-to-line/dist/es/index.js"],"sourcesContent":["import { getType } from \"@turf/invariant\";\nimport { featureEach, geomEach } from \"@turf/meta\";\nimport pointToLineDistance from \"@turf/point-to-line-distance\";\nimport objectAssign from \"object-assign\";\n/**\n * Returns the closest {@link Point|point}, of a {@link FeatureCollection|collection} of points,\n * to a {@link LineString|line}. The returned point has a `dist` property indicating its distance to the line.\n *\n * @name nearestPointToLine\n * @param {FeatureCollection|GeometryCollection<Point>} points Point Collection\n * @param {Feature|Geometry<LineString>} line Line Feature\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units='kilometers'] unit of the output distance property\n * (eg: degrees, radians, miles, or kilometers)\n * @param {Object} [options.properties={}] Translate Properties to Point\n * @returns {Feature<Point>} the closest point\n * @example\n * var pt1 = turf.point([0, 0]);\n * var pt2 = turf.point([0.5, 0.5]);\n * var points = turf.featureCollection([pt1, pt2]);\n * var line = turf.lineString([[1,1], [-1,1]]);\n *\n * var nearest = turf.nearestPointToLine(points, line);\n *\n * //addToMap\n * var addToMap = [nearest, line];\n */\nfunction nearestPointToLine(points, line, options) {\n    if (options === void 0) { options = {}; }\n    var units = options.units;\n    var properties = options.properties || {};\n    // validation\n    var pts = normalize(points);\n    if (!pts.features.length) {\n        throw new Error(\"points must contain features\");\n    }\n    if (!line) {\n        throw new Error(\"line is required\");\n    }\n    if (getType(line) !== \"LineString\") {\n        throw new Error(\"line must be a LineString\");\n    }\n    var dist = Infinity;\n    var pt = null;\n    featureEach(pts, function (point) {\n        var d = pointToLineDistance(point, line, { units: units });\n        if (d < dist) {\n            dist = d;\n            pt = point;\n        }\n    });\n    /**\n     * Translate Properties to final Point, priorities:\n     * 1. options.properties\n     * 2. inherent Point properties\n     * 3. dist custom properties created by NearestPointToLine\n     */\n    if (pt) {\n        pt.properties = objectAssign({ dist: dist }, pt.properties, properties);\n    }\n    // if (pt) { pt.properties = objectAssign({dist}, pt.properties, properties); }\n    return pt;\n}\n/**\n * Convert Collection to FeatureCollection\n *\n * @private\n * @param {FeatureCollection|GeometryCollection} points Points\n * @returns {FeatureCollection<Point>} points\n */\nfunction normalize(points) {\n    var features = [];\n    var type = points.geometry ? points.geometry.type : points.type;\n    switch (type) {\n        case \"GeometryCollection\":\n            geomEach(points, function (geom) {\n                if (geom.type === \"Point\") {\n                    features.push({ type: \"Feature\", properties: {}, geometry: geom });\n                }\n            });\n            return { type: \"FeatureCollection\", features: features };\n        case \"FeatureCollection\":\n            points.features = points.features.filter(function (feature) {\n                return feature.geometry.type === \"Point\";\n            });\n            return points;\n        default:\n            throw new Error(\"points must be a Point Collection\");\n    }\n}\nexport default nearestPointToLine;\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,iBAAiB;AACzC,SAASC,WAAW,EAAEC,QAAQ,QAAQ,YAAY;AAClD,OAAOC,mBAAmB,MAAM,8BAA8B;AAC9D,OAAOC,YAAY,MAAM,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,MAAM,EAAEC,IAAI,EAAEC,OAAO,EAAE;EAC/C,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC,IAAIC,KAAK,GAAGD,OAAO,CAACC,KAAK;EACzB,IAAIC,UAAU,GAAGF,OAAO,CAACE,UAAU,IAAI,CAAC,CAAC;EACzC;EACA,IAAIC,GAAG,GAAGC,SAAS,CAACN,MAAM,CAAC;EAC3B,IAAI,CAACK,GAAG,CAACE,QAAQ,CAACC,MAAM,EAAE;IACtB,MAAM,IAAIC,KAAK,CAAC,8BAA8B,CAAC;EACnD;EACA,IAAI,CAACR,IAAI,EAAE;IACP,MAAM,IAAIQ,KAAK,CAAC,kBAAkB,CAAC;EACvC;EACA,IAAIf,OAAO,CAACO,IAAI,CAAC,KAAK,YAAY,EAAE;IAChC,MAAM,IAAIQ,KAAK,CAAC,2BAA2B,CAAC;EAChD;EACA,IAAIC,IAAI,GAAGC,QAAQ;EACnB,IAAIC,EAAE,GAAG,IAAI;EACbjB,WAAW,CAACU,GAAG,EAAE,UAAUQ,KAAK,EAAE;IAC9B,IAAIC,CAAC,GAAGjB,mBAAmB,CAACgB,KAAK,EAAEZ,IAAI,EAAE;MAAEE,KAAK,EAAEA;IAAM,CAAC,CAAC;IAC1D,IAAIW,CAAC,GAAGJ,IAAI,EAAE;MACVA,IAAI,GAAGI,CAAC;MACRF,EAAE,GAAGC,KAAK;IACd;EACJ,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;AACA;EACI,IAAID,EAAE,EAAE;IACJA,EAAE,CAACR,UAAU,GAAGN,YAAY,CAAC;MAAEY,IAAI,EAAEA;IAAK,CAAC,EAAEE,EAAE,CAACR,UAAU,EAAEA,UAAU,CAAC;EAC3E;EACA;EACA,OAAOQ,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,SAASA,CAACN,MAAM,EAAE;EACvB,IAAIO,QAAQ,GAAG,EAAE;EACjB,IAAIQ,IAAI,GAAGf,MAAM,CAACgB,QAAQ,GAAGhB,MAAM,CAACgB,QAAQ,CAACD,IAAI,GAAGf,MAAM,CAACe,IAAI;EAC/D,QAAQA,IAAI;IACR,KAAK,oBAAoB;MACrBnB,QAAQ,CAACI,MAAM,EAAE,UAAUiB,IAAI,EAAE;QAC7B,IAAIA,IAAI,CAACF,IAAI,KAAK,OAAO,EAAE;UACvBR,QAAQ,CAACW,IAAI,CAAC;YAAEH,IAAI,EAAE,SAAS;YAAEX,UAAU,EAAE,CAAC,CAAC;YAAEY,QAAQ,EAAEC;UAAK,CAAC,CAAC;QACtE;MACJ,CAAC,CAAC;MACF,OAAO;QAAEF,IAAI,EAAE,mBAAmB;QAAER,QAAQ,EAAEA;MAAS,CAAC;IAC5D,KAAK,mBAAmB;MACpBP,MAAM,CAACO,QAAQ,GAAGP,MAAM,CAACO,QAAQ,CAACY,MAAM,CAAC,UAAUC,OAAO,EAAE;QACxD,OAAOA,OAAO,CAACJ,QAAQ,CAACD,IAAI,KAAK,OAAO;MAC5C,CAAC,CAAC;MACF,OAAOf,MAAM;IACjB;MACI,MAAM,IAAIS,KAAK,CAAC,mCAAmC,CAAC;EAC5D;AACJ;AACA,eAAeV,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}