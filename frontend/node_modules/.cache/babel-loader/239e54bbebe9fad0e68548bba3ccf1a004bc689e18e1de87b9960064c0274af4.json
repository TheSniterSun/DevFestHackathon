{"ast":null,"code":"import turfBBox from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport clone from \"@turf/clone\";\n/**\n * Converts (Multi)LineString(s) to Polygon(s).\n *\n * @name lineToPolygon\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\n * @example\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\n *\n * var polygon = turf.lineToPolygon(line);\n *\n * //addToMap\n * var addToMap = [polygon];\n */\nfunction lineToPolygon(lines, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a, _b, _c;\n  // Optional parameters\n  var properties = options.properties;\n  var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;\n  var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;\n  var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;\n  if (!mutate) {\n    lines = clone(lines);\n  }\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords = [];\n      lines.features.forEach(function (line) {\n        coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\n/**\n * LineString to Polygon\n *\n * @private\n * @param {Feature<LineString|MultiLineString>} line line\n * @param {Object} [properties] translates GeoJSON properties to Feature\n * @param {boolean} [autoComplete=true] auto complete linestrings\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @returns {Feature<Polygon>} line converted to Polygon\n */\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\n  properties = properties ? properties : line.type === \"Feature\" ? line.properties : {};\n  var geom = getGeom(line);\n  var coords = geom.coordinates;\n  var type = geom.type;\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords);\n      return polygon([coords], properties);\n    case \"MultiLineString\":\n      var multiCoords = [];\n      var largestArea = 0;\n      coords.forEach(function (coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n        // Largest LineString to be placed in the first position of the coordinates array\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\n/**\n * Auto Complete Coords - matches first & last coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords Coordinates\n * @returns {Array<Array<number>>} auto completed coordinates\n */\nfunction autoCompleteCoords(coords) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\n/**\n * area - quick approximate area calculation (used to sort)\n *\n * @private\n * @param {Array<number>} bbox BBox [west, south, east, north]\n * @returns {number} very quick area calculation\n */\nfunction calculateArea(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\nexport default lineToPolygon;","map":{"version":3,"names":["turfBBox","getCoords","getGeom","polygon","multiPolygon","lineString","clone","lineToPolygon","lines","options","_a","_b","_c","properties","autoComplete","orderCoords","mutate","type","coords","features","forEach","line","push","lineStringToPolygon","geom","coordinates","length","Error","autoCompleteCoords","multiCoords","largestArea","coord","area","calculateArea","unshift","first","x1","y1","last","x2","y2","bbox","west","south","east","north","Math","abs"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/line-to-polygon/dist/es/index.js"],"sourcesContent":["import turfBBox from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString, } from \"@turf/helpers\";\nimport clone from \"@turf/clone\";\n/**\n * Converts (Multi)LineString(s) to Polygon(s).\n *\n * @name lineToPolygon\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\n * @example\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\n *\n * var polygon = turf.lineToPolygon(line);\n *\n * //addToMap\n * var addToMap = [polygon];\n */\nfunction lineToPolygon(lines, options) {\n    if (options === void 0) { options = {}; }\n    var _a, _b, _c;\n    // Optional parameters\n    var properties = options.properties;\n    var autoComplete = (_a = options.autoComplete) !== null && _a !== void 0 ? _a : true;\n    var orderCoords = (_b = options.orderCoords) !== null && _b !== void 0 ? _b : true;\n    var mutate = (_c = options.mutate) !== null && _c !== void 0 ? _c : false;\n    if (!mutate) {\n        lines = clone(lines);\n    }\n    switch (lines.type) {\n        case \"FeatureCollection\":\n            var coords = [];\n            lines.features.forEach(function (line) {\n                coords.push(getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords)));\n            });\n            return multiPolygon(coords, properties);\n        default:\n            return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n    }\n}\n/**\n * LineString to Polygon\n *\n * @private\n * @param {Feature<LineString|MultiLineString>} line line\n * @param {Object} [properties] translates GeoJSON properties to Feature\n * @param {boolean} [autoComplete=true] auto complete linestrings\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @returns {Feature<Polygon>} line converted to Polygon\n */\nfunction lineStringToPolygon(line, properties, autoComplete, orderCoords) {\n    properties = properties\n        ? properties\n        : line.type === \"Feature\"\n            ? line.properties\n            : {};\n    var geom = getGeom(line);\n    var coords = geom.coordinates;\n    var type = geom.type;\n    if (!coords.length)\n        throw new Error(\"line must contain coordinates\");\n    switch (type) {\n        case \"LineString\":\n            if (autoComplete)\n                coords = autoCompleteCoords(coords);\n            return polygon([coords], properties);\n        case \"MultiLineString\":\n            var multiCoords = [];\n            var largestArea = 0;\n            coords.forEach(function (coord) {\n                if (autoComplete)\n                    coord = autoCompleteCoords(coord);\n                // Largest LineString to be placed in the first position of the coordinates array\n                if (orderCoords) {\n                    var area = calculateArea(turfBBox(lineString(coord)));\n                    if (area > largestArea) {\n                        multiCoords.unshift(coord);\n                        largestArea = area;\n                    }\n                    else\n                        multiCoords.push(coord);\n                }\n                else {\n                    multiCoords.push(coord);\n                }\n            });\n            return polygon(multiCoords, properties);\n        default:\n            throw new Error(\"geometry type \" + type + \" is not supported\");\n    }\n}\n/**\n * Auto Complete Coords - matches first & last coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords Coordinates\n * @returns {Array<Array<number>>} auto completed coordinates\n */\nfunction autoCompleteCoords(coords) {\n    var first = coords[0];\n    var x1 = first[0];\n    var y1 = first[1];\n    var last = coords[coords.length - 1];\n    var x2 = last[0];\n    var y2 = last[1];\n    if (x1 !== x2 || y1 !== y2) {\n        coords.push(first);\n    }\n    return coords;\n}\n/**\n * area - quick approximate area calculation (used to sort)\n *\n * @private\n * @param {Array<number>} bbox BBox [west, south, east, north]\n * @returns {number} very quick area calculation\n */\nfunction calculateArea(bbox) {\n    var west = bbox[0];\n    var south = bbox[1];\n    var east = bbox[2];\n    var north = bbox[3];\n    return Math.abs(west - east) * Math.abs(south - north);\n}\nexport default lineToPolygon;\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,YAAY;AACjC,SAASC,SAAS,EAAEC,OAAO,QAAQ,iBAAiB;AACpD,SAASC,OAAO,EAAEC,YAAY,EAAEC,UAAU,QAAS,eAAe;AAClE,OAAOC,KAAK,MAAM,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACC,KAAK,EAAEC,OAAO,EAAE;EACnC,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC,IAAIC,EAAE,EAAEC,EAAE,EAAEC,EAAE;EACd;EACA,IAAIC,UAAU,GAAGJ,OAAO,CAACI,UAAU;EACnC,IAAIC,YAAY,GAAG,CAACJ,EAAE,GAAGD,OAAO,CAACK,YAAY,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI;EACpF,IAAIK,WAAW,GAAG,CAACJ,EAAE,GAAGF,OAAO,CAACM,WAAW,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI;EAClF,IAAIK,MAAM,GAAG,CAACJ,EAAE,GAAGH,OAAO,CAACO,MAAM,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,KAAK;EACzE,IAAI,CAACI,MAAM,EAAE;IACTR,KAAK,GAAGF,KAAK,CAACE,KAAK,CAAC;EACxB;EACA,QAAQA,KAAK,CAACS,IAAI;IACd,KAAK,mBAAmB;MACpB,IAAIC,MAAM,GAAG,EAAE;MACfV,KAAK,CAACW,QAAQ,CAACC,OAAO,CAAC,UAAUC,IAAI,EAAE;QACnCH,MAAM,CAACI,IAAI,CAACrB,SAAS,CAACsB,mBAAmB,CAACF,IAAI,EAAE,CAAC,CAAC,EAAEP,YAAY,EAAEC,WAAW,CAAC,CAAC,CAAC;MACpF,CAAC,CAAC;MACF,OAAOX,YAAY,CAACc,MAAM,EAAEL,UAAU,CAAC;IAC3C;MACI,OAAOU,mBAAmB,CAACf,KAAK,EAAEK,UAAU,EAAEC,YAAY,EAAEC,WAAW,CAAC;EAChF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,mBAAmBA,CAACF,IAAI,EAAER,UAAU,EAAEC,YAAY,EAAEC,WAAW,EAAE;EACtEF,UAAU,GAAGA,UAAU,GACjBA,UAAU,GACVQ,IAAI,CAACJ,IAAI,KAAK,SAAS,GACnBI,IAAI,CAACR,UAAU,GACf,CAAC,CAAC;EACZ,IAAIW,IAAI,GAAGtB,OAAO,CAACmB,IAAI,CAAC;EACxB,IAAIH,MAAM,GAAGM,IAAI,CAACC,WAAW;EAC7B,IAAIR,IAAI,GAAGO,IAAI,CAACP,IAAI;EACpB,IAAI,CAACC,MAAM,CAACQ,MAAM,EACd,MAAM,IAAIC,KAAK,CAAC,+BAA+B,CAAC;EACpD,QAAQV,IAAI;IACR,KAAK,YAAY;MACb,IAAIH,YAAY,EACZI,MAAM,GAAGU,kBAAkB,CAACV,MAAM,CAAC;MACvC,OAAOf,OAAO,CAAC,CAACe,MAAM,CAAC,EAAEL,UAAU,CAAC;IACxC,KAAK,iBAAiB;MAClB,IAAIgB,WAAW,GAAG,EAAE;MACpB,IAAIC,WAAW,GAAG,CAAC;MACnBZ,MAAM,CAACE,OAAO,CAAC,UAAUW,KAAK,EAAE;QAC5B,IAAIjB,YAAY,EACZiB,KAAK,GAAGH,kBAAkB,CAACG,KAAK,CAAC;QACrC;QACA,IAAIhB,WAAW,EAAE;UACb,IAAIiB,IAAI,GAAGC,aAAa,CAACjC,QAAQ,CAACK,UAAU,CAAC0B,KAAK,CAAC,CAAC,CAAC;UACrD,IAAIC,IAAI,GAAGF,WAAW,EAAE;YACpBD,WAAW,CAACK,OAAO,CAACH,KAAK,CAAC;YAC1BD,WAAW,GAAGE,IAAI;UACtB,CAAC,MAEGH,WAAW,CAACP,IAAI,CAACS,KAAK,CAAC;QAC/B,CAAC,MACI;UACDF,WAAW,CAACP,IAAI,CAACS,KAAK,CAAC;QAC3B;MACJ,CAAC,CAAC;MACF,OAAO5B,OAAO,CAAC0B,WAAW,EAAEhB,UAAU,CAAC;IAC3C;MACI,MAAM,IAAIc,KAAK,CAAC,gBAAgB,GAAGV,IAAI,GAAG,mBAAmB,CAAC;EACtE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,kBAAkBA,CAACV,MAAM,EAAE;EAChC,IAAIiB,KAAK,GAAGjB,MAAM,CAAC,CAAC,CAAC;EACrB,IAAIkB,EAAE,GAAGD,KAAK,CAAC,CAAC,CAAC;EACjB,IAAIE,EAAE,GAAGF,KAAK,CAAC,CAAC,CAAC;EACjB,IAAIG,IAAI,GAAGpB,MAAM,CAACA,MAAM,CAACQ,MAAM,GAAG,CAAC,CAAC;EACpC,IAAIa,EAAE,GAAGD,IAAI,CAAC,CAAC,CAAC;EAChB,IAAIE,EAAE,GAAGF,IAAI,CAAC,CAAC,CAAC;EAChB,IAAIF,EAAE,KAAKG,EAAE,IAAIF,EAAE,KAAKG,EAAE,EAAE;IACxBtB,MAAM,CAACI,IAAI,CAACa,KAAK,CAAC;EACtB;EACA,OAAOjB,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASe,aAAaA,CAACQ,IAAI,EAAE;EACzB,IAAIC,IAAI,GAAGD,IAAI,CAAC,CAAC,CAAC;EAClB,IAAIE,KAAK,GAAGF,IAAI,CAAC,CAAC,CAAC;EACnB,IAAIG,IAAI,GAAGH,IAAI,CAAC,CAAC,CAAC;EAClB,IAAII,KAAK,GAAGJ,IAAI,CAAC,CAAC,CAAC;EACnB,OAAOK,IAAI,CAACC,GAAG,CAACL,IAAI,GAAGE,IAAI,CAAC,GAAGE,IAAI,CAACC,GAAG,CAACJ,KAAK,GAAGE,KAAK,CAAC;AAC1D;AACA,eAAetC,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}