{"ast":null,"code":"import bbox from '@turf/bbox';\nimport { featureEach, coordEach } from '@turf/meta';\nimport { collectionOf, getCoords } from '@turf/invariant';\nimport { isObject, featureCollection, multiLineString } from '@turf/helpers';\nimport objectAssign from 'object-assign';\n\n/**\n * @license GNU Affero General Public License.\n * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\n * v. 1.2.0\n * https://github.com/RaumZeit/MarchingSquares.js\n *\n * MarchingSquaresJS is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * MarchingSquaresJS is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * As additional permission under GNU Affero General Public License version 3\n * section 7, third-party projects (personal or commercial) may distribute,\n * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\n * requirement that said third-party project for that reason alone becomes\n * subject to any requirement of the GNU Affero General Public License version 3.\n * Any modifications to MarchingSquaresJS, however, must be shared with the public\n * and made available.\n *\n * In summary this:\n * - allows you to use MarchingSquaresJS at no cost\n * - allows you to use MarchingSquaresJS for both personal and commercial purposes\n * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\n *   license as long as this license notice is included\n * - enables you to keep the source code of your program that uses MarchingSquaresJS\n *   undisclosed\n * - forces you to share any modifications you have made to MarchingSquaresJS,\n *   e.g. bug-fixes\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Compute the isocontour(s) of a scalar 2D field given\n * a certain threshold by applying the Marching Squares\n * Algorithm. The function returns a list of path coordinates\n */\nvar defaultSettings = {\n  successCallback: null,\n  verbose: false\n};\nvar settings = {};\nfunction isoContours(data, threshold, options) {\n  /* process options */\n  options = options ? options : {};\n  var optionKeys = Object.keys(defaultSettings);\n  for (var i = 0; i < optionKeys.length; i++) {\n    var key = optionKeys[i];\n    var val = options[key];\n    val = typeof val !== \"undefined\" && val !== null ? val : defaultSettings[key];\n    settings[key] = val;\n  }\n  if (settings.verbose) console.log(\"MarchingSquaresJS-isoContours: computing isocontour for \" + threshold);\n  var ret = contourGrid2Paths(computeContourGrid(data, threshold));\n  if (typeof settings.successCallback === \"function\") settings.successCallback(ret);\n  return ret;\n}\n\n/*\n  Thats all for the public interface, below follows the actual\n  implementation\n*/\n\n/*\n################################\nIsocontour implementation below\n################################\n*/\n\n/* assume that x1 == 1 &&  x0 == 0 */\nfunction interpolateX(y, y0, y1) {\n  return (y - y0) / (y1 - y0);\n}\n\n/* compute the isocontour 4-bit grid */\nfunction computeContourGrid(data, threshold) {\n  var rows = data.length - 1;\n  var cols = data[0].length - 1;\n  var ContourGrid = {\n    rows: rows,\n    cols: cols,\n    cells: []\n  };\n  for (var j = 0; j < rows; ++j) {\n    ContourGrid.cells[j] = [];\n    for (var i = 0; i < cols; ++i) {\n      /* compose the 4-bit corner representation */\n      var cval = 0;\n      var tl = data[j + 1][i];\n      var tr = data[j + 1][i + 1];\n      var br = data[j][i + 1];\n      var bl = data[j][i];\n      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {\n        continue;\n      }\n      cval |= tl >= threshold ? 8 : 0;\n      cval |= tr >= threshold ? 4 : 0;\n      cval |= br >= threshold ? 2 : 0;\n      cval |= bl >= threshold ? 1 : 0;\n\n      /* resolve ambiguity for cval == 5 || 10 via averaging */\n      var flipped = false;\n      if (cval === 5 || cval === 10) {\n        var average = (tl + tr + br + bl) / 4;\n        if (cval === 5 && average < threshold) {\n          cval = 10;\n          flipped = true;\n        } else if (cval === 10 && average < threshold) {\n          cval = 5;\n          flipped = true;\n        }\n      }\n\n      /* add cell to ContourGrid if it contains edges */\n      if (cval !== 0 && cval !== 15) {\n        var top, bottom, left, right;\n        top = bottom = left = right = 0.5;\n        /* interpolate edges of cell */\n        if (cval === 1) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          bottom = 1 - interpolateX(threshold, br, bl);\n        } else if (cval === 2) {\n          bottom = interpolateX(threshold, bl, br);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 3) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 4) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 5) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n          bottom = 1 - interpolateX(threshold, br, bl);\n          left = 1 - interpolateX(threshold, tl, bl);\n        } else if (cval === 6) {\n          bottom = interpolateX(threshold, bl, br);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 7) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 8) {\n          left = interpolateX(threshold, bl, tl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 9) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 10) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n          bottom = interpolateX(threshold, bl, br);\n          left = interpolateX(threshold, bl, tl);\n        } else if (cval === 11) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 12) {\n          left = interpolateX(threshold, bl, tl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 13) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 14) {\n          left = interpolateX(threshold, bl, tl);\n          bottom = interpolateX(threshold, bl, br);\n        } else {\n          console.log(\"MarchingSquaresJS-isoContours: Illegal cval detected: \" + cval);\n        }\n        ContourGrid.cells[j][i] = {\n          cval: cval,\n          flipped: flipped,\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left\n        };\n      }\n    }\n  }\n  return ContourGrid;\n}\nfunction isSaddle(cell) {\n  return cell.cval === 5 || cell.cval === 10;\n}\nfunction isTrivial(cell) {\n  return cell.cval === 0 || cell.cval === 15;\n}\nfunction clearCell(cell) {\n  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {\n    cell.cval = 15;\n  }\n}\nfunction getXY(cell, edge) {\n  if (edge === \"top\") {\n    return [cell.top, 1.0];\n  } else if (edge === \"bottom\") {\n    return [cell.bottom, 0.0];\n  } else if (edge === \"right\") {\n    return [1.0, cell.right];\n  } else if (edge === \"left\") {\n    return [0.0, cell.left];\n  }\n}\nfunction contourGrid2Paths(grid) {\n  var paths = [];\n  var path_idx = 0;\n  var epsilon = 1e-7;\n  grid.cells.forEach(function (g, j) {\n    g.forEach(function (gg, i) {\n      if (typeof gg !== \"undefined\" && !isSaddle(gg) && !isTrivial(gg)) {\n        var p = tracePath(grid.cells, j, i);\n        var merged = false;\n        /* we may try to merge paths at this point */\n        if (p.info === \"mergeable\") {\n          /*\n            search backwards through the path array to find an entry\n            that starts with where the current path ends...\n          */\n          var x = p.path[p.path.length - 1][0],\n            y = p.path[p.path.length - 1][1];\n          for (var k = path_idx - 1; k >= 0; k--) {\n            if (Math.abs(paths[k][0][0] - x) <= epsilon && Math.abs(paths[k][0][1] - y) <= epsilon) {\n              for (var l = p.path.length - 2; l >= 0; --l) {\n                paths[k].unshift(p.path[l]);\n              }\n              merged = true;\n              break;\n            }\n          }\n        }\n        if (!merged) paths[path_idx++] = p.path;\n      }\n    });\n  });\n  return paths;\n}\n\n/*\n  construct consecutive line segments from starting cell by\n  walking arround the enclosed area clock-wise\n  */\nfunction tracePath(grid, j, i) {\n  var maxj = grid.length;\n  var p = [];\n  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];\n  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];\n  var dx, dy;\n  var startEdge = [\"none\", \"left\", \"bottom\", \"left\", \"right\", \"none\", \"bottom\", \"left\", \"top\", \"top\", \"none\", \"top\", \"right\", \"right\", \"bottom\", \"none\"];\n  var nextEdge = [\"none\", \"bottom\", \"right\", \"right\", \"top\", \"top\", \"top\", \"top\", \"left\", \"bottom\", \"right\", \"right\", \"left\", \"bottom\", \"left\", \"none\"];\n  var edge;\n  var currentCell = grid[j][i];\n  var cval = currentCell.cval;\n  var edge = startEdge[cval];\n  var pt = getXY(currentCell, edge);\n\n  /* push initial segment */\n  p.push([i + pt[0], j + pt[1]]);\n  edge = nextEdge[cval];\n  pt = getXY(currentCell, edge);\n  p.push([i + pt[0], j + pt[1]]);\n  clearCell(currentCell);\n\n  /* now walk arround the enclosed area in clockwise-direction */\n  var k = i + dxContour[cval];\n  var l = j + dyContour[cval];\n  var prev_cval = cval;\n  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {\n    currentCell = grid[l][k];\n    if (typeof currentCell === \"undefined\") {\n      /* path ends here */\n      //console.log(k + \" \" + l + \" is undefined, stopping path!\");\n      break;\n    }\n    cval = currentCell.cval;\n    if (cval === 0 || cval === 15) {\n      return {\n        path: p,\n        info: \"mergeable\"\n      };\n    }\n    edge = nextEdge[cval];\n    dx = dxContour[cval];\n    dy = dyContour[cval];\n    if (cval === 5 || cval === 10) {\n      /* select upper or lower band, depending on previous cells cval */\n      if (cval === 5) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 10 */\n          if (dyContour[prev_cval] === -1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          } else {\n            edge = \"right\";\n            dx = 1;\n            dy = 0;\n          }\n        } else {\n          /* real case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        }\n      } else if (cval === 10) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"top\";\n            dx = 0;\n            dy = 1;\n          } else {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        } else {\n          /* real case 10 */\n          if (dyContour[prev_cval] === 1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          }\n        }\n      }\n    }\n    pt = getXY(currentCell, edge);\n    p.push([k + pt[0], l + pt[1]]);\n    clearCell(currentCell);\n    k += dx;\n    l += dy;\n    prev_cval = cval;\n  }\n  return {\n    path: p,\n    info: \"closed\"\n  };\n}\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n\n  // sort rows (of points with the same latitude) by latitude\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n  return pointMatrix;\n}\n\n/**\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\n *\n * @name isolines\n * @param {FeatureCollection<Point>} pointGrid input points\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\n * the breaks array will define the order in which the isolines are created\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\n * @example\n * // create a grid of points with random z-values in their properties\n * var extent = [0, 30, 20, 50];\n * var cellWidth = 100;\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\n *\n * for (var i = 0; i < pointGrid.features.length; i++) {\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\n * }\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n *\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\n *\n * //addToMap\n * var addToMap = [lines];\n */\nfunction isolines(pointGrid, breaks, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var commonProperties = options.commonProperties || {};\n  var breaksProperties = options.breaksProperties || [];\n\n  // Input validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject(commonProperties)) throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties)) throw new Error(\"breaksProperties must be an Array\");\n\n  // Isoline methods\n  var matrix = gridToMatrix(pointGrid, {\n    zProperty: zProperty,\n    flip: true\n  });\n  var createdIsoLines = createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties);\n  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n  return featureCollection(scaledIsolines);\n}\n\n/**\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} zProperty name of the z-values property\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\n * @returns {Array<MultiLineString>} isolines\n */\nfunction createIsoLines(matrix, breaks, zProperty, commonProperties, breaksProperties) {\n  var results = [];\n  for (var i = 1; i < breaks.length; i++) {\n    var threshold = +breaks[i]; // make sure it's a number\n\n    var properties = objectAssign({}, commonProperties, breaksProperties[i]);\n    properties[zProperty] = threshold;\n    var isoline = multiLineString(isoContours(matrix, threshold), properties);\n    results.push(isoline);\n  }\n  return results;\n}\n\n/**\n * Translates and scales isolines\n *\n * @private\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<MultiLineString>} isolines\n */\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\n  // get dimensions (on the map) of the original grid\n  var gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  var originalWidth = gridBbox[2] - gridBbox[0];\n  var originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  var x0 = gridBbox[0];\n  var y0 = gridBbox[1];\n\n  // get number of cells per side\n  var matrixWidth = matrix[0].length - 1;\n  var matrixHeight = matrix.length - 1;\n\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  var scaleX = originalWidth / matrixWidth;\n  var scaleY = originalHeigth / matrixHeight;\n  var resize = function (point) {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  };\n\n  // resize and shift each point/line of the createdIsoLines\n  createdIsoLines.forEach(function (isoline) {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\nexport default isolines;","map":{"version":3,"names":["bbox","featureEach","coordEach","collectionOf","getCoords","isObject","featureCollection","multiLineString","objectAssign","defaultSettings","successCallback","verbose","settings","isoContours","data","threshold","options","optionKeys","Object","keys","i","length","key","val","console","log","ret","contourGrid2Paths","computeContourGrid","interpolateX","y","y0","y1","rows","cols","ContourGrid","cells","j","cval","tl","tr","br","bl","isNaN","flipped","average","top","bottom","left","right","isSaddle","cell","isTrivial","clearCell","getXY","edge","grid","paths","path_idx","epsilon","forEach","g","gg","p","tracePath","merged","info","x","path","k","Math","abs","l","unshift","maxj","dxContour","dyContour","dx","dy","startEdge","nextEdge","currentCell","pt","push","prev_cval","gridToMatrix","Error","zProperty","flip","flags","pointsMatrix","sortPointsByLatLng","matrix","r","pointRow","row","c","point","properties","matrixPosition","points","pointsByLatitude","lat","orderedRowsByLatitude","map","rowOrderedByLongitude","sort","a","b","pointMatrix","isolines","pointGrid","breaks","commonProperties","breaksProperties","Array","isArray","createdIsoLines","createIsoLines","scaledIsolines","rescaleIsolines","results","isoline","gridBbox","originalWidth","originalHeigth","x0","matrixWidth","matrixHeight","scaleX","scaleY","resize"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/isolines/dist/es/index.js"],"sourcesContent":["import bbox from '@turf/bbox';\nimport { featureEach, coordEach } from '@turf/meta';\nimport { collectionOf, getCoords } from '@turf/invariant';\nimport { isObject, featureCollection, multiLineString } from '@turf/helpers';\nimport objectAssign from 'object-assign';\n\n/**\n * @license GNU Affero General Public License.\n * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\n * v. 1.2.0\n * https://github.com/RaumZeit/MarchingSquares.js\n *\n * MarchingSquaresJS is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * MarchingSquaresJS is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * As additional permission under GNU Affero General Public License version 3\n * section 7, third-party projects (personal or commercial) may distribute,\n * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\n * requirement that said third-party project for that reason alone becomes\n * subject to any requirement of the GNU Affero General Public License version 3.\n * Any modifications to MarchingSquaresJS, however, must be shared with the public\n * and made available.\n *\n * In summary this:\n * - allows you to use MarchingSquaresJS at no cost\n * - allows you to use MarchingSquaresJS for both personal and commercial purposes\n * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\n *   license as long as this license notice is included\n * - enables you to keep the source code of your program that uses MarchingSquaresJS\n *   undisclosed\n * - forces you to share any modifications you have made to MarchingSquaresJS,\n *   e.g. bug-fixes\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Compute the isocontour(s) of a scalar 2D field given\n * a certain threshold by applying the Marching Squares\n * Algorithm. The function returns a list of path coordinates\n */\nvar defaultSettings = {\n  successCallback: null,\n  verbose: false,\n};\n\nvar settings = {};\n\nfunction isoContours(data, threshold, options) {\n  /* process options */\n  options = options ? options : {};\n\n  var optionKeys = Object.keys(defaultSettings);\n\n  for (var i = 0; i < optionKeys.length; i++) {\n    var key = optionKeys[i];\n    var val = options[key];\n    val =\n      typeof val !== \"undefined\" && val !== null ? val : defaultSettings[key];\n\n    settings[key] = val;\n  }\n\n  if (settings.verbose)\n    console.log(\n      \"MarchingSquaresJS-isoContours: computing isocontour for \" + threshold\n    );\n\n  var ret = contourGrid2Paths(computeContourGrid(data, threshold));\n\n  if (typeof settings.successCallback === \"function\")\n    settings.successCallback(ret);\n\n  return ret;\n}\n\n/*\n  Thats all for the public interface, below follows the actual\n  implementation\n*/\n\n/*\n################################\nIsocontour implementation below\n################################\n*/\n\n/* assume that x1 == 1 &&  x0 == 0 */\nfunction interpolateX(y, y0, y1) {\n  return (y - y0) / (y1 - y0);\n}\n\n/* compute the isocontour 4-bit grid */\nfunction computeContourGrid(data, threshold) {\n  var rows = data.length - 1;\n  var cols = data[0].length - 1;\n  var ContourGrid = { rows: rows, cols: cols, cells: [] };\n\n  for (var j = 0; j < rows; ++j) {\n    ContourGrid.cells[j] = [];\n    for (var i = 0; i < cols; ++i) {\n      /* compose the 4-bit corner representation */\n      var cval = 0;\n\n      var tl = data[j + 1][i];\n      var tr = data[j + 1][i + 1];\n      var br = data[j][i + 1];\n      var bl = data[j][i];\n\n      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {\n        continue;\n      }\n      cval |= tl >= threshold ? 8 : 0;\n      cval |= tr >= threshold ? 4 : 0;\n      cval |= br >= threshold ? 2 : 0;\n      cval |= bl >= threshold ? 1 : 0;\n\n      /* resolve ambiguity for cval == 5 || 10 via averaging */\n      var flipped = false;\n      if (cval === 5 || cval === 10) {\n        var average = (tl + tr + br + bl) / 4;\n        if (cval === 5 && average < threshold) {\n          cval = 10;\n          flipped = true;\n        } else if (cval === 10 && average < threshold) {\n          cval = 5;\n          flipped = true;\n        }\n      }\n\n      /* add cell to ContourGrid if it contains edges */\n      if (cval !== 0 && cval !== 15) {\n        var top, bottom, left, right;\n        top = bottom = left = right = 0.5;\n        /* interpolate edges of cell */\n        if (cval === 1) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          bottom = 1 - interpolateX(threshold, br, bl);\n        } else if (cval === 2) {\n          bottom = interpolateX(threshold, bl, br);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 3) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 4) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 5) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n          bottom = 1 - interpolateX(threshold, br, bl);\n          left = 1 - interpolateX(threshold, tl, bl);\n        } else if (cval === 6) {\n          bottom = interpolateX(threshold, bl, br);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 7) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 8) {\n          left = interpolateX(threshold, bl, tl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 9) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 10) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n          bottom = interpolateX(threshold, bl, br);\n          left = interpolateX(threshold, bl, tl);\n        } else if (cval === 11) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 12) {\n          left = interpolateX(threshold, bl, tl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 13) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 14) {\n          left = interpolateX(threshold, bl, tl);\n          bottom = interpolateX(threshold, bl, br);\n        } else {\n          console.log(\n            \"MarchingSquaresJS-isoContours: Illegal cval detected: \" + cval\n          );\n        }\n        ContourGrid.cells[j][i] = {\n          cval: cval,\n          flipped: flipped,\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left,\n        };\n      }\n    }\n  }\n\n  return ContourGrid;\n}\n\nfunction isSaddle(cell) {\n  return cell.cval === 5 || cell.cval === 10;\n}\n\nfunction isTrivial(cell) {\n  return cell.cval === 0 || cell.cval === 15;\n}\n\nfunction clearCell(cell) {\n  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {\n    cell.cval = 15;\n  }\n}\n\nfunction getXY(cell, edge) {\n  if (edge === \"top\") {\n    return [cell.top, 1.0];\n  } else if (edge === \"bottom\") {\n    return [cell.bottom, 0.0];\n  } else if (edge === \"right\") {\n    return [1.0, cell.right];\n  } else if (edge === \"left\") {\n    return [0.0, cell.left];\n  }\n}\n\nfunction contourGrid2Paths(grid) {\n  var paths = [];\n  var path_idx = 0;\n  var epsilon = 1e-7;\n\n  grid.cells.forEach(function (g, j) {\n    g.forEach(function (gg, i) {\n      if (typeof gg !== \"undefined\" && !isSaddle(gg) && !isTrivial(gg)) {\n        var p = tracePath(grid.cells, j, i);\n        var merged = false;\n        /* we may try to merge paths at this point */\n        if (p.info === \"mergeable\") {\n          /*\n            search backwards through the path array to find an entry\n            that starts with where the current path ends...\n          */\n          var x = p.path[p.path.length - 1][0],\n            y = p.path[p.path.length - 1][1];\n\n          for (var k = path_idx - 1; k >= 0; k--) {\n            if (\n              Math.abs(paths[k][0][0] - x) <= epsilon &&\n              Math.abs(paths[k][0][1] - y) <= epsilon\n            ) {\n              for (var l = p.path.length - 2; l >= 0; --l) {\n                paths[k].unshift(p.path[l]);\n              }\n              merged = true;\n              break;\n            }\n          }\n        }\n        if (!merged) paths[path_idx++] = p.path;\n      }\n    });\n  });\n\n  return paths;\n}\n\n/*\n  construct consecutive line segments from starting cell by\n  walking arround the enclosed area clock-wise\n  */\nfunction tracePath(grid, j, i) {\n  var maxj = grid.length;\n  var p = [];\n  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];\n  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];\n  var dx, dy;\n  var startEdge = [\n    \"none\",\n    \"left\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"none\",\n    \"bottom\",\n    \"left\",\n    \"top\",\n    \"top\",\n    \"none\",\n    \"top\",\n    \"right\",\n    \"right\",\n    \"bottom\",\n    \"none\",\n  ];\n  var nextEdge = [\n    \"none\",\n    \"bottom\",\n    \"right\",\n    \"right\",\n    \"top\",\n    \"top\",\n    \"top\",\n    \"top\",\n    \"left\",\n    \"bottom\",\n    \"right\",\n    \"right\",\n    \"left\",\n    \"bottom\",\n    \"left\",\n    \"none\",\n  ];\n  var edge;\n\n  var currentCell = grid[j][i];\n\n  var cval = currentCell.cval;\n  var edge = startEdge[cval];\n\n  var pt = getXY(currentCell, edge);\n\n  /* push initial segment */\n  p.push([i + pt[0], j + pt[1]]);\n  edge = nextEdge[cval];\n  pt = getXY(currentCell, edge);\n  p.push([i + pt[0], j + pt[1]]);\n  clearCell(currentCell);\n\n  /* now walk arround the enclosed area in clockwise-direction */\n  var k = i + dxContour[cval];\n  var l = j + dyContour[cval];\n  var prev_cval = cval;\n\n  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {\n    currentCell = grid[l][k];\n    if (typeof currentCell === \"undefined\") {\n      /* path ends here */\n      //console.log(k + \" \" + l + \" is undefined, stopping path!\");\n      break;\n    }\n    cval = currentCell.cval;\n    if (cval === 0 || cval === 15) {\n      return { path: p, info: \"mergeable\" };\n    }\n    edge = nextEdge[cval];\n    dx = dxContour[cval];\n    dy = dyContour[cval];\n    if (cval === 5 || cval === 10) {\n      /* select upper or lower band, depending on previous cells cval */\n      if (cval === 5) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 10 */\n          if (dyContour[prev_cval] === -1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          } else {\n            edge = \"right\";\n            dx = 1;\n            dy = 0;\n          }\n        } else {\n          /* real case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        }\n      } else if (cval === 10) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"top\";\n            dx = 0;\n            dy = 1;\n          } else {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        } else {\n          /* real case 10 */\n          if (dyContour[prev_cval] === 1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          }\n        }\n      }\n    }\n    pt = getXY(currentCell, edge);\n    p.push([k + pt[0], l + pt[1]]);\n    clearCell(currentCell);\n    k += dx;\n    l += dy;\n    prev_cval = cval;\n  }\n\n  return { path: p, info: \"closed\" };\n}\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n\n  // validation\n  collectionOf(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n\n  // divide points by rows with the same latitude\n  featureEach(points, function (point) {\n    var lat = getCoords(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return getCoords(a)[0] - getCoords(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n\n  // sort rows (of points with the same latitude) by latitude\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return getCoords(a[0])[1] - getCoords(b[0])[1];\n    else return getCoords(b[0])[1] - getCoords(a[0])[1];\n  });\n\n  return pointMatrix;\n}\n\n/**\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\n *\n * @name isolines\n * @param {FeatureCollection<Point>} pointGrid input points\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\n * the breaks array will define the order in which the isolines are created\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\n * @example\n * // create a grid of points with random z-values in their properties\n * var extent = [0, 30, 20, 50];\n * var cellWidth = 100;\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\n *\n * for (var i = 0; i < pointGrid.features.length; i++) {\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\n * }\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n *\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\n *\n * //addToMap\n * var addToMap = [lines];\n */\nfunction isolines(pointGrid, breaks, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var commonProperties = options.commonProperties || {};\n  var breaksProperties = options.breaksProperties || [];\n\n  // Input validation\n  collectionOf(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!isObject(commonProperties))\n    throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties must be an Array\");\n\n  // Isoline methods\n  var matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n  var createdIsoLines = createIsoLines(\n    matrix,\n    breaks,\n    zProperty,\n    commonProperties,\n    breaksProperties\n  );\n  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n\n  return featureCollection(scaledIsolines);\n}\n\n/**\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} zProperty name of the z-values property\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\n * @returns {Array<MultiLineString>} isolines\n */\nfunction createIsoLines(\n  matrix,\n  breaks,\n  zProperty,\n  commonProperties,\n  breaksProperties\n) {\n  var results = [];\n  for (var i = 1; i < breaks.length; i++) {\n    var threshold = +breaks[i]; // make sure it's a number\n\n    var properties = objectAssign({}, commonProperties, breaksProperties[i]);\n    properties[zProperty] = threshold;\n    var isoline = multiLineString(isoContours(matrix, threshold), properties);\n\n    results.push(isoline);\n  }\n  return results;\n}\n\n/**\n * Translates and scales isolines\n *\n * @private\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<MultiLineString>} isolines\n */\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\n  // get dimensions (on the map) of the original grid\n  var gridBbox = bbox(points); // [ minX, minY, maxX, maxY ]\n  var originalWidth = gridBbox[2] - gridBbox[0];\n  var originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  var x0 = gridBbox[0];\n  var y0 = gridBbox[1];\n\n  // get number of cells per side\n  var matrixWidth = matrix[0].length - 1;\n  var matrixHeight = matrix.length - 1;\n\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  var scaleX = originalWidth / matrixWidth;\n  var scaleY = originalHeigth / matrixHeight;\n\n  var resize = function (point) {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  };\n\n  // resize and shift each point/line of the createdIsoLines\n  createdIsoLines.forEach(function (isoline) {\n    coordEach(isoline, resize);\n  });\n  return createdIsoLines;\n}\n\nexport default isolines;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}