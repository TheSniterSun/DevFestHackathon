{"ast":null,"code":"import { segmentEach } from \"@turf/meta\";\nimport { getGeom } from \"@turf/invariant\";\nimport lineOverlap from \"@turf/line-overlap\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport GeojsonEquality from \"geojson-equality\";\n/**\n * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry\n * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\n * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\n *\n * In other words, it returns true if the two geometries overlap, provided that neither completely contains the other.\n *\n * @name booleanOverlap\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input\n * @returns {boolean} true/false\n * @example\n * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);\n * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);\n * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);\n *\n * turf.booleanOverlap(poly1, poly2)\n * //=true\n * turf.booleanOverlap(poly2, poly3)\n * //=false\n */\nexport default function booleanOverlap(feature1, feature2) {\n  var geom1 = getGeom(feature1);\n  var geom2 = getGeom(feature2);\n  var type1 = geom1.type;\n  var type2 = geom2.type;\n  if (type1 === \"MultiPoint\" && type2 !== \"MultiPoint\" || (type1 === \"LineString\" || type1 === \"MultiLineString\") && type2 !== \"LineString\" && type2 !== \"MultiLineString\" || (type1 === \"Polygon\" || type1 === \"MultiPolygon\") && type2 !== \"Polygon\" && type2 !== \"MultiPolygon\") {\n    throw new Error(\"features must be of the same type\");\n  }\n  if (type1 === \"Point\") throw new Error(\"Point geometry not supported\");\n  // features must be not equal\n  var equality = new GeojsonEquality({\n    precision: 6\n  });\n  if (equality.compare(feature1, feature2)) return false;\n  var overlap = 0;\n  switch (type1) {\n    case \"MultiPoint\":\n      for (var i = 0; i < geom1.coordinates.length; i++) {\n        for (var j = 0; j < geom2.coordinates.length; j++) {\n          var coord1 = geom1.coordinates[i];\n          var coord2 = geom2.coordinates[j];\n          if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {\n            return true;\n          }\n        }\n      }\n      return false;\n    case \"LineString\":\n    case \"MultiLineString\":\n      segmentEach(feature1, function (segment1) {\n        segmentEach(feature2, function (segment2) {\n          if (lineOverlap(segment1, segment2).features.length) overlap++;\n        });\n      });\n      break;\n    case \"Polygon\":\n    case \"MultiPolygon\":\n      segmentEach(feature1, function (segment1) {\n        segmentEach(feature2, function (segment2) {\n          if (lineIntersect(segment1, segment2).features.length) overlap++;\n        });\n      });\n      break;\n  }\n  return overlap > 0;\n}","map":{"version":3,"names":["segmentEach","getGeom","lineOverlap","lineIntersect","GeojsonEquality","booleanOverlap","feature1","feature2","geom1","geom2","type1","type","type2","Error","equality","precision","compare","overlap","i","coordinates","length","j","coord1","coord2","segment1","segment2","features"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/boolean-overlap/dist/es/index.js"],"sourcesContent":["import { segmentEach } from \"@turf/meta\";\nimport { getGeom } from \"@turf/invariant\";\nimport lineOverlap from \"@turf/line-overlap\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport GeojsonEquality from \"geojson-equality\";\n/**\n * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry\n * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,\n * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.\n *\n * In other words, it returns true if the two geometries overlap, provided that neither completely contains the other.\n *\n * @name booleanOverlap\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input\n * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input\n * @returns {boolean} true/false\n * @example\n * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);\n * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);\n * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);\n *\n * turf.booleanOverlap(poly1, poly2)\n * //=true\n * turf.booleanOverlap(poly2, poly3)\n * //=false\n */\nexport default function booleanOverlap(feature1, feature2) {\n    var geom1 = getGeom(feature1);\n    var geom2 = getGeom(feature2);\n    var type1 = geom1.type;\n    var type2 = geom2.type;\n    if ((type1 === \"MultiPoint\" && type2 !== \"MultiPoint\") ||\n        ((type1 === \"LineString\" || type1 === \"MultiLineString\") &&\n            type2 !== \"LineString\" &&\n            type2 !== \"MultiLineString\") ||\n        ((type1 === \"Polygon\" || type1 === \"MultiPolygon\") &&\n            type2 !== \"Polygon\" &&\n            type2 !== \"MultiPolygon\")) {\n        throw new Error(\"features must be of the same type\");\n    }\n    if (type1 === \"Point\")\n        throw new Error(\"Point geometry not supported\");\n    // features must be not equal\n    var equality = new GeojsonEquality({ precision: 6 });\n    if (equality.compare(feature1, feature2))\n        return false;\n    var overlap = 0;\n    switch (type1) {\n        case \"MultiPoint\":\n            for (var i = 0; i < geom1.coordinates.length; i++) {\n                for (var j = 0; j < geom2.coordinates.length; j++) {\n                    var coord1 = geom1.coordinates[i];\n                    var coord2 = geom2.coordinates[j];\n                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1]) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        case \"LineString\":\n        case \"MultiLineString\":\n            segmentEach(feature1, function (segment1) {\n                segmentEach(feature2, function (segment2) {\n                    if (lineOverlap(segment1, segment2).features.length)\n                        overlap++;\n                });\n            });\n            break;\n        case \"Polygon\":\n        case \"MultiPolygon\":\n            segmentEach(feature1, function (segment1) {\n                segmentEach(feature2, function (segment2) {\n                    if (lineIntersect(segment1, segment2).features.length)\n                        overlap++;\n                });\n            });\n            break;\n    }\n    return overlap > 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}