{"ast":null,"code":"import rbush from \"geojson-rbush\";\nimport lineSegment from \"@turf/line-segment\";\nimport nearestPointOnLine from \"@turf/nearest-point-on-line\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureEach, segmentEach } from \"@turf/meta\";\nimport { featureCollection, isObject } from \"@turf/helpers\";\nimport equal from \"deep-equal\";\n/**\n * Takes any LineString or Polygon and returns the overlapping lines between both features.\n *\n * @name lineOverlap\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)\n * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features\n * @example\n * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);\n * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);\n *\n * var overlapping = turf.lineOverlap(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, overlapping]\n */\nfunction lineOverlap(line1, line2, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance || 0;\n  // Containers\n  var features = [];\n  // Create Spatial Index\n  var tree = rbush();\n  // To-Do -- HACK way to support typescript\n  var line = lineSegment(line1);\n  tree.load(line);\n  var overlapSegment;\n  // Line Intersection\n  // Iterate over line segments\n  segmentEach(line2, function (segment) {\n    var doesOverlaps = false;\n    if (!segment) {\n      return;\n    }\n    // Iterate over each segments which falls within the same bounds\n    featureEach(tree.search(segment), function (match) {\n      if (doesOverlaps === false) {\n        var coordsSegment = getCoords(segment).sort();\n        var coordsMatch = getCoords(match).sort();\n        // Segment overlaps feature\n        if (equal(coordsSegment, coordsMatch)) {\n          doesOverlaps = true;\n          // Overlaps already exists - only append last coordinate of segment\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, segment);else overlapSegment = segment;\n          // Match segments which don't share nodes (Issue #901)\n        } else if (tolerance === 0 ? booleanPointOnLine(coordsSegment[0], match) && booleanPointOnLine(coordsSegment[1], match) : nearestPointOnLine(match, coordsSegment[0]).properties.dist <= tolerance && nearestPointOnLine(match, coordsSegment[1]).properties.dist <= tolerance) {\n          doesOverlaps = true;\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, segment);else overlapSegment = segment;\n        } else if (tolerance === 0 ? booleanPointOnLine(coordsMatch[0], segment) && booleanPointOnLine(coordsMatch[1], segment) : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <= tolerance && nearestPointOnLine(segment, coordsMatch[1]).properties.dist <= tolerance) {\n          // Do not define (doesOverlap = true) since more matches can occur within the same segment\n          // doesOverlaps = true;\n          if (overlapSegment) overlapSegment = concatSegment(overlapSegment, match);else overlapSegment = match;\n        }\n      }\n    });\n    // Segment doesn't overlap - add overlaps to results & reset\n    if (doesOverlaps === false && overlapSegment) {\n      features.push(overlapSegment);\n      overlapSegment = undefined;\n    }\n  });\n  // Add last segment if exists\n  if (overlapSegment) features.push(overlapSegment);\n  return featureCollection(features);\n}\n/**\n * Concat Segment\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<LineString>} segment 2-vertex LineString\n * @returns {Feature<LineString>} concat linestring\n */\nfunction concatSegment(line, segment) {\n  var coords = getCoords(segment);\n  var lineCoords = getCoords(line);\n  var start = lineCoords[0];\n  var end = lineCoords[lineCoords.length - 1];\n  var geom = line.geometry.coordinates;\n  if (equal(coords[0], start)) geom.unshift(coords[1]);else if (equal(coords[0], end)) geom.push(coords[1]);else if (equal(coords[1], start)) geom.unshift(coords[0]);else if (equal(coords[1], end)) geom.push(coords[0]);\n  return line;\n}\nexport default lineOverlap;","map":{"version":3,"names":["rbush","lineSegment","nearestPointOnLine","booleanPointOnLine","getCoords","featureEach","segmentEach","featureCollection","isObject","equal","lineOverlap","line1","line2","options","Error","tolerance","features","tree","line","load","overlapSegment","segment","doesOverlaps","search","match","coordsSegment","sort","coordsMatch","concatSegment","properties","dist","push","undefined","coords","lineCoords","start","end","length","geom","geometry","coordinates","unshift"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/line-overlap/dist/es/index.js"],"sourcesContent":["import rbush from \"geojson-rbush\";\nimport lineSegment from \"@turf/line-segment\";\nimport nearestPointOnLine from \"@turf/nearest-point-on-line\";\nimport booleanPointOnLine from \"@turf/boolean-point-on-line\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureEach, segmentEach } from \"@turf/meta\";\nimport { featureCollection, isObject, } from \"@turf/helpers\";\nimport equal from \"deep-equal\";\n/**\n * Takes any LineString or Polygon and returns the overlapping lines between both features.\n *\n * @name lineOverlap\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)\n * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features\n * @example\n * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);\n * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);\n *\n * var overlapping = turf.lineOverlap(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, overlapping]\n */\nfunction lineOverlap(line1, line2, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options))\n        throw new Error(\"options is invalid\");\n    var tolerance = options.tolerance || 0;\n    // Containers\n    var features = [];\n    // Create Spatial Index\n    var tree = rbush();\n    // To-Do -- HACK way to support typescript\n    var line = lineSegment(line1);\n    tree.load(line);\n    var overlapSegment;\n    // Line Intersection\n    // Iterate over line segments\n    segmentEach(line2, function (segment) {\n        var doesOverlaps = false;\n        if (!segment) {\n            return;\n        }\n        // Iterate over each segments which falls within the same bounds\n        featureEach(tree.search(segment), function (match) {\n            if (doesOverlaps === false) {\n                var coordsSegment = getCoords(segment).sort();\n                var coordsMatch = getCoords(match).sort();\n                // Segment overlaps feature\n                if (equal(coordsSegment, coordsMatch)) {\n                    doesOverlaps = true;\n                    // Overlaps already exists - only append last coordinate of segment\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, segment);\n                    else\n                        overlapSegment = segment;\n                    // Match segments which don't share nodes (Issue #901)\n                }\n                else if (tolerance === 0\n                    ? booleanPointOnLine(coordsSegment[0], match) &&\n                        booleanPointOnLine(coordsSegment[1], match)\n                    : nearestPointOnLine(match, coordsSegment[0]).properties.dist <=\n                        tolerance &&\n                        nearestPointOnLine(match, coordsSegment[1]).properties.dist <=\n                            tolerance) {\n                    doesOverlaps = true;\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, segment);\n                    else\n                        overlapSegment = segment;\n                }\n                else if (tolerance === 0\n                    ? booleanPointOnLine(coordsMatch[0], segment) &&\n                        booleanPointOnLine(coordsMatch[1], segment)\n                    : nearestPointOnLine(segment, coordsMatch[0]).properties.dist <=\n                        tolerance &&\n                        nearestPointOnLine(segment, coordsMatch[1]).properties.dist <=\n                            tolerance) {\n                    // Do not define (doesOverlap = true) since more matches can occur within the same segment\n                    // doesOverlaps = true;\n                    if (overlapSegment)\n                        overlapSegment = concatSegment(overlapSegment, match);\n                    else\n                        overlapSegment = match;\n                }\n            }\n        });\n        // Segment doesn't overlap - add overlaps to results & reset\n        if (doesOverlaps === false && overlapSegment) {\n            features.push(overlapSegment);\n            overlapSegment = undefined;\n        }\n    });\n    // Add last segment if exists\n    if (overlapSegment)\n        features.push(overlapSegment);\n    return featureCollection(features);\n}\n/**\n * Concat Segment\n *\n * @private\n * @param {Feature<LineString>} line LineString\n * @param {Feature<LineString>} segment 2-vertex LineString\n * @returns {Feature<LineString>} concat linestring\n */\nfunction concatSegment(line, segment) {\n    var coords = getCoords(segment);\n    var lineCoords = getCoords(line);\n    var start = lineCoords[0];\n    var end = lineCoords[lineCoords.length - 1];\n    var geom = line.geometry.coordinates;\n    if (equal(coords[0], start))\n        geom.unshift(coords[1]);\n    else if (equal(coords[0], end))\n        geom.push(coords[1]);\n    else if (equal(coords[1], start))\n        geom.unshift(coords[0]);\n    else if (equal(coords[1], end))\n        geom.push(coords[0]);\n    return line;\n}\nexport default lineOverlap;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}