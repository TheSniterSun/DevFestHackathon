{"ast":null,"code":"import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // validation\n  if (!point) {\n    throw new Error(\"point is required\");\n  }\n  if (!polygon) {\n    throw new Error(\"polygon is required\");\n  }\n  var pt = getCoord(point);\n  var geom = getGeom(polygon);\n  var type = geom.type;\n  var bbox = polygon.bbox;\n  var polys = geom.coordinates;\n  // Quick elimination if point is not inside bbox\n  if (bbox && inBBox(pt, bbox) === false) {\n    return false;\n  }\n  // normalize to multipolygon\n  if (type === \"Polygon\") {\n    polys = [polys];\n  }\n  var insidePoly = false;\n  for (var i = 0; i < polys.length && !insidePoly; i++) {\n    // check if it is in the outer ring first\n    if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n      var inHole = false;\n      var k = 1;\n      // check for the point in any of the holes\n      while (k < polys[i].length && !inHole) {\n        if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n          inHole = true;\n        }\n        k++;\n      }\n      if (!inHole) {\n        insidePoly = true;\n      }\n    }\n  }\n  return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n  var isInside = false;\n  if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n    ring = ring.slice(0, ring.length - 1);\n  }\n  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n    var xi = ring[i][0];\n    var yi = ring[i][1];\n    var xj = ring[j][0];\n    var yj = ring[j][1];\n    var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;\n    if (onBoundary) {\n      return !ignoreBoundary;\n    }\n    var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];\n}","map":{"version":3,"names":["getCoord","getGeom","booleanPointInPolygon","point","polygon","options","Error","pt","geom","type","bbox","polys","coordinates","inBBox","insidePoly","i","length","inRing","ignoreBoundary","inHole","k","ring","isInside","slice","j","xi","yi","xj","yj","onBoundary","intersect"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/boolean-point-in-polygon/dist/es/index.js"],"sourcesContent":["import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}