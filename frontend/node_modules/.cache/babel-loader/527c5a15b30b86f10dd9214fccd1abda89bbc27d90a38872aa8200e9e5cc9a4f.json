{"ast":null,"code":"import cleanCoords from '@turf/clean-coords';\nimport clone from '@turf/clone';\nimport { geomEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\n\n/*\n (c) 2013, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1.x - p2.x,\n    dy = p1.y - p2.y;\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n  var x = p1.x,\n    y = p1.y,\n    dx = p2.x - x,\n    dy = p2.y - y;\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2.x;\n      y = p2.y;\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p.x - x;\n  dy = p.y - y;\n  return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n  var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n  for (var i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n  if (prevPoint !== point) newPoints.push(point);\n  return newPoints;\n}\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  var maxSqDist = sqTolerance,\n    index;\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  var last = points.length - 1;\n  var simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n  if (points.length <= 2) return points;\n  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n  return points;\n}\n\n/**\n * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses\n * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.\n *\n * @name simplify\n * @param {GeoJSON} geojson object to be simplified\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=1] simplification tolerance\n * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} a simplified GeoJSON\n * @example\n * var geojson = turf.polygon([[\n *   [-70.603637, -33.399918],\n *   [-70.614624, -33.395332],\n *   [-70.639343, -33.392466],\n *   [-70.659942, -33.394759],\n *   [-70.683975, -33.404504],\n *   [-70.697021, -33.419406],\n *   [-70.701141, -33.434306],\n *   [-70.700454, -33.446339],\n *   [-70.694274, -33.458369],\n *   [-70.682601, -33.465816],\n *   [-70.668869, -33.472117],\n *   [-70.646209, -33.473835],\n *   [-70.624923, -33.472117],\n *   [-70.609817, -33.468107],\n *   [-70.595397, -33.458369],\n *   [-70.587158, -33.442901],\n *   [-70.587158, -33.426283],\n *   [-70.590591, -33.414248],\n *   [-70.594711, -33.406224],\n *   [-70.603637, -33.399918]\n * ]]);\n * var options = {tolerance: 0.01, highQuality: false};\n * var simplified = turf.simplify(geojson, options);\n *\n * //addToMap\n * var addToMap = [geojson, simplified]\n */\nfunction simplify$1(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance !== undefined ? options.tolerance : 1;\n  var highQuality = options.highQuality || false;\n  var mutate = options.mutate || false;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (tolerance && tolerance < 0) throw new Error(\"invalid tolerance\");\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n  geomEach(geojson, function (geom) {\n    simplifyGeom(geom, tolerance, highQuality);\n  });\n  return geojson;\n}\n\n/**\n * Simplifies a feature's coordinates\n *\n * @private\n * @param {Geometry} geometry to be simplified\n * @param {number} [tolerance=1] simplification tolerance\n * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @returns {Geometry} output\n */\nfunction simplifyGeom(geometry, tolerance, highQuality) {\n  var type = geometry.type;\n\n  // \"unsimplyfiable\" geometry types\n  if (type === \"Point\" || type === \"MultiPoint\") return geometry;\n\n  // Remove any extra coordinates\n  cleanCoords(geometry, true);\n  var coordinates = geometry.coordinates;\n  switch (type) {\n    case \"LineString\":\n      geometry[\"coordinates\"] = simplifyLine(coordinates, tolerance, highQuality);\n      break;\n    case \"MultiLineString\":\n      geometry[\"coordinates\"] = coordinates.map(function (lines) {\n        return simplifyLine(lines, tolerance, highQuality);\n      });\n      break;\n    case \"Polygon\":\n      geometry[\"coordinates\"] = simplifyPolygon(coordinates, tolerance, highQuality);\n      break;\n    case \"MultiPolygon\":\n      geometry[\"coordinates\"] = coordinates.map(function (rings) {\n        return simplifyPolygon(rings, tolerance, highQuality);\n      });\n  }\n  return geometry;\n}\n\n/**\n * Simplifies the coordinates of a LineString with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<number>>} simplified coords\n */\nfunction simplifyLine(coordinates, tolerance, highQuality) {\n  return simplify(coordinates.map(function (coord) {\n    return {\n      x: coord[0],\n      y: coord[1],\n      z: coord[2]\n    };\n  }), tolerance, highQuality).map(function (coords) {\n    return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n  });\n}\n\n/**\n * Simplifies the coordinates of a Polygon with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<Array<number>>>} simplified coords\n */\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n  return coordinates.map(function (ring) {\n    var pts = ring.map(function (coord) {\n      return {\n        x: coord[0],\n        y: coord[1]\n      };\n    });\n    if (pts.length < 4) {\n      throw new Error(\"invalid polygon\");\n    }\n    var simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {\n      return [coords.x, coords.y];\n    });\n    //remove 1 percent of tolerance until enough points to make a triangle\n    while (!checkValidity(simpleRing)) {\n      tolerance -= tolerance * 0.01;\n      simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {\n        return [coords.x, coords.y];\n      });\n    }\n    if (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] || simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]) {\n      simpleRing.push(simpleRing[0]);\n    }\n    return simpleRing;\n  });\n}\n\n/**\n * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last\n *\n * @private\n * @param {Array<number>} ring coordinates to be checked\n * @returns {boolean} true if valid\n */\nfunction checkValidity(ring) {\n  if (ring.length < 3) return false;\n  //if the last point is the same as the first, it's not a triangle\n  return !(ring.length === 3 && ring[2][0] === ring[0][0] && ring[2][1] === ring[0][1]);\n}\nexport default simplify$1;","map":{"version":3,"names":["cleanCoords","clone","geomEach","isObject","getSqDist","p1","p2","dx","x","dy","y","getSqSegDist","p","t","simplifyRadialDist","points","sqTolerance","prevPoint","newPoints","point","i","len","length","push","simplifyDPStep","first","last","simplified","maxSqDist","index","sqDist","simplifyDouglasPeucker","simplify","tolerance","highestQuality","undefined","simplify$1","geojson","options","Error","highQuality","mutate","geom","simplifyGeom","geometry","type","coordinates","simplifyLine","map","lines","simplifyPolygon","rings","coord","z","coords","ring","pts","simpleRing","checkValidity"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/simplify/dist/es/index.js"],"sourcesContent":["import cleanCoords from '@turf/clean-coords';\nimport clone from '@turf/clone';\nimport { geomEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\n\n/*\n (c) 2013, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1.x - p2.x,\n    dy = p1.y - p2.y;\n\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n  var x = p1.x,\n    y = p1.y,\n    dx = p2.x - x,\n    dy = p2.y - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2.x;\n      y = p2.y;\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p.x - x;\n  dy = p.y - y;\n\n  return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n  var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n\n  if (prevPoint !== point) newPoints.push(point);\n\n  return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  var maxSqDist = sqTolerance,\n    index;\n\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1)\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1)\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  var last = points.length - 1;\n\n  var simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n  if (points.length <= 2) return points;\n\n  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n\n  return points;\n}\n\n/**\n * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses\n * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.\n *\n * @name simplify\n * @param {GeoJSON} geojson object to be simplified\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=1] simplification tolerance\n * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} a simplified GeoJSON\n * @example\n * var geojson = turf.polygon([[\n *   [-70.603637, -33.399918],\n *   [-70.614624, -33.395332],\n *   [-70.639343, -33.392466],\n *   [-70.659942, -33.394759],\n *   [-70.683975, -33.404504],\n *   [-70.697021, -33.419406],\n *   [-70.701141, -33.434306],\n *   [-70.700454, -33.446339],\n *   [-70.694274, -33.458369],\n *   [-70.682601, -33.465816],\n *   [-70.668869, -33.472117],\n *   [-70.646209, -33.473835],\n *   [-70.624923, -33.472117],\n *   [-70.609817, -33.468107],\n *   [-70.595397, -33.458369],\n *   [-70.587158, -33.442901],\n *   [-70.587158, -33.426283],\n *   [-70.590591, -33.414248],\n *   [-70.594711, -33.406224],\n *   [-70.603637, -33.399918]\n * ]]);\n * var options = {tolerance: 0.01, highQuality: false};\n * var simplified = turf.simplify(geojson, options);\n *\n * //addToMap\n * var addToMap = [geojson, simplified]\n */\nfunction simplify$1(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance !== undefined ? options.tolerance : 1;\n  var highQuality = options.highQuality || false;\n  var mutate = options.mutate || false;\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (tolerance && tolerance < 0) throw new Error(\"invalid tolerance\");\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  geomEach(geojson, function (geom) {\n    simplifyGeom(geom, tolerance, highQuality);\n  });\n  return geojson;\n}\n\n/**\n * Simplifies a feature's coordinates\n *\n * @private\n * @param {Geometry} geometry to be simplified\n * @param {number} [tolerance=1] simplification tolerance\n * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @returns {Geometry} output\n */\nfunction simplifyGeom(geometry, tolerance, highQuality) {\n  var type = geometry.type;\n\n  // \"unsimplyfiable\" geometry types\n  if (type === \"Point\" || type === \"MultiPoint\") return geometry;\n\n  // Remove any extra coordinates\n  cleanCoords(geometry, true);\n\n  var coordinates = geometry.coordinates;\n  switch (type) {\n    case \"LineString\":\n      geometry[\"coordinates\"] = simplifyLine(\n        coordinates,\n        tolerance,\n        highQuality\n      );\n      break;\n    case \"MultiLineString\":\n      geometry[\"coordinates\"] = coordinates.map(function (lines) {\n        return simplifyLine(lines, tolerance, highQuality);\n      });\n      break;\n    case \"Polygon\":\n      geometry[\"coordinates\"] = simplifyPolygon(\n        coordinates,\n        tolerance,\n        highQuality\n      );\n      break;\n    case \"MultiPolygon\":\n      geometry[\"coordinates\"] = coordinates.map(function (rings) {\n        return simplifyPolygon(rings, tolerance, highQuality);\n      });\n  }\n  return geometry;\n}\n\n/**\n * Simplifies the coordinates of a LineString with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<number>>} simplified coords\n */\nfunction simplifyLine(coordinates, tolerance, highQuality) {\n  return simplify(\n    coordinates.map(function (coord) {\n      return { x: coord[0], y: coord[1], z: coord[2] };\n    }),\n    tolerance,\n    highQuality\n  ).map(function (coords) {\n    return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n  });\n}\n\n/**\n * Simplifies the coordinates of a Polygon with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<Array<number>>>} simplified coords\n */\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n  return coordinates.map(function (ring) {\n    var pts = ring.map(function (coord) {\n      return { x: coord[0], y: coord[1] };\n    });\n    if (pts.length < 4) {\n      throw new Error(\"invalid polygon\");\n    }\n    var simpleRing = simplify(pts, tolerance, highQuality).map(function (\n      coords\n    ) {\n      return [coords.x, coords.y];\n    });\n    //remove 1 percent of tolerance until enough points to make a triangle\n    while (!checkValidity(simpleRing)) {\n      tolerance -= tolerance * 0.01;\n      simpleRing = simplify(pts, tolerance, highQuality).map(function (\n        coords\n      ) {\n        return [coords.x, coords.y];\n      });\n    }\n    if (\n      simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] ||\n      simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]\n    ) {\n      simpleRing.push(simpleRing[0]);\n    }\n    return simpleRing;\n  });\n}\n\n/**\n * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last\n *\n * @private\n * @param {Array<number>} ring coordinates to be checked\n * @returns {boolean} true if valid\n */\nfunction checkValidity(ring) {\n  if (ring.length < 3) return false;\n  //if the last point is the same as the first, it's not a triangle\n  return !(\n    ring.length === 3 &&\n    ring[2][0] === ring[0][0] &&\n    ring[2][1] === ring[0][1]\n  );\n}\n\nexport default simplify$1;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}