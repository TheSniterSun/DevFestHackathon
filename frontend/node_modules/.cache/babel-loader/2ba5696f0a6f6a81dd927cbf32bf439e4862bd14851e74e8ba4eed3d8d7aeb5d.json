{"ast":null,"code":"// Taken from http://geomalgorithms.com/a02-_lines.html\nimport getDistance from \"@turf/distance\";\nimport { convertLength, feature, lineString, point } from \"@turf/helpers\";\nimport { featureOf } from \"@turf/invariant\";\nimport { segmentEach } from \"@turf/meta\";\nimport getPlanarDistance from \"@turf/rhumb-distance\";\n/**\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\n * minimum distance between the point and any segment of the `LineString`.\n *\n * @name pointToLineDistance\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\n * (ex: degrees, radians, miles, or kilometers)\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\n * @returns {number} distance between point and line\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[1, 1],[-1, 1]]);\n *\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\n * //=69.11854715938406\n */\nfunction pointToLineDistance(pt, line, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Optional parameters\n  if (!options.method) {\n    options.method = \"geodesic\";\n  }\n  if (!options.units) {\n    options.units = \"kilometers\";\n  }\n  // validation\n  if (!pt) {\n    throw new Error(\"pt is required\");\n  }\n  if (Array.isArray(pt)) {\n    pt = point(pt);\n  } else if (pt.type === \"Point\") {\n    pt = feature(pt);\n  } else {\n    featureOf(pt, \"Point\", \"point\");\n  }\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (Array.isArray(line)) {\n    line = lineString(line);\n  } else if (line.type === \"LineString\") {\n    line = feature(line);\n  } else {\n    featureOf(line, \"LineString\", \"line\");\n  }\n  var distance = Infinity;\n  var p = pt.geometry.coordinates;\n  segmentEach(line, function (segment) {\n    var a = segment.geometry.coordinates[0];\n    var b = segment.geometry.coordinates[1];\n    var d = distanceToSegment(p, a, b, options);\n    if (d < distance) {\n      distance = d;\n    }\n  });\n  return convertLength(distance, \"degrees\", options.units);\n}\n/**\n * Returns the distance between a point P on a segment AB.\n *\n * @private\n * @param {Array<number>} p external point\n * @param {Array<number>} a first segment point\n * @param {Array<number>} b second segment point\n * @param {Object} [options={}] Optional parameters\n * @returns {number} distance\n */\nfunction distanceToSegment(p, a, b, options) {\n  var v = [b[0] - a[0], b[1] - a[1]];\n  var w = [p[0] - a[0], p[1] - a[1]];\n  var c1 = dot(w, v);\n  if (c1 <= 0) {\n    return calcDistance(p, a, {\n      method: options.method,\n      units: \"degrees\"\n    });\n  }\n  var c2 = dot(v, v);\n  if (c2 <= c1) {\n    return calcDistance(p, b, {\n      method: options.method,\n      units: \"degrees\"\n    });\n  }\n  var b2 = c1 / c2;\n  var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n  return calcDistance(p, Pb, {\n    method: options.method,\n    units: \"degrees\"\n  });\n}\nfunction dot(u, v) {\n  return u[0] * v[0] + u[1] * v[1];\n}\nfunction calcDistance(a, b, options) {\n  return options.method === \"planar\" ? getPlanarDistance(a, b, options) : getDistance(a, b, options);\n}\nexport default pointToLineDistance;","map":{"version":3,"names":["getDistance","convertLength","feature","lineString","point","featureOf","segmentEach","getPlanarDistance","pointToLineDistance","pt","line","options","method","units","Error","Array","isArray","type","distance","Infinity","p","geometry","coordinates","segment","a","b","d","distanceToSegment","v","w","c1","dot","calcDistance","c2","b2","Pb","u"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/point-to-line-distance/dist/es/index.js"],"sourcesContent":["// Taken from http://geomalgorithms.com/a02-_lines.html\nimport getDistance from \"@turf/distance\";\nimport { convertLength, feature, lineString, point, } from \"@turf/helpers\";\nimport { featureOf } from \"@turf/invariant\";\nimport { segmentEach } from \"@turf/meta\";\nimport getPlanarDistance from \"@turf/rhumb-distance\";\n/**\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\n * minimum distance between the point and any segment of the `LineString`.\n *\n * @name pointToLineDistance\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\n * (ex: degrees, radians, miles, or kilometers)\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\n * @returns {number} distance between point and line\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[1, 1],[-1, 1]]);\n *\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\n * //=69.11854715938406\n */\nfunction pointToLineDistance(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    if (!options.method) {\n        options.method = \"geodesic\";\n    }\n    if (!options.units) {\n        options.units = \"kilometers\";\n    }\n    // validation\n    if (!pt) {\n        throw new Error(\"pt is required\");\n    }\n    if (Array.isArray(pt)) {\n        pt = point(pt);\n    }\n    else if (pt.type === \"Point\") {\n        pt = feature(pt);\n    }\n    else {\n        featureOf(pt, \"Point\", \"point\");\n    }\n    if (!line) {\n        throw new Error(\"line is required\");\n    }\n    if (Array.isArray(line)) {\n        line = lineString(line);\n    }\n    else if (line.type === \"LineString\") {\n        line = feature(line);\n    }\n    else {\n        featureOf(line, \"LineString\", \"line\");\n    }\n    var distance = Infinity;\n    var p = pt.geometry.coordinates;\n    segmentEach(line, function (segment) {\n        var a = segment.geometry.coordinates[0];\n        var b = segment.geometry.coordinates[1];\n        var d = distanceToSegment(p, a, b, options);\n        if (d < distance) {\n            distance = d;\n        }\n    });\n    return convertLength(distance, \"degrees\", options.units);\n}\n/**\n * Returns the distance between a point P on a segment AB.\n *\n * @private\n * @param {Array<number>} p external point\n * @param {Array<number>} a first segment point\n * @param {Array<number>} b second segment point\n * @param {Object} [options={}] Optional parameters\n * @returns {number} distance\n */\nfunction distanceToSegment(p, a, b, options) {\n    var v = [b[0] - a[0], b[1] - a[1]];\n    var w = [p[0] - a[0], p[1] - a[1]];\n    var c1 = dot(w, v);\n    if (c1 <= 0) {\n        return calcDistance(p, a, { method: options.method, units: \"degrees\" });\n    }\n    var c2 = dot(v, v);\n    if (c2 <= c1) {\n        return calcDistance(p, b, { method: options.method, units: \"degrees\" });\n    }\n    var b2 = c1 / c2;\n    var Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n    return calcDistance(p, Pb, { method: options.method, units: \"degrees\" });\n}\nfunction dot(u, v) {\n    return u[0] * v[0] + u[1] * v[1];\n}\nfunction calcDistance(a, b, options) {\n    return options.method === \"planar\"\n        ? getPlanarDistance(a, b, options)\n        : getDistance(a, b, options);\n}\nexport default pointToLineDistance;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}