{"ast":null,"code":"import circle from '@turf/circle';\nimport lineArc from '@turf/line-arc';\nimport { coordEach } from '@turf/meta';\nimport { isObject, polygon } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\n\n/**\n * Creates a circular sector of a circle of given radius and center {@link Point},\n * between (clockwise) bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.\n *\n * @name sector\n * @param {Coord} center center point\n * @param {number} radius radius of the circle\n * @param {number} bearing1 angle, in decimal degrees, of the first radius of the sector\n * @param {number} bearing2 angle, in decimal degrees, of the second radius of the sector\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {number} [options.steps=64] number of steps\n * @param {Properties} [options.properties={}] Translate properties to Feature Polygon\n * @returns {Feature<Polygon>} sector polygon\n * @example\n * var center = turf.point([-75, 40]);\n * var radius = 5;\n * var bearing1 = 25;\n * var bearing2 = 45;\n *\n * var sector = turf.sector(center, radius, bearing1, bearing2);\n *\n * //addToMap\n * var addToMap = [center, sector];\n */\nfunction sector(center, radius, bearing1, bearing2, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var properties = options.properties;\n\n  // validation\n  if (!center) throw new Error(\"center is required\");\n  if (bearing1 === undefined || bearing1 === null) throw new Error(\"bearing1 is required\");\n  if (bearing2 === undefined || bearing2 === null) throw new Error(\"bearing2 is required\");\n  if (!radius) throw new Error(\"radius is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {\n    return circle(center, radius, options);\n  }\n  var coords = getCoords(center);\n  var arc = lineArc(center, radius, bearing1, bearing2, options);\n  var sliceCoords = [[coords]];\n  coordEach(arc, function (currentCoords) {\n    sliceCoords[0].push(currentCoords);\n  });\n  sliceCoords[0].push(coords);\n  return polygon(sliceCoords, properties);\n}\n\n/**\n * Takes any angle in degrees\n * and returns a valid angle between 0-360 degrees\n *\n * @private\n * @param {number} alfa angle between -180-180 degrees\n * @returns {number} angle between 0-360 degrees\n */\nfunction convertAngleTo360(alfa) {\n  var beta = alfa % 360;\n  if (beta < 0) beta += 360;\n  return beta;\n}\nexport default sector;","map":{"version":3,"names":["circle","lineArc","coordEach","isObject","polygon","getCoords","sector","center","radius","bearing1","bearing2","options","Error","properties","undefined","convertAngleTo360","coords","arc","sliceCoords","currentCoords","push","alfa","beta"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/sector/dist/es/index.js"],"sourcesContent":["import circle from '@turf/circle';\nimport lineArc from '@turf/line-arc';\nimport { coordEach } from '@turf/meta';\nimport { isObject, polygon } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\n\n/**\n * Creates a circular sector of a circle of given radius and center {@link Point},\n * between (clockwise) bearing1 and bearing2; 0 bearing is North of center point, positive clockwise.\n *\n * @name sector\n * @param {Coord} center center point\n * @param {number} radius radius of the circle\n * @param {number} bearing1 angle, in decimal degrees, of the first radius of the sector\n * @param {number} bearing2 angle, in decimal degrees, of the second radius of the sector\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {number} [options.steps=64] number of steps\n * @param {Properties} [options.properties={}] Translate properties to Feature Polygon\n * @returns {Feature<Polygon>} sector polygon\n * @example\n * var center = turf.point([-75, 40]);\n * var radius = 5;\n * var bearing1 = 25;\n * var bearing2 = 45;\n *\n * var sector = turf.sector(center, radius, bearing1, bearing2);\n *\n * //addToMap\n * var addToMap = [center, sector];\n */\nfunction sector(center, radius, bearing1, bearing2, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var properties = options.properties;\n\n  // validation\n  if (!center) throw new Error(\"center is required\");\n  if (bearing1 === undefined || bearing1 === null)\n    throw new Error(\"bearing1 is required\");\n  if (bearing2 === undefined || bearing2 === null)\n    throw new Error(\"bearing2 is required\");\n  if (!radius) throw new Error(\"radius is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n\n  if (convertAngleTo360(bearing1) === convertAngleTo360(bearing2)) {\n    return circle(center, radius, options);\n  }\n  var coords = getCoords(center);\n  var arc = lineArc(center, radius, bearing1, bearing2, options);\n  var sliceCoords = [[coords]];\n  coordEach(arc, function (currentCoords) {\n    sliceCoords[0].push(currentCoords);\n  });\n  sliceCoords[0].push(coords);\n\n  return polygon(sliceCoords, properties);\n}\n\n/**\n * Takes any angle in degrees\n * and returns a valid angle between 0-360 degrees\n *\n * @private\n * @param {number} alfa angle between -180-180 degrees\n * @returns {number} angle between 0-360 degrees\n */\nfunction convertAngleTo360(alfa) {\n  var beta = alfa % 360;\n  if (beta < 0) beta += 360;\n  return beta;\n}\n\nexport default sector;\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,cAAc;AACjC,OAAOC,OAAO,MAAM,gBAAgB;AACpC,SAASC,SAAS,QAAQ,YAAY;AACtC,SAASC,QAAQ,EAAEC,OAAO,QAAQ,eAAe;AACjD,SAASC,SAAS,QAAQ,iBAAiB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EAC3D;EACAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAI,CAACR,QAAQ,CAACQ,OAAO,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EAC7D,IAAIC,UAAU,GAAGF,OAAO,CAACE,UAAU;;EAEnC;EACA,IAAI,CAACN,MAAM,EAAE,MAAM,IAAIK,KAAK,CAAC,oBAAoB,CAAC;EAClD,IAAIH,QAAQ,KAAKK,SAAS,IAAIL,QAAQ,KAAK,IAAI,EAC7C,MAAM,IAAIG,KAAK,CAAC,sBAAsB,CAAC;EACzC,IAAIF,QAAQ,KAAKI,SAAS,IAAIJ,QAAQ,KAAK,IAAI,EAC7C,MAAM,IAAIE,KAAK,CAAC,sBAAsB,CAAC;EACzC,IAAI,CAACJ,MAAM,EAAE,MAAM,IAAII,KAAK,CAAC,oBAAoB,CAAC;EAClD,IAAI,OAAOD,OAAO,KAAK,QAAQ,EAAE,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;EAE7E,IAAIG,iBAAiB,CAACN,QAAQ,CAAC,KAAKM,iBAAiB,CAACL,QAAQ,CAAC,EAAE;IAC/D,OAAOV,MAAM,CAACO,MAAM,EAAEC,MAAM,EAAEG,OAAO,CAAC;EACxC;EACA,IAAIK,MAAM,GAAGX,SAAS,CAACE,MAAM,CAAC;EAC9B,IAAIU,GAAG,GAAGhB,OAAO,CAACM,MAAM,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,OAAO,CAAC;EAC9D,IAAIO,WAAW,GAAG,CAAC,CAACF,MAAM,CAAC,CAAC;EAC5Bd,SAAS,CAACe,GAAG,EAAE,UAAUE,aAAa,EAAE;IACtCD,WAAW,CAAC,CAAC,CAAC,CAACE,IAAI,CAACD,aAAa,CAAC;EACpC,CAAC,CAAC;EACFD,WAAW,CAAC,CAAC,CAAC,CAACE,IAAI,CAACJ,MAAM,CAAC;EAE3B,OAAOZ,OAAO,CAACc,WAAW,EAAEL,UAAU,CAAC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,iBAAiBA,CAACM,IAAI,EAAE;EAC/B,IAAIC,IAAI,GAAGD,IAAI,GAAG,GAAG;EACrB,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,IAAI,GAAG;EACzB,OAAOA,IAAI;AACb;AAEA,eAAehB,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}