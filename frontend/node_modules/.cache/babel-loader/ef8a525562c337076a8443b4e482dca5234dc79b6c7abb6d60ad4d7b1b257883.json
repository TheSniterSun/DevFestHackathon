{"ast":null,"code":"import { lineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nimport Spline from \"./lib/spline.js\";\n/**\n * Takes a {@link LineString|line} and returns a curved version\n * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)\n * algorithm.\n *\n * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).\n *\n * @name bezierSpline\n * @param {Feature<LineString>} line input LineString\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] Translate properties to output\n * @param {number} [options.resolution=10000] time in milliseconds between points\n * @param {number} [options.sharpness=0.85] a measure of how curvy the path should be between splines\n * @returns {Feature<LineString>} curved line\n * @example\n * var line = turf.lineString([\n *   [-76.091308, 18.427501],\n *   [-76.695556, 18.729501],\n *   [-76.552734, 19.40443],\n *   [-74.61914, 19.134789],\n *   [-73.652343, 20.07657],\n *   [-73.157958, 20.210656]\n * ]);\n *\n * var curved = turf.bezierSpline(line);\n *\n * //addToMap\n * var addToMap = [line, curved]\n * curved.properties = { stroke: '#0F0' };\n */\nfunction bezier(line, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Optional params\n  var resolution = options.resolution || 10000;\n  var sharpness = options.sharpness || 0.85;\n  var coords = [];\n  var points = getGeom(line).coordinates.map(function (pt) {\n    return {\n      x: pt[0],\n      y: pt[1]\n    };\n  });\n  var spline = new Spline({\n    duration: resolution,\n    points: points,\n    sharpness: sharpness\n  });\n  var pushCoord = function (time) {\n    var pos = spline.pos(time);\n    if (Math.floor(time / 100) % 2 === 0) {\n      coords.push([pos.x, pos.y]);\n    }\n  };\n  for (var i = 0; i < spline.duration; i += 10) {\n    pushCoord(i);\n  }\n  pushCoord(spline.duration);\n  return lineString(coords, options.properties);\n}\nexport default bezier;","map":{"version":3,"names":["lineString","getGeom","Spline","bezier","line","options","resolution","sharpness","coords","points","coordinates","map","pt","x","y","spline","duration","pushCoord","time","pos","Math","floor","push","i","properties"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/bezier-spline/dist/es/index.js"],"sourcesContent":["import { lineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nimport Spline from \"./lib/spline.js\";\n/**\n * Takes a {@link LineString|line} and returns a curved version\n * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)\n * algorithm.\n *\n * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).\n *\n * @name bezierSpline\n * @param {Feature<LineString>} line input LineString\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] Translate properties to output\n * @param {number} [options.resolution=10000] time in milliseconds between points\n * @param {number} [options.sharpness=0.85] a measure of how curvy the path should be between splines\n * @returns {Feature<LineString>} curved line\n * @example\n * var line = turf.lineString([\n *   [-76.091308, 18.427501],\n *   [-76.695556, 18.729501],\n *   [-76.552734, 19.40443],\n *   [-74.61914, 19.134789],\n *   [-73.652343, 20.07657],\n *   [-73.157958, 20.210656]\n * ]);\n *\n * var curved = turf.bezierSpline(line);\n *\n * //addToMap\n * var addToMap = [line, curved]\n * curved.properties = { stroke: '#0F0' };\n */\nfunction bezier(line, options) {\n    if (options === void 0) { options = {}; }\n    // Optional params\n    var resolution = options.resolution || 10000;\n    var sharpness = options.sharpness || 0.85;\n    var coords = [];\n    var points = getGeom(line).coordinates.map(function (pt) {\n        return { x: pt[0], y: pt[1] };\n    });\n    var spline = new Spline({\n        duration: resolution,\n        points: points,\n        sharpness: sharpness,\n    });\n    var pushCoord = function (time) {\n        var pos = spline.pos(time);\n        if (Math.floor(time / 100) % 2 === 0) {\n            coords.push([pos.x, pos.y]);\n        }\n    };\n    for (var i = 0; i < spline.duration; i += 10) {\n        pushCoord(i);\n    }\n    pushCoord(spline.duration);\n    return lineString(coords, options.properties);\n}\nexport default bezier;\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,eAAe;AAC1C,SAASC,OAAO,QAAQ,iBAAiB;AACzC,OAAOC,MAAM,MAAM,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,IAAI,EAAEC,OAAO,EAAE;EAC3B,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC;EACA,IAAIC,UAAU,GAAGD,OAAO,CAACC,UAAU,IAAI,KAAK;EAC5C,IAAIC,SAAS,GAAGF,OAAO,CAACE,SAAS,IAAI,IAAI;EACzC,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,MAAM,GAAGR,OAAO,CAACG,IAAI,CAAC,CAACM,WAAW,CAACC,GAAG,CAAC,UAAUC,EAAE,EAAE;IACrD,OAAO;MAAEC,CAAC,EAAED,EAAE,CAAC,CAAC,CAAC;MAAEE,CAAC,EAAEF,EAAE,CAAC,CAAC;IAAE,CAAC;EACjC,CAAC,CAAC;EACF,IAAIG,MAAM,GAAG,IAAIb,MAAM,CAAC;IACpBc,QAAQ,EAAEV,UAAU;IACpBG,MAAM,EAAEA,MAAM;IACdF,SAAS,EAAEA;EACf,CAAC,CAAC;EACF,IAAIU,SAAS,GAAG,SAAAA,CAAUC,IAAI,EAAE;IAC5B,IAAIC,GAAG,GAAGJ,MAAM,CAACI,GAAG,CAACD,IAAI,CAAC;IAC1B,IAAIE,IAAI,CAACC,KAAK,CAACH,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;MAClCV,MAAM,CAACc,IAAI,CAAC,CAACH,GAAG,CAACN,CAAC,EAAEM,GAAG,CAACL,CAAC,CAAC,CAAC;IAC/B;EACJ,CAAC;EACD,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,MAAM,CAACC,QAAQ,EAAEO,CAAC,IAAI,EAAE,EAAE;IAC1CN,SAAS,CAACM,CAAC,CAAC;EAChB;EACAN,SAAS,CAACF,MAAM,CAACC,QAAQ,CAAC;EAC1B,OAAOhB,UAAU,CAACQ,MAAM,EAAEH,OAAO,CAACmB,UAAU,CAAC;AACjD;AACA,eAAerB,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}