{"ast":null,"code":"import bearing from \"@turf/bearing\";\nimport distance from \"@turf/distance\";\nimport destination from \"@turf/destination\";\nimport lineIntersects from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var closestPt = point([Infinity, Infinity], {\n    dist: Infinity\n  });\n  var length = 0.0;\n  flattenEach(lines, function (line) {\n    var coords = getCoords(line);\n    for (var i = 0; i < coords.length - 1; i++) {\n      //start\n      var start = point(coords[i]);\n      start.properties.dist = distance(pt, start, options);\n      //stop\n      var stop_1 = point(coords[i + 1]);\n      stop_1.properties.dist = distance(pt, stop_1, options);\n      // sectionLength\n      var sectionLength = distance(start, stop_1, options);\n      //perpendicular\n      var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n      var direction = bearing(start, stop_1);\n      var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n      var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n      var intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n      var intersectPt = null;\n      if (intersect.features.length > 0) {\n        intersectPt = intersect.features[0];\n        intersectPt.properties.dist = distance(pt, intersectPt, options);\n        intersectPt.properties.location = length + distance(start, intersectPt, options);\n      }\n      if (start.properties.dist < closestPt.properties.dist) {\n        closestPt = start;\n        closestPt.properties.index = i;\n        closestPt.properties.location = length;\n      }\n      if (stop_1.properties.dist < closestPt.properties.dist) {\n        closestPt = stop_1;\n        closestPt.properties.index = i + 1;\n        closestPt.properties.location = length + sectionLength;\n      }\n      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n        closestPt = intersectPt;\n        closestPt.properties.index = i;\n      }\n      // update length\n      length += sectionLength;\n    }\n  });\n  return closestPt;\n}\nexport default nearestPointOnLine;","map":{"version":3,"names":["bearing","distance","destination","lineIntersects","flattenEach","point","lineString","getCoords","nearestPointOnLine","lines","pt","options","closestPt","Infinity","dist","length","line","coords","i","start","properties","stop_1","sectionLength","heightDistance","Math","max","direction","perpendicularPt1","perpendicularPt2","intersect","geometry","coordinates","intersectPt","features","location","index"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/nearest-point-on-line/dist/es/index.js"],"sourcesContent":["import bearing from \"@turf/bearing\";\nimport distance from \"@turf/distance\";\nimport destination from \"@turf/destination\";\nimport lineIntersects from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    if (options === void 0) { options = {}; }\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity,\n    });\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, options);\n            //stop\n            var stop_1 = point(coords[i + 1]);\n            stop_1.properties.dist = distance(pt, stop_1, options);\n            // sectionLength\n            var sectionLength = distance(start, stop_1, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n            var direction = bearing(start, stop_1);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n            var intersect = lineIntersects(lineString([\n                perpendicularPt1.geometry.coordinates,\n                perpendicularPt2.geometry.coordinates,\n            ]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, options);\n                intersectPt.properties.location =\n                    length + distance(start, intersectPt, options);\n            }\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop_1.properties.dist < closestPt.properties.dist) {\n                closestPt = stop_1;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt &&\n                intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n    });\n    return closestPt;\n}\nexport default nearestPointOnLine;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}