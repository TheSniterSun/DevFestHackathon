{"ast":null,"code":"import { getCoords, getType } from '@turf/invariant';\nimport { featureCollection, point } from '@turf/helpers';\nimport calcBbox from '@turf/bbox';\nimport explode from '@turf/explode';\nimport nearestPoint from '@turf/nearest-point';\n\n/**\n * Finds the tangents of a {@link Polygon|(Multi)Polygon} from a {@link Point}.\n *\n * @name polygonTangents\n * @param {Coord} pt to calculate the tangent points from\n * @param {Feature<Polygon|MultiPolygon>} polygon to get tangents from\n * @returns {FeatureCollection<Point>} Feature Collection containing the two tangent points\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n * var point = turf.point([61, 5]);\n *\n * var tangents = turf.polygonTangents(point, polygon)\n *\n * //addToMap\n * var addToMap = [tangents, point, polygon];\n */\nfunction polygonTangents(pt, polygon) {\n  var pointCoords = getCoords(pt);\n  var polyCoords = getCoords(polygon);\n  var rtan;\n  var ltan;\n  var enext;\n  var eprev;\n  var bbox = calcBbox(polygon);\n  var nearestPtIndex = 0;\n  var nearest = null;\n\n  // If the point lies inside the polygon bbox then we need to be a bit trickier\n  // otherwise points lying inside reflex angles on concave polys can have issues\n  if (pointCoords[0] > bbox[0] && pointCoords[0] < bbox[2] && pointCoords[1] > bbox[1] && pointCoords[1] < bbox[3]) {\n    nearest = nearestPoint(pt, explode(polygon));\n    nearestPtIndex = nearest.properties.featureIndex;\n  }\n  var type = getType(polygon);\n  switch (type) {\n    case \"Polygon\":\n      rtan = polyCoords[0][nearestPtIndex];\n      ltan = polyCoords[0][0];\n      if (nearest !== null) {\n        if (nearest.geometry.coordinates[1] < pointCoords[1]) ltan = polyCoords[0][nearestPtIndex];\n      }\n      eprev = isLeft(polyCoords[0][0], polyCoords[0][polyCoords[0].length - 1], pointCoords);\n      var out = processPolygon(polyCoords[0], pointCoords, eprev, enext, rtan, ltan);\n      rtan = out[0];\n      ltan = out[1];\n      break;\n    case \"MultiPolygon\":\n      var closestFeature = 0;\n      var closestVertex = 0;\n      var verticesCounted = 0;\n      for (var i = 0; i < polyCoords[0].length; i++) {\n        closestFeature = i;\n        var verticeFound = false;\n        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {\n          closestVertex = i2;\n          if (verticesCounted === nearestPtIndex) {\n            verticeFound = true;\n            break;\n          }\n          verticesCounted++;\n        }\n        if (verticeFound) break;\n      }\n      rtan = polyCoords[0][closestFeature][closestVertex];\n      ltan = polyCoords[0][closestFeature][closestVertex];\n      eprev = isLeft(polyCoords[0][0][0], polyCoords[0][0][polyCoords[0][0].length - 1], pointCoords);\n      polyCoords.forEach(function (ring) {\n        var out = processPolygon(ring[0], pointCoords, eprev, enext, rtan, ltan);\n        rtan = out[0];\n        ltan = out[1];\n      });\n      break;\n  }\n  return featureCollection([point(rtan), point(ltan)]);\n}\nfunction processPolygon(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {\n  for (var i = 0; i < polygonCoords.length; i++) {\n    var currentCoords = polygonCoords[i];\n    var nextCoordPair = polygonCoords[i + 1];\n    if (i === polygonCoords.length - 1) {\n      nextCoordPair = polygonCoords[0];\n    }\n    enext = isLeft(currentCoords, nextCoordPair, ptCoords);\n    if (eprev <= 0 && enext > 0) {\n      if (!isBelow(ptCoords, currentCoords, rtan)) {\n        rtan = currentCoords;\n      }\n    } else if (eprev > 0 && enext <= 0) {\n      if (!isAbove(ptCoords, currentCoords, ltan)) {\n        ltan = currentCoords;\n      }\n    }\n    eprev = enext;\n  }\n  return [rtan, ltan];\n}\nfunction isAbove(point1, point2, point3) {\n  return isLeft(point1, point2, point3) > 0;\n}\nfunction isBelow(point1, point2, point3) {\n  return isLeft(point1, point2, point3) < 0;\n}\nfunction isLeft(point1, point2, point3) {\n  return (point2[0] - point1[0]) * (point3[1] - point1[1]) - (point3[0] - point1[0]) * (point2[1] - point1[1]);\n}\nexport default polygonTangents;","map":{"version":3,"names":["getCoords","getType","featureCollection","point","calcBbox","explode","nearestPoint","polygonTangents","pt","polygon","pointCoords","polyCoords","rtan","ltan","enext","eprev","bbox","nearestPtIndex","nearest","properties","featureIndex","type","geometry","coordinates","isLeft","length","out","processPolygon","closestFeature","closestVertex","verticesCounted","i","verticeFound","i2","forEach","ring","polygonCoords","ptCoords","currentCoords","nextCoordPair","isBelow","isAbove","point1","point2","point3"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/polygon-tangents/dist/es/index.js"],"sourcesContent":["import { getCoords, getType } from '@turf/invariant';\nimport { featureCollection, point } from '@turf/helpers';\nimport calcBbox from '@turf/bbox';\nimport explode from '@turf/explode';\nimport nearestPoint from '@turf/nearest-point';\n\n/**\n * Finds the tangents of a {@link Polygon|(Multi)Polygon} from a {@link Point}.\n *\n * @name polygonTangents\n * @param {Coord} pt to calculate the tangent points from\n * @param {Feature<Polygon|MultiPolygon>} polygon to get tangents from\n * @returns {FeatureCollection<Point>} Feature Collection containing the two tangent points\n * @example\n * var polygon = turf.polygon([[[11, 0], [22, 4], [31, 0], [31, 11], [21, 15], [11, 11], [11, 0]]]);\n * var point = turf.point([61, 5]);\n *\n * var tangents = turf.polygonTangents(point, polygon)\n *\n * //addToMap\n * var addToMap = [tangents, point, polygon];\n */\nfunction polygonTangents(pt, polygon) {\n  var pointCoords = getCoords(pt);\n  var polyCoords = getCoords(polygon);\n\n  var rtan;\n  var ltan;\n  var enext;\n  var eprev;\n  var bbox = calcBbox(polygon);\n  var nearestPtIndex = 0;\n  var nearest = null;\n\n  // If the point lies inside the polygon bbox then we need to be a bit trickier\n  // otherwise points lying inside reflex angles on concave polys can have issues\n  if (\n    pointCoords[0] > bbox[0] &&\n    pointCoords[0] < bbox[2] &&\n    pointCoords[1] > bbox[1] &&\n    pointCoords[1] < bbox[3]\n  ) {\n    nearest = nearestPoint(pt, explode(polygon));\n    nearestPtIndex = nearest.properties.featureIndex;\n  }\n  var type = getType(polygon);\n  switch (type) {\n    case \"Polygon\":\n      rtan = polyCoords[0][nearestPtIndex];\n      ltan = polyCoords[0][0];\n      if (nearest !== null) {\n        if (nearest.geometry.coordinates[1] < pointCoords[1])\n          ltan = polyCoords[0][nearestPtIndex];\n      }\n      eprev = isLeft(\n        polyCoords[0][0],\n        polyCoords[0][polyCoords[0].length - 1],\n        pointCoords\n      );\n      var out = processPolygon(\n        polyCoords[0],\n        pointCoords,\n        eprev,\n        enext,\n        rtan,\n        ltan);\n      rtan = out[0];\n      ltan = out[1];\n      break;\n    case \"MultiPolygon\":\n      var closestFeature = 0;\n      var closestVertex = 0;\n      var verticesCounted = 0;\n      for (var i = 0; i < polyCoords[0].length; i++) {\n        closestFeature = i;\n        var verticeFound = false;\n        for (var i2 = 0; i2 < polyCoords[0][i].length; i2++) {\n          closestVertex = i2;\n          if (verticesCounted === nearestPtIndex) {\n            verticeFound = true;\n            break;\n          }\n          verticesCounted++;\n        }\n        if (verticeFound) break;\n      }\n      rtan = polyCoords[0][closestFeature][closestVertex];\n      ltan = polyCoords[0][closestFeature][closestVertex];\n      eprev = isLeft(\n        polyCoords[0][0][0],\n        polyCoords[0][0][polyCoords[0][0].length - 1],\n        pointCoords\n      );\n      polyCoords.forEach(function (ring) {\n        var out = processPolygon(\n          ring[0],\n          pointCoords,\n          eprev,\n          enext,\n          rtan,\n          ltan);\n        rtan = out[0];\n        ltan = out[1];\n      });\n      break;\n  }\n  return featureCollection([point(rtan), point(ltan)]);\n}\n\nfunction processPolygon(polygonCoords, ptCoords, eprev, enext, rtan, ltan) {\n  for (var i = 0; i < polygonCoords.length; i++) {\n    var currentCoords = polygonCoords[i];\n    var nextCoordPair = polygonCoords[i + 1];\n    if (i === polygonCoords.length - 1) {\n      nextCoordPair = polygonCoords[0];\n    }\n    enext = isLeft(currentCoords, nextCoordPair, ptCoords);\n    if (eprev <= 0 && enext > 0) {\n      if (!isBelow(ptCoords, currentCoords, rtan)) {\n        rtan = currentCoords;\n      }\n    } else if (eprev > 0 && enext <= 0) {\n      if (!isAbove(ptCoords, currentCoords, ltan)) {\n        ltan = currentCoords;\n      }\n    }\n    eprev = enext;\n  }\n  return [rtan, ltan];\n}\n\nfunction isAbove(point1, point2, point3) {\n  return isLeft(point1, point2, point3) > 0;\n}\n\nfunction isBelow(point1, point2, point3) {\n  return isLeft(point1, point2, point3) < 0;\n}\n\nfunction isLeft(point1, point2, point3) {\n  return (\n    (point2[0] - point1[0]) * (point3[1] - point1[1]) -\n    (point3[0] - point1[0]) * (point2[1] - point1[1])\n  );\n}\n\nexport default polygonTangents;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}