{"ast":null,"code":"/**\r\n * KMEANS clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\n\n/**\r\n * KMEANS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} k - number of clusters\r\n * @param {function} distance - distance function\r\n * @returns {KMEANS}\r\n */\nfunction KMEANS(dataset, k, distance) {\n  this.k = 3; // number of clusters\n  this.dataset = []; // set of feature vectors\n  this.assignments = []; // set of associated clusters for each feature vector\n  this.centroids = []; // vectors for our clusters\n\n  this.init(dataset, k, distance);\n}\n\n/**\r\n * @returns {undefined}\r\n */\nKMEANS.prototype.init = function (dataset, k, distance) {\n  this.assignments = [];\n  this.centroids = [];\n  if (typeof dataset !== 'undefined') {\n    this.dataset = dataset;\n  }\n  if (typeof k !== 'undefined') {\n    this.k = k;\n  }\n  if (typeof distance !== 'undefined') {\n    this.distance = distance;\n  }\n};\n\n/**\r\n * @returns {undefined}\r\n */\nKMEANS.prototype.run = function (dataset, k) {\n  this.init(dataset, k);\n  var len = this.dataset.length;\n\n  // initialize centroids\n  for (var i = 0; i < this.k; i++) {\n    this.centroids[i] = this.randomCentroid();\n  }\n  var change = true;\n  while (change) {\n    // assign feature vectors to clusters\n    change = this.assign();\n\n    // adjust location of centroids\n    for (var centroidId = 0; centroidId < this.k; centroidId++) {\n      var mean = new Array(maxDim);\n      var count = 0;\n\n      // init mean vector\n      for (var dim = 0; dim < maxDim; dim++) {\n        mean[dim] = 0;\n      }\n      for (var j = 0; j < len; j++) {\n        var maxDim = this.dataset[j].length;\n\n        // if current cluster id is assigned to point\n        if (centroidId === this.assignments[j]) {\n          for (var dim = 0; dim < maxDim; dim++) {\n            mean[dim] += this.dataset[j][dim];\n          }\n          count++;\n        }\n      }\n      if (count > 0) {\n        // if cluster contain points, adjust centroid position\n        for (var dim = 0; dim < maxDim; dim++) {\n          mean[dim] /= count;\n        }\n        this.centroids[centroidId] = mean;\n      } else {\n        // if cluster is empty, generate new random centroid\n        this.centroids[centroidId] = this.randomCentroid();\n        change = true;\n      }\n    }\n  }\n  return this.getClusters();\n};\n\n/**\r\n * Generate random centroid\r\n *\r\n * @returns {Array}\r\n */\nKMEANS.prototype.randomCentroid = function () {\n  var maxId = this.dataset.length - 1;\n  var centroid;\n  var id;\n  do {\n    id = Math.round(Math.random() * maxId);\n    centroid = this.dataset[id];\n  } while (this.centroids.indexOf(centroid) >= 0);\n  return centroid;\n};\n\n/**\r\n * Assign points to clusters\r\n *\r\n * @returns {boolean}\r\n */\nKMEANS.prototype.assign = function () {\n  var change = false;\n  var len = this.dataset.length;\n  var closestCentroid;\n  for (var i = 0; i < len; i++) {\n    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);\n    if (closestCentroid != this.assignments[i]) {\n      this.assignments[i] = closestCentroid;\n      change = true;\n    }\n  }\n  return change;\n};\n\n/**\r\n * Extract information about clusters\r\n *\r\n * @returns {undefined}\r\n */\nKMEANS.prototype.getClusters = function () {\n  var clusters = new Array(this.k);\n  var centroidId;\n  for (var pointId = 0; pointId < this.assignments.length; pointId++) {\n    centroidId = this.assignments[pointId];\n\n    // init empty cluster\n    if (typeof clusters[centroidId] === 'undefined') {\n      clusters[centroidId] = [];\n    }\n    clusters[centroidId].push(pointId);\n  }\n  return clusters;\n};\n\n// utils\n\n/**\r\n * @params {Array} point\r\n * @params {Array.<Array>} set\r\n * @params {Function} f\r\n * @returns {number}\r\n */\nKMEANS.prototype.argmin = function (point, set, f) {\n  var min = Number.MAX_VALUE;\n  var arg = 0;\n  var len = set.length;\n  var d;\n  for (var i = 0; i < len; i++) {\n    d = f(point, set[i]);\n    if (d < min) {\n      min = d;\n      arg = i;\n    }\n  }\n  return arg;\n};\n\n/**\r\n * Euclidean distance\r\n *\r\n * @params {number} p\r\n * @params {number} q\r\n * @returns {number}\r\n */\nKMEANS.prototype.distance = function (p, q) {\n  var sum = 0;\n  var i = Math.min(p.length, q.length);\n  while (i--) {\n    var diff = p[i] - q[i];\n    sum += diff * diff;\n  }\n  return Math.sqrt(sum);\n};\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = KMEANS;\n}","map":{"version":3,"names":["KMEANS","dataset","k","distance","assignments","centroids","init","prototype","run","len","length","i","randomCentroid","change","assign","centroidId","mean","Array","maxDim","count","dim","j","getClusters","maxId","centroid","id","Math","round","random","indexOf","closestCentroid","argmin","clusters","pointId","push","point","set","f","min","Number","MAX_VALUE","arg","d","p","q","sum","diff","sqrt","module","exports"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/density-clustering/lib/KMEANS.js"],"sourcesContent":["/**\r\n * KMEANS clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * KMEANS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} k - number of clusters\r\n * @param {function} distance - distance function\r\n * @returns {KMEANS}\r\n */\r\n function KMEANS(dataset, k, distance) {\r\n  this.k = 3; // number of clusters\r\n  this.dataset = []; // set of feature vectors\r\n  this.assignments = []; // set of associated clusters for each feature vector\r\n  this.centroids = []; // vectors for our clusters\r\n\r\n  this.init(dataset, k, distance);\r\n}\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.init = function(dataset, k, distance) {\r\n  this.assignments = [];\r\n  this.centroids = [];\r\n\r\n  if (typeof dataset !== 'undefined') {\r\n    this.dataset = dataset;\r\n  }\r\n\r\n  if (typeof k !== 'undefined') {\r\n    this.k = k;\r\n  }\r\n\r\n  if (typeof distance !== 'undefined') {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.run = function(dataset, k) {\r\n  this.init(dataset, k);\r\n\r\n  var len = this.dataset.length;\r\n\r\n  // initialize centroids\r\n  for (var i = 0; i < this.k; i++) {\r\n    this.centroids[i] = this.randomCentroid();\r\n\t}\r\n\r\n  var change = true;\r\n  while(change) {\r\n\r\n    // assign feature vectors to clusters\r\n    change = this.assign();\r\n\r\n    // adjust location of centroids\r\n    for (var centroidId = 0; centroidId < this.k; centroidId++) {\r\n      var mean = new Array(maxDim);\r\n      var count = 0;\r\n\r\n      // init mean vector\r\n      for (var dim = 0; dim < maxDim; dim++) {\r\n        mean[dim] = 0;\r\n      }\r\n\r\n      for (var j = 0; j < len; j++) {\r\n        var maxDim = this.dataset[j].length;\r\n\r\n        // if current cluster id is assigned to point\r\n        if (centroidId === this.assignments[j]) {\r\n          for (var dim = 0; dim < maxDim; dim++) {\r\n            mean[dim] += this.dataset[j][dim];\r\n          }\r\n          count++;\r\n        }\r\n      }\r\n\r\n      if (count > 0) {\r\n        // if cluster contain points, adjust centroid position\r\n        for (var dim = 0; dim < maxDim; dim++) {\r\n          mean[dim] /= count;\r\n        }\r\n        this.centroids[centroidId] = mean;\r\n      } else {\r\n        // if cluster is empty, generate new random centroid\r\n        this.centroids[centroidId] = this.randomCentroid();\r\n        change = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.getClusters();\r\n};\r\n\r\n/**\r\n * Generate random centroid\r\n *\r\n * @returns {Array}\r\n */\r\nKMEANS.prototype.randomCentroid = function() {\r\n  var maxId = this.dataset.length -1;\r\n  var centroid;\r\n  var id;\r\n\r\n  do {\r\n    id = Math.round(Math.random() * maxId);\r\n    centroid = this.dataset[id];\r\n  } while (this.centroids.indexOf(centroid) >= 0);\r\n\r\n  return centroid;\r\n}\r\n\r\n/**\r\n * Assign points to clusters\r\n *\r\n * @returns {boolean}\r\n */\r\nKMEANS.prototype.assign = function() {\r\n  var change = false;\r\n  var len = this.dataset.length;\r\n  var closestCentroid;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);\r\n\r\n    if (closestCentroid != this.assignments[i]) {\r\n      this.assignments[i] = closestCentroid;\r\n      change = true;\r\n    }\r\n  }\r\n\r\n  return change;\r\n}\r\n\r\n/**\r\n * Extract information about clusters\r\n *\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.getClusters = function() {\r\n  var clusters = new Array(this.k);\r\n  var centroidId;\r\n\r\n  for (var pointId = 0; pointId < this.assignments.length; pointId++) {\r\n    centroidId = this.assignments[pointId];\r\n\r\n    // init empty cluster\r\n    if (typeof clusters[centroidId] === 'undefined') {\r\n      clusters[centroidId] = [];\r\n    }\r\n\r\n    clusters[centroidId].push(pointId);\r\n  }\r\n\r\n  return clusters;\r\n};\r\n\r\n// utils\r\n\r\n/**\r\n * @params {Array} point\r\n * @params {Array.<Array>} set\r\n * @params {Function} f\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.argmin = function(point, set, f) {\r\n  var min = Number.MAX_VALUE;\r\n  var arg = 0;\r\n  var len = set.length;\r\n  var d;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    d = f(point, set[i]);\r\n    if (d < min) {\r\n      min = d;\r\n      arg = i;\r\n    }\r\n  }\r\n\r\n  return arg;\r\n};\r\n\r\n/**\r\n * Euclidean distance\r\n *\r\n * @params {number} p\r\n * @params {number} q\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.distance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    var diff = p[i] - q[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = KMEANS;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,SAASA,MAAMA,CAACC,OAAO,EAAEC,CAAC,EAAEC,QAAQ,EAAE;EACrC,IAAI,CAACD,CAAC,GAAG,CAAC,CAAC,CAAC;EACZ,IAAI,CAACD,OAAO,GAAG,EAAE,CAAC,CAAC;EACnB,IAAI,CAACG,WAAW,GAAG,EAAE,CAAC,CAAC;EACvB,IAAI,CAACC,SAAS,GAAG,EAAE,CAAC,CAAC;;EAErB,IAAI,CAACC,IAAI,CAACL,OAAO,EAAEC,CAAC,EAAEC,QAAQ,CAAC;AACjC;;AAEA;AACA;AACA;AACAH,MAAM,CAACO,SAAS,CAACD,IAAI,GAAG,UAASL,OAAO,EAAEC,CAAC,EAAEC,QAAQ,EAAE;EACrD,IAAI,CAACC,WAAW,GAAG,EAAE;EACrB,IAAI,CAACC,SAAS,GAAG,EAAE;EAEnB,IAAI,OAAOJ,OAAO,KAAK,WAAW,EAAE;IAClC,IAAI,CAACA,OAAO,GAAGA,OAAO;EACxB;EAEA,IAAI,OAAOC,CAAC,KAAK,WAAW,EAAE;IAC5B,IAAI,CAACA,CAAC,GAAGA,CAAC;EACZ;EAEA,IAAI,OAAOC,QAAQ,KAAK,WAAW,EAAE;IACnC,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC1B;AACF,CAAC;;AAED;AACA;AACA;AACAH,MAAM,CAACO,SAAS,CAACC,GAAG,GAAG,UAASP,OAAO,EAAEC,CAAC,EAAE;EAC1C,IAAI,CAACI,IAAI,CAACL,OAAO,EAAEC,CAAC,CAAC;EAErB,IAAIO,GAAG,GAAG,IAAI,CAACR,OAAO,CAACS,MAAM;;EAE7B;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACT,CAAC,EAAES,CAAC,EAAE,EAAE;IAC/B,IAAI,CAACN,SAAS,CAACM,CAAC,CAAC,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;EAC5C;EAEC,IAAIC,MAAM,GAAG,IAAI;EACjB,OAAMA,MAAM,EAAE;IAEZ;IACAA,MAAM,GAAG,IAAI,CAACC,MAAM,CAAC,CAAC;;IAEtB;IACA,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAG,IAAI,CAACb,CAAC,EAAEa,UAAU,EAAE,EAAE;MAC1D,IAAIC,IAAI,GAAG,IAAIC,KAAK,CAACC,MAAM,CAAC;MAC5B,IAAIC,KAAK,GAAG,CAAC;;MAEb;MACA,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGF,MAAM,EAAEE,GAAG,EAAE,EAAE;QACrCJ,IAAI,CAACI,GAAG,CAAC,GAAG,CAAC;MACf;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,GAAG,EAAEY,CAAC,EAAE,EAAE;QAC5B,IAAIH,MAAM,GAAG,IAAI,CAACjB,OAAO,CAACoB,CAAC,CAAC,CAACX,MAAM;;QAEnC;QACA,IAAIK,UAAU,KAAK,IAAI,CAACX,WAAW,CAACiB,CAAC,CAAC,EAAE;UACtC,KAAK,IAAID,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGF,MAAM,EAAEE,GAAG,EAAE,EAAE;YACrCJ,IAAI,CAACI,GAAG,CAAC,IAAI,IAAI,CAACnB,OAAO,CAACoB,CAAC,CAAC,CAACD,GAAG,CAAC;UACnC;UACAD,KAAK,EAAE;QACT;MACF;MAEA,IAAIA,KAAK,GAAG,CAAC,EAAE;QACb;QACA,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGF,MAAM,EAAEE,GAAG,EAAE,EAAE;UACrCJ,IAAI,CAACI,GAAG,CAAC,IAAID,KAAK;QACpB;QACA,IAAI,CAACd,SAAS,CAACU,UAAU,CAAC,GAAGC,IAAI;MACnC,CAAC,MAAM;QACL;QACA,IAAI,CAACX,SAAS,CAACU,UAAU,CAAC,GAAG,IAAI,CAACH,cAAc,CAAC,CAAC;QAClDC,MAAM,GAAG,IAAI;MACf;IACF;EACF;EAEA,OAAO,IAAI,CAACS,WAAW,CAAC,CAAC;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAtB,MAAM,CAACO,SAAS,CAACK,cAAc,GAAG,YAAW;EAC3C,IAAIW,KAAK,GAAG,IAAI,CAACtB,OAAO,CAACS,MAAM,GAAE,CAAC;EAClC,IAAIc,QAAQ;EACZ,IAAIC,EAAE;EAEN,GAAG;IACDA,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGL,KAAK,CAAC;IACtCC,QAAQ,GAAG,IAAI,CAACvB,OAAO,CAACwB,EAAE,CAAC;EAC7B,CAAC,QAAQ,IAAI,CAACpB,SAAS,CAACwB,OAAO,CAACL,QAAQ,CAAC,IAAI,CAAC;EAE9C,OAAOA,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAxB,MAAM,CAACO,SAAS,CAACO,MAAM,GAAG,YAAW;EACnC,IAAID,MAAM,GAAG,KAAK;EAClB,IAAIJ,GAAG,GAAG,IAAI,CAACR,OAAO,CAACS,MAAM;EAC7B,IAAIoB,eAAe;EAEnB,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;IAC5BmB,eAAe,GAAG,IAAI,CAACC,MAAM,CAAC,IAAI,CAAC9B,OAAO,CAACU,CAAC,CAAC,EAAE,IAAI,CAACN,SAAS,EAAE,IAAI,CAACF,QAAQ,CAAC;IAE7E,IAAI2B,eAAe,IAAI,IAAI,CAAC1B,WAAW,CAACO,CAAC,CAAC,EAAE;MAC1C,IAAI,CAACP,WAAW,CAACO,CAAC,CAAC,GAAGmB,eAAe;MACrCjB,MAAM,GAAG,IAAI;IACf;EACF;EAEA,OAAOA,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAb,MAAM,CAACO,SAAS,CAACe,WAAW,GAAG,YAAW;EACxC,IAAIU,QAAQ,GAAG,IAAIf,KAAK,CAAC,IAAI,CAACf,CAAC,CAAC;EAChC,IAAIa,UAAU;EAEd,KAAK,IAAIkB,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,IAAI,CAAC7B,WAAW,CAACM,MAAM,EAAEuB,OAAO,EAAE,EAAE;IAClElB,UAAU,GAAG,IAAI,CAACX,WAAW,CAAC6B,OAAO,CAAC;;IAEtC;IACA,IAAI,OAAOD,QAAQ,CAACjB,UAAU,CAAC,KAAK,WAAW,EAAE;MAC/CiB,QAAQ,CAACjB,UAAU,CAAC,GAAG,EAAE;IAC3B;IAEAiB,QAAQ,CAACjB,UAAU,CAAC,CAACmB,IAAI,CAACD,OAAO,CAAC;EACpC;EAEA,OAAOD,QAAQ;AACjB,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAhC,MAAM,CAACO,SAAS,CAACwB,MAAM,GAAG,UAASI,KAAK,EAAEC,GAAG,EAAEC,CAAC,EAAE;EAChD,IAAIC,GAAG,GAAGC,MAAM,CAACC,SAAS;EAC1B,IAAIC,GAAG,GAAG,CAAC;EACX,IAAIhC,GAAG,GAAG2B,GAAG,CAAC1B,MAAM;EACpB,IAAIgC,CAAC;EAEL,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;IAC5B+B,CAAC,GAAGL,CAAC,CAACF,KAAK,EAAEC,GAAG,CAACzB,CAAC,CAAC,CAAC;IACpB,IAAI+B,CAAC,GAAGJ,GAAG,EAAE;MACXA,GAAG,GAAGI,CAAC;MACPD,GAAG,GAAG9B,CAAC;IACT;EACF;EAEA,OAAO8B,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAzC,MAAM,CAACO,SAAS,CAACJ,QAAQ,GAAG,UAASwC,CAAC,EAAEC,CAAC,EAAE;EACzC,IAAIC,GAAG,GAAG,CAAC;EACX,IAAIlC,CAAC,GAAGe,IAAI,CAACY,GAAG,CAACK,CAAC,CAACjC,MAAM,EAAEkC,CAAC,CAAClC,MAAM,CAAC;EAEpC,OAAOC,CAAC,EAAE,EAAE;IACV,IAAImC,IAAI,GAAGH,CAAC,CAAChC,CAAC,CAAC,GAAGiC,CAAC,CAACjC,CAAC,CAAC;IACtBkC,GAAG,IAAIC,IAAI,GAAGA,IAAI;EACpB;EAEA,OAAOpB,IAAI,CAACqB,IAAI,CAACF,GAAG,CAAC;AACvB,CAAC;AAED,IAAI,OAAOG,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,OAAO,EAAE;EACnDD,MAAM,CAACC,OAAO,GAAGjD,MAAM;AACzB"},"metadata":{},"sourceType":"script","externalDependencies":[]}