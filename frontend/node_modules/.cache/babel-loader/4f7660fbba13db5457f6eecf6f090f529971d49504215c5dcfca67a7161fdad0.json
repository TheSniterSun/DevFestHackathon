{"ast":null,"code":"import distance from '@turf/distance';\n\n/**\n * Takes a bounding box and calculates the minimum square bounding box that\n * would contain the input.\n *\n * @name square\n * @param {BBox} bbox extent in [west, south, east, north] order\n * @returns {BBox} a square surrounding `bbox`\n * @example\n * var bbox = [-20, -20, -15, 0];\n * var squared = turf.square(bbox);\n *\n * //addToMap\n * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]\n */\nfunction square(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n  var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n  if (horizontalDistance >= verticalDistance) {\n    var verticalMidpoint = (south + north) / 2;\n    return [west, verticalMidpoint - (east - west) / 2, east, verticalMidpoint + (east - west) / 2];\n  } else {\n    var horizontalMidpoint = (west + east) / 2;\n    return [horizontalMidpoint - (north - south) / 2, south, horizontalMidpoint + (north - south) / 2, north];\n  }\n}\nexport default square;","map":{"version":3,"names":["distance","square","bbox","west","south","east","north","horizontalDistance","slice","verticalDistance","verticalMidpoint","horizontalMidpoint"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/square/dist/es/index.js"],"sourcesContent":["import distance from '@turf/distance';\n\n/**\n * Takes a bounding box and calculates the minimum square bounding box that\n * would contain the input.\n *\n * @name square\n * @param {BBox} bbox extent in [west, south, east, north] order\n * @returns {BBox} a square surrounding `bbox`\n * @example\n * var bbox = [-20, -20, -15, 0];\n * var squared = turf.square(bbox);\n *\n * //addToMap\n * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]\n */\nfunction square(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n  var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n  if (horizontalDistance >= verticalDistance) {\n    var verticalMidpoint = (south + north) / 2;\n    return [\n      west,\n      verticalMidpoint - (east - west) / 2,\n      east,\n      verticalMidpoint + (east - west) / 2,\n    ];\n  } else {\n    var horizontalMidpoint = (west + east) / 2;\n    return [\n      horizontalMidpoint - (north - south) / 2,\n      south,\n      horizontalMidpoint + (north - south) / 2,\n      north,\n    ];\n  }\n}\n\nexport default square;\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,gBAAgB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,IAAI,EAAE;EACpB,IAAIC,IAAI,GAAGD,IAAI,CAAC,CAAC,CAAC;EAClB,IAAIE,KAAK,GAAGF,IAAI,CAAC,CAAC,CAAC;EACnB,IAAIG,IAAI,GAAGH,IAAI,CAAC,CAAC,CAAC;EAClB,IAAII,KAAK,GAAGJ,IAAI,CAAC,CAAC,CAAC;EAEnB,IAAIK,kBAAkB,GAAGP,QAAQ,CAACE,IAAI,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAACH,IAAI,EAAED,KAAK,CAAC,CAAC;EAClE,IAAIK,gBAAgB,GAAGT,QAAQ,CAACE,IAAI,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAACL,IAAI,EAAEG,KAAK,CAAC,CAAC;EAChE,IAAIC,kBAAkB,IAAIE,gBAAgB,EAAE;IAC1C,IAAIC,gBAAgB,GAAG,CAACN,KAAK,GAAGE,KAAK,IAAI,CAAC;IAC1C,OAAO,CACLH,IAAI,EACJO,gBAAgB,GAAG,CAACL,IAAI,GAAGF,IAAI,IAAI,CAAC,EACpCE,IAAI,EACJK,gBAAgB,GAAG,CAACL,IAAI,GAAGF,IAAI,IAAI,CAAC,CACrC;EACH,CAAC,MAAM;IACL,IAAIQ,kBAAkB,GAAG,CAACR,IAAI,GAAGE,IAAI,IAAI,CAAC;IAC1C,OAAO,CACLM,kBAAkB,GAAG,CAACL,KAAK,GAAGF,KAAK,IAAI,CAAC,EACxCA,KAAK,EACLO,kBAAkB,GAAG,CAACL,KAAK,GAAGF,KAAK,IAAI,CAAC,EACxCE,KAAK,CACN;EACH;AACF;AAEA,eAAeL,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}