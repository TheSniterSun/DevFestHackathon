{"ast":null,"code":"import centerMean from \"@turf/center-mean\";\nimport distance from \"@turf/distance\";\nimport centroid from \"@turf/centroid\";\nimport { isNumber, point, isObject, featureCollection } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * Takes a {@link FeatureCollection} of points and calculates the median center,\n * algorithimically. The median center is understood as the point that is\n * requires the least total travel from all other points.\n *\n * Turfjs has four different functions for calculating the center of a set of\n * data. Each is useful depending on circumstance.\n *\n * `@turf/center` finds the simple center of a dataset, by finding the\n * midpoint between the extents of the data. That is, it divides in half the\n * farthest east and farthest west point as well as the farthest north and\n * farthest south.\n *\n * `@turf/center-of-mass` imagines that the dataset is a sheet of paper.\n * The center of mass is where the sheet would balance on a fingertip.\n *\n * `@turf/center-mean` takes the averages of all the coordinates and\n * produces a value that respects that. Unlike `@turf/center`, it is\n * sensitive to clusters and outliers. It lands in the statistical middle of a\n * dataset, not the geographical. It can also be weighted, meaning certain\n * points are more important than others.\n *\n * `@turf/center-median` takes the mean center and tries to find, iteratively,\n * a new point that requires the least amount of travel from all the points in\n * the dataset. It is not as sensitive to outliers as `@turf/center-mean`, but it is\n * attracted to clustered data. It, too, can be weighted.\n *\n * **Bibliography**\n *\n * Harold W. Kuhn and Robert E. Kuenne, “An Efficient Algorithm for the\n * Numerical Solution of the Generalized Weber Problem in Spatial\n * Economics,” _Journal of Regional Science_ 4, no. 2 (1962): 21–33,\n * doi:{@link https://doi.org/10.1111/j.1467-9787.1962.tb00902.x}.\n *\n * James E. Burt, Gerald M. Barber, and David L. Rigby, _Elementary\n * Statistics for Geographers_, 3rd ed., New York: The Guilford\n * Press, 2009, 150–151.\n *\n * @name centerMedian\n * @param {FeatureCollection<any>} features Any GeoJSON Feature Collection\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.weight] the property name used to weight the center\n * @param {number} [options.tolerance=0.001] the difference in distance between candidate medians at which point the algorighim stops iterating.\n * @param {number} [options.counter=10] how many attempts to find the median, should the tolerance be insufficient.\n * @returns {Feature<Point>} The median center of the collection\n * @example\n * var points = turf.points([[0, 0], [1, 0], [0, 1], [5, 8]]);\n * var medianCenter = turf.centerMedian(points);\n *\n * //addToMap\n * var addToMap = [points, medianCenter]\n */\nfunction centerMedian(features, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var counter = options.counter || 10;\n  if (!isNumber(counter)) throw new Error(\"counter must be a number\");\n  var weightTerm = options.weight;\n  // Calculate mean center:\n  var meanCenter = centerMean(features, {\n    weight: options.weight\n  });\n  // Calculate center of every feature:\n  var centroids = featureCollection([]);\n  featureEach(features, function (feature) {\n    var _a;\n    centroids.features.push(centroid(feature, {\n      properties: {\n        weight: (_a = feature.properties) === null || _a === void 0 ? void 0 : _a[weightTerm]\n      }\n    }));\n  });\n  var properties = {\n    tolerance: options.tolerance,\n    medianCandidates: []\n  };\n  return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);\n}\n/**\n * Recursive function to find new candidate medians.\n *\n * @private\n * @param {Position} candidateMedian current candidate median\n * @param {Position} previousCandidate the previous candidate median\n * @param {FeatureCollection<Point>} centroids the collection of centroids whose median we are determining\n * @param {number} counter how many attempts to try before quitting.\n * @returns {Feature<Point>} the median center of the dataset.\n */\nfunction findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {\n  var tolerance = properties.tolerance || 0.001;\n  var candidateXsum = 0;\n  var candidateYsum = 0;\n  var kSum = 0;\n  var centroidCount = 0;\n  featureEach(centroids, function (theCentroid) {\n    var _a;\n    var weightValue = (_a = theCentroid.properties) === null || _a === void 0 ? void 0 : _a.weight;\n    var weight = weightValue === undefined || weightValue === null ? 1 : weightValue;\n    weight = Number(weight);\n    if (!isNumber(weight)) throw new Error(\"weight value must be a number\");\n    if (weight > 0) {\n      centroidCount += 1;\n      var distanceFromCandidate = weight * distance(theCentroid, candidateMedian);\n      if (distanceFromCandidate === 0) distanceFromCandidate = 1;\n      var k = weight / distanceFromCandidate;\n      candidateXsum += theCentroid.geometry.coordinates[0] * k;\n      candidateYsum += theCentroid.geometry.coordinates[1] * k;\n      kSum += k;\n    }\n  });\n  if (centroidCount < 1) throw new Error(\"no features to measure\");\n  var candidateX = candidateXsum / kSum;\n  var candidateY = candidateYsum / kSum;\n  if (centroidCount === 1 || counter === 0 || Math.abs(candidateX - previousCandidate[0]) < tolerance && Math.abs(candidateY - previousCandidate[1]) < tolerance) {\n    return point([candidateX, candidateY], {\n      medianCandidates: properties.medianCandidates\n    });\n  } else {\n    properties.medianCandidates.push([candidateX, candidateY]);\n    return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);\n  }\n}\nexport default centerMedian;","map":{"version":3,"names":["centerMean","distance","centroid","isNumber","point","isObject","featureCollection","featureEach","centerMedian","features","options","Error","counter","weightTerm","weight","meanCenter","centroids","feature","_a","push","properties","tolerance","medianCandidates","findMedian","geometry","coordinates","candidateMedian","previousCandidate","candidateXsum","candidateYsum","kSum","centroidCount","theCentroid","weightValue","undefined","Number","distanceFromCandidate","k","candidateX","candidateY","Math","abs"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/center-median/dist/es/index.js"],"sourcesContent":["import centerMean from \"@turf/center-mean\";\nimport distance from \"@turf/distance\";\nimport centroid from \"@turf/centroid\";\nimport { isNumber, point, isObject, featureCollection, } from \"@turf/helpers\";\nimport { featureEach } from \"@turf/meta\";\n/**\n * Takes a {@link FeatureCollection} of points and calculates the median center,\n * algorithimically. The median center is understood as the point that is\n * requires the least total travel from all other points.\n *\n * Turfjs has four different functions for calculating the center of a set of\n * data. Each is useful depending on circumstance.\n *\n * `@turf/center` finds the simple center of a dataset, by finding the\n * midpoint between the extents of the data. That is, it divides in half the\n * farthest east and farthest west point as well as the farthest north and\n * farthest south.\n *\n * `@turf/center-of-mass` imagines that the dataset is a sheet of paper.\n * The center of mass is where the sheet would balance on a fingertip.\n *\n * `@turf/center-mean` takes the averages of all the coordinates and\n * produces a value that respects that. Unlike `@turf/center`, it is\n * sensitive to clusters and outliers. It lands in the statistical middle of a\n * dataset, not the geographical. It can also be weighted, meaning certain\n * points are more important than others.\n *\n * `@turf/center-median` takes the mean center and tries to find, iteratively,\n * a new point that requires the least amount of travel from all the points in\n * the dataset. It is not as sensitive to outliers as `@turf/center-mean`, but it is\n * attracted to clustered data. It, too, can be weighted.\n *\n * **Bibliography**\n *\n * Harold W. Kuhn and Robert E. Kuenne, “An Efficient Algorithm for the\n * Numerical Solution of the Generalized Weber Problem in Spatial\n * Economics,” _Journal of Regional Science_ 4, no. 2 (1962): 21–33,\n * doi:{@link https://doi.org/10.1111/j.1467-9787.1962.tb00902.x}.\n *\n * James E. Burt, Gerald M. Barber, and David L. Rigby, _Elementary\n * Statistics for Geographers_, 3rd ed., New York: The Guilford\n * Press, 2009, 150–151.\n *\n * @name centerMedian\n * @param {FeatureCollection<any>} features Any GeoJSON Feature Collection\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.weight] the property name used to weight the center\n * @param {number} [options.tolerance=0.001] the difference in distance between candidate medians at which point the algorighim stops iterating.\n * @param {number} [options.counter=10] how many attempts to find the median, should the tolerance be insufficient.\n * @returns {Feature<Point>} The median center of the collection\n * @example\n * var points = turf.points([[0, 0], [1, 0], [0, 1], [5, 8]]);\n * var medianCenter = turf.centerMedian(points);\n *\n * //addToMap\n * var addToMap = [points, medianCenter]\n */\nfunction centerMedian(features, options) {\n    if (options === void 0) { options = {}; }\n    // Optional params\n    options = options || {};\n    if (!isObject(options))\n        throw new Error(\"options is invalid\");\n    var counter = options.counter || 10;\n    if (!isNumber(counter))\n        throw new Error(\"counter must be a number\");\n    var weightTerm = options.weight;\n    // Calculate mean center:\n    var meanCenter = centerMean(features, { weight: options.weight });\n    // Calculate center of every feature:\n    var centroids = featureCollection([]);\n    featureEach(features, function (feature) {\n        var _a;\n        centroids.features.push(centroid(feature, {\n            properties: { weight: (_a = feature.properties) === null || _a === void 0 ? void 0 : _a[weightTerm] },\n        }));\n    });\n    var properties = {\n        tolerance: options.tolerance,\n        medianCandidates: [],\n    };\n    return findMedian(meanCenter.geometry.coordinates, [0, 0], centroids, properties, counter);\n}\n/**\n * Recursive function to find new candidate medians.\n *\n * @private\n * @param {Position} candidateMedian current candidate median\n * @param {Position} previousCandidate the previous candidate median\n * @param {FeatureCollection<Point>} centroids the collection of centroids whose median we are determining\n * @param {number} counter how many attempts to try before quitting.\n * @returns {Feature<Point>} the median center of the dataset.\n */\nfunction findMedian(candidateMedian, previousCandidate, centroids, properties, counter) {\n    var tolerance = properties.tolerance || 0.001;\n    var candidateXsum = 0;\n    var candidateYsum = 0;\n    var kSum = 0;\n    var centroidCount = 0;\n    featureEach(centroids, function (theCentroid) {\n        var _a;\n        var weightValue = (_a = theCentroid.properties) === null || _a === void 0 ? void 0 : _a.weight;\n        var weight = weightValue === undefined || weightValue === null ? 1 : weightValue;\n        weight = Number(weight);\n        if (!isNumber(weight))\n            throw new Error(\"weight value must be a number\");\n        if (weight > 0) {\n            centroidCount += 1;\n            var distanceFromCandidate = weight * distance(theCentroid, candidateMedian);\n            if (distanceFromCandidate === 0)\n                distanceFromCandidate = 1;\n            var k = weight / distanceFromCandidate;\n            candidateXsum += theCentroid.geometry.coordinates[0] * k;\n            candidateYsum += theCentroid.geometry.coordinates[1] * k;\n            kSum += k;\n        }\n    });\n    if (centroidCount < 1)\n        throw new Error(\"no features to measure\");\n    var candidateX = candidateXsum / kSum;\n    var candidateY = candidateYsum / kSum;\n    if (centroidCount === 1 ||\n        counter === 0 ||\n        (Math.abs(candidateX - previousCandidate[0]) < tolerance &&\n            Math.abs(candidateY - previousCandidate[1]) < tolerance)) {\n        return point([candidateX, candidateY], {\n            medianCandidates: properties.medianCandidates,\n        });\n    }\n    else {\n        properties.medianCandidates.push([candidateX, candidateY]);\n        return findMedian([candidateX, candidateY], candidateMedian, centroids, properties, counter - 1);\n    }\n}\nexport default centerMedian;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}