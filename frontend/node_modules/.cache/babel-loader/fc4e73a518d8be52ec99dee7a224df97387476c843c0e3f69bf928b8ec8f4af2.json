{"ast":null,"code":"import intersect from \"@turf/boolean-intersects\";\nimport distance from \"@turf/distance\";\nimport { featureCollection, polygon } from \"@turf/helpers\";\n/**\n * Creates a grid of rectangles from a bounding box, {@link Feature} or {@link FeatureCollection}.\n *\n * @name rectangleGrid\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellWidth of each cell, in units\n * @param {number} cellHeight of each cell, in units\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] units (\"degrees\", \"radians\", \"miles\", \"kilometers\") that the given cellWidth\n * and cellHeight are expressed in. Converted at the southern border.\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,\n * the grid Points will be created only inside it\n * @param {Object} [options.properties={}] passed to each point of the grid\n * @returns {FeatureCollection<Polygon>} a grid of polygons\n * @example\n * var bbox = [-95, 30 ,-85, 40];\n * var cellWidth = 50;\n * var cellHeight = 20;\n * var options = {units: 'miles'};\n *\n * var rectangleGrid = turf.rectangleGrid(bbox, cellWidth, cellHeight, options);\n *\n * //addToMap\n * var addToMap = [rectangleGrid]\n */\nfunction rectangleGrid(bbox, cellWidth, cellHeight, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Containers\n  var results = [];\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  var xFraction = cellWidth / distance([west, south], [east, south], options);\n  var cellWidthDeg = xFraction * (east - west);\n  var yFraction = cellHeight / distance([west, south], [west, north], options);\n  var cellHeightDeg = yFraction * (north - south);\n  // rows & columns\n  var bboxWidth = east - west;\n  var bboxHeight = north - south;\n  var columns = Math.floor(bboxWidth / cellWidthDeg);\n  var rows = Math.floor(bboxHeight / cellHeightDeg);\n  // if the grid does not fill the bbox perfectly, center it.\n  var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;\n  var deltaY = (bboxHeight - rows * cellHeightDeg) / 2;\n  // iterate over columns & rows\n  var currentX = west + deltaX;\n  for (var column = 0; column < columns; column++) {\n    var currentY = south + deltaY;\n    for (var row = 0; row < rows; row++) {\n      var cellPoly = polygon([[[currentX, currentY], [currentX, currentY + cellHeightDeg], [currentX + cellWidthDeg, currentY + cellHeightDeg], [currentX + cellWidthDeg, currentY], [currentX, currentY]]], options.properties);\n      if (options.mask) {\n        if (intersect(options.mask, cellPoly)) {\n          results.push(cellPoly);\n        }\n      } else {\n        results.push(cellPoly);\n      }\n      currentY += cellHeightDeg;\n    }\n    currentX += cellWidthDeg;\n  }\n  return featureCollection(results);\n}\nexport default rectangleGrid;","map":{"version":3,"names":["intersect","distance","featureCollection","polygon","rectangleGrid","bbox","cellWidth","cellHeight","options","results","west","south","east","north","xFraction","cellWidthDeg","yFraction","cellHeightDeg","bboxWidth","bboxHeight","columns","Math","floor","rows","deltaX","deltaY","currentX","column","currentY","row","cellPoly","properties","mask","push"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/rectangle-grid/dist/es/index.js"],"sourcesContent":["import intersect from \"@turf/boolean-intersects\";\nimport distance from \"@turf/distance\";\nimport { featureCollection, polygon, } from \"@turf/helpers\";\n/**\n * Creates a grid of rectangles from a bounding box, {@link Feature} or {@link FeatureCollection}.\n *\n * @name rectangleGrid\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellWidth of each cell, in units\n * @param {number} cellHeight of each cell, in units\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] units (\"degrees\", \"radians\", \"miles\", \"kilometers\") that the given cellWidth\n * and cellHeight are expressed in. Converted at the southern border.\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon,\n * the grid Points will be created only inside it\n * @param {Object} [options.properties={}] passed to each point of the grid\n * @returns {FeatureCollection<Polygon>} a grid of polygons\n * @example\n * var bbox = [-95, 30 ,-85, 40];\n * var cellWidth = 50;\n * var cellHeight = 20;\n * var options = {units: 'miles'};\n *\n * var rectangleGrid = turf.rectangleGrid(bbox, cellWidth, cellHeight, options);\n *\n * //addToMap\n * var addToMap = [rectangleGrid]\n */\nfunction rectangleGrid(bbox, cellWidth, cellHeight, options) {\n    if (options === void 0) { options = {}; }\n    // Containers\n    var results = [];\n    var west = bbox[0];\n    var south = bbox[1];\n    var east = bbox[2];\n    var north = bbox[3];\n    var xFraction = cellWidth / distance([west, south], [east, south], options);\n    var cellWidthDeg = xFraction * (east - west);\n    var yFraction = cellHeight / distance([west, south], [west, north], options);\n    var cellHeightDeg = yFraction * (north - south);\n    // rows & columns\n    var bboxWidth = east - west;\n    var bboxHeight = north - south;\n    var columns = Math.floor(bboxWidth / cellWidthDeg);\n    var rows = Math.floor(bboxHeight / cellHeightDeg);\n    // if the grid does not fill the bbox perfectly, center it.\n    var deltaX = (bboxWidth - columns * cellWidthDeg) / 2;\n    var deltaY = (bboxHeight - rows * cellHeightDeg) / 2;\n    // iterate over columns & rows\n    var currentX = west + deltaX;\n    for (var column = 0; column < columns; column++) {\n        var currentY = south + deltaY;\n        for (var row = 0; row < rows; row++) {\n            var cellPoly = polygon([\n                [\n                    [currentX, currentY],\n                    [currentX, currentY + cellHeightDeg],\n                    [currentX + cellWidthDeg, currentY + cellHeightDeg],\n                    [currentX + cellWidthDeg, currentY],\n                    [currentX, currentY],\n                ],\n            ], options.properties);\n            if (options.mask) {\n                if (intersect(options.mask, cellPoly)) {\n                    results.push(cellPoly);\n                }\n            }\n            else {\n                results.push(cellPoly);\n            }\n            currentY += cellHeightDeg;\n        }\n        currentX += cellWidthDeg;\n    }\n    return featureCollection(results);\n}\nexport default rectangleGrid;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}