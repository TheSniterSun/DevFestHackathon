{"ast":null,"code":"import clone from \"@turf/clone\";\nimport { isObject, lineString, multiLineString } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { lineReduce } from \"@turf/meta\";\n/**\n * Merges all connected (non-forking, non-junctioning) line strings into single lineStrings.\n * [LineString] -> LineString|MultiLineString\n *\n * @param {FeatureCollection<LineString|MultiLineString>} geojson Lines to dissolve\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] Prevent input mutation\n * @returns {Feature<LineString|MultiLineString>} Dissolved lines\n */\nfunction lineDissolve(geojson, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  var mutate = options.mutate;\n  // Validation\n  if (getType(geojson) !== \"FeatureCollection\") {\n    throw new Error(\"geojson must be a FeatureCollection\");\n  }\n  if (!geojson.features.length) {\n    throw new Error(\"geojson is empty\");\n  }\n  // Clone geojson to avoid side effects\n  if (mutate === false || mutate === undefined) {\n    geojson = clone(geojson);\n  }\n  var result = [];\n  var lastLine = lineReduce(geojson, function (previousLine, currentLine) {\n    // Attempt to merge this LineString with the other LineStrings, updating\n    // the reference as it is merged with others and grows.\n    var merged = mergeLineStrings(previousLine, currentLine);\n    // Accumulate the merged LineString\n    if (merged) {\n      return merged;\n      // Put the unmerged LineString back into the list\n    } else {\n      result.push(previousLine);\n      return currentLine;\n    }\n  });\n  // Append the last line\n  if (lastLine) {\n    result.push(lastLine);\n  }\n  // Return null if no lines were dissolved\n  if (!result.length) {\n    return null;\n    // Return LineString if only 1 line was dissolved\n  } else if (result.length === 1) {\n    return result[0];\n    // Return MultiLineString if multiple lines were dissolved with gaps\n  } else {\n    return multiLineString(result.map(function (line) {\n      return line.coordinates;\n    }));\n  }\n}\n// [Number, Number] -> String\nfunction coordId(coord) {\n  return coord[0].toString() + \",\" + coord[1].toString();\n}\n/**\n * LineString, LineString -> LineString\n *\n * @private\n * @param {Feature<LineString>} a line1\n * @param {Feature<LineString>} b line2\n * @returns {Feature<LineString>|null} Merged LineString\n */\nfunction mergeLineStrings(a, b) {\n  var coords1 = a.geometry.coordinates;\n  var coords2 = b.geometry.coordinates;\n  var s1 = coordId(coords1[0]);\n  var e1 = coordId(coords1[coords1.length - 1]);\n  var s2 = coordId(coords2[0]);\n  var e2 = coordId(coords2[coords2.length - 1]);\n  // TODO: handle case where more than one of these is true!\n  var coords;\n  if (s1 === e2) {\n    coords = coords2.concat(coords1.slice(1));\n  } else if (s2 === e1) {\n    coords = coords1.concat(coords2.slice(1));\n  } else if (s1 === s2) {\n    coords = coords1.slice(1).reverse().concat(coords2);\n  } else if (e1 === e2) {\n    coords = coords1.concat(coords2.reverse().slice(1));\n  } else {\n    return null;\n  }\n  return lineString(coords);\n}\nexport default lineDissolve;","map":{"version":3,"names":["clone","isObject","lineString","multiLineString","getType","lineReduce","lineDissolve","geojson","options","Error","mutate","features","length","undefined","result","lastLine","previousLine","currentLine","merged","mergeLineStrings","push","map","line","coordinates","coordId","coord","toString","a","b","coords1","geometry","coords2","s1","e1","s2","e2","coords","concat","slice","reverse"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/concave/dist/es/lib/turf-line-dissolve.js"],"sourcesContent":["import clone from \"@turf/clone\";\nimport { isObject, lineString, multiLineString } from \"@turf/helpers\";\nimport { getType } from \"@turf/invariant\";\nimport { lineReduce } from \"@turf/meta\";\n/**\n * Merges all connected (non-forking, non-junctioning) line strings into single lineStrings.\n * [LineString] -> LineString|MultiLineString\n *\n * @param {FeatureCollection<LineString|MultiLineString>} geojson Lines to dissolve\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] Prevent input mutation\n * @returns {Feature<LineString|MultiLineString>} Dissolved lines\n */\nfunction lineDissolve(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) {\n        throw new Error(\"options is invalid\");\n    }\n    var mutate = options.mutate;\n    // Validation\n    if (getType(geojson) !== \"FeatureCollection\") {\n        throw new Error(\"geojson must be a FeatureCollection\");\n    }\n    if (!geojson.features.length) {\n        throw new Error(\"geojson is empty\");\n    }\n    // Clone geojson to avoid side effects\n    if (mutate === false || mutate === undefined) {\n        geojson = clone(geojson);\n    }\n    var result = [];\n    var lastLine = lineReduce(geojson, function (previousLine, currentLine) {\n        // Attempt to merge this LineString with the other LineStrings, updating\n        // the reference as it is merged with others and grows.\n        var merged = mergeLineStrings(previousLine, currentLine);\n        // Accumulate the merged LineString\n        if (merged) {\n            return merged;\n            // Put the unmerged LineString back into the list\n        }\n        else {\n            result.push(previousLine);\n            return currentLine;\n        }\n    });\n    // Append the last line\n    if (lastLine) {\n        result.push(lastLine);\n    }\n    // Return null if no lines were dissolved\n    if (!result.length) {\n        return null;\n        // Return LineString if only 1 line was dissolved\n    }\n    else if (result.length === 1) {\n        return result[0];\n        // Return MultiLineString if multiple lines were dissolved with gaps\n    }\n    else {\n        return multiLineString(result.map(function (line) {\n            return line.coordinates;\n        }));\n    }\n}\n// [Number, Number] -> String\nfunction coordId(coord) {\n    return coord[0].toString() + \",\" + coord[1].toString();\n}\n/**\n * LineString, LineString -> LineString\n *\n * @private\n * @param {Feature<LineString>} a line1\n * @param {Feature<LineString>} b line2\n * @returns {Feature<LineString>|null} Merged LineString\n */\nfunction mergeLineStrings(a, b) {\n    var coords1 = a.geometry.coordinates;\n    var coords2 = b.geometry.coordinates;\n    var s1 = coordId(coords1[0]);\n    var e1 = coordId(coords1[coords1.length - 1]);\n    var s2 = coordId(coords2[0]);\n    var e2 = coordId(coords2[coords2.length - 1]);\n    // TODO: handle case where more than one of these is true!\n    var coords;\n    if (s1 === e2) {\n        coords = coords2.concat(coords1.slice(1));\n    }\n    else if (s2 === e1) {\n        coords = coords1.concat(coords2.slice(1));\n    }\n    else if (s1 === s2) {\n        coords = coords1.slice(1).reverse().concat(coords2);\n    }\n    else if (e1 === e2) {\n        coords = coords1.concat(coords2.reverse().slice(1));\n    }\n    else {\n        return null;\n    }\n    return lineString(coords);\n}\nexport default lineDissolve;\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,aAAa;AAC/B,SAASC,QAAQ,EAAEC,UAAU,EAAEC,eAAe,QAAQ,eAAe;AACrE,SAASC,OAAO,QAAQ,iBAAiB;AACzC,SAASC,UAAU,QAAQ,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,OAAO,EAAEC,OAAO,EAAE;EACpC,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC;EACAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAI,CAACP,QAAQ,CAACO,OAAO,CAAC,EAAE;IACpB,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EACzC;EACA,IAAIC,MAAM,GAAGF,OAAO,CAACE,MAAM;EAC3B;EACA,IAAIN,OAAO,CAACG,OAAO,CAAC,KAAK,mBAAmB,EAAE;IAC1C,MAAM,IAAIE,KAAK,CAAC,qCAAqC,CAAC;EAC1D;EACA,IAAI,CAACF,OAAO,CAACI,QAAQ,CAACC,MAAM,EAAE;IAC1B,MAAM,IAAIH,KAAK,CAAC,kBAAkB,CAAC;EACvC;EACA;EACA,IAAIC,MAAM,KAAK,KAAK,IAAIA,MAAM,KAAKG,SAAS,EAAE;IAC1CN,OAAO,GAAGP,KAAK,CAACO,OAAO,CAAC;EAC5B;EACA,IAAIO,MAAM,GAAG,EAAE;EACf,IAAIC,QAAQ,GAAGV,UAAU,CAACE,OAAO,EAAE,UAAUS,YAAY,EAAEC,WAAW,EAAE;IACpE;IACA;IACA,IAAIC,MAAM,GAAGC,gBAAgB,CAACH,YAAY,EAAEC,WAAW,CAAC;IACxD;IACA,IAAIC,MAAM,EAAE;MACR,OAAOA,MAAM;MACb;IACJ,CAAC,MACI;MACDJ,MAAM,CAACM,IAAI,CAACJ,YAAY,CAAC;MACzB,OAAOC,WAAW;IACtB;EACJ,CAAC,CAAC;EACF;EACA,IAAIF,QAAQ,EAAE;IACVD,MAAM,CAACM,IAAI,CAACL,QAAQ,CAAC;EACzB;EACA;EACA,IAAI,CAACD,MAAM,CAACF,MAAM,EAAE;IAChB,OAAO,IAAI;IACX;EACJ,CAAC,MACI,IAAIE,MAAM,CAACF,MAAM,KAAK,CAAC,EAAE;IAC1B,OAAOE,MAAM,CAAC,CAAC,CAAC;IAChB;EACJ,CAAC,MACI;IACD,OAAOX,eAAe,CAACW,MAAM,CAACO,GAAG,CAAC,UAAUC,IAAI,EAAE;MAC9C,OAAOA,IAAI,CAACC,WAAW;IAC3B,CAAC,CAAC,CAAC;EACP;AACJ;AACA;AACA,SAASC,OAAOA,CAACC,KAAK,EAAE;EACpB,OAAOA,KAAK,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAG,GAAG,GAAGD,KAAK,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,gBAAgBA,CAACQ,CAAC,EAAEC,CAAC,EAAE;EAC5B,IAAIC,OAAO,GAAGF,CAAC,CAACG,QAAQ,CAACP,WAAW;EACpC,IAAIQ,OAAO,GAAGH,CAAC,CAACE,QAAQ,CAACP,WAAW;EACpC,IAAIS,EAAE,GAAGR,OAAO,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;EAC5B,IAAII,EAAE,GAAGT,OAAO,CAACK,OAAO,CAACA,OAAO,CAACjB,MAAM,GAAG,CAAC,CAAC,CAAC;EAC7C,IAAIsB,EAAE,GAAGV,OAAO,CAACO,OAAO,CAAC,CAAC,CAAC,CAAC;EAC5B,IAAII,EAAE,GAAGX,OAAO,CAACO,OAAO,CAACA,OAAO,CAACnB,MAAM,GAAG,CAAC,CAAC,CAAC;EAC7C;EACA,IAAIwB,MAAM;EACV,IAAIJ,EAAE,KAAKG,EAAE,EAAE;IACXC,MAAM,GAAGL,OAAO,CAACM,MAAM,CAACR,OAAO,CAACS,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7C,CAAC,MACI,IAAIJ,EAAE,KAAKD,EAAE,EAAE;IAChBG,MAAM,GAAGP,OAAO,CAACQ,MAAM,CAACN,OAAO,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7C,CAAC,MACI,IAAIN,EAAE,KAAKE,EAAE,EAAE;IAChBE,MAAM,GAAGP,OAAO,CAACS,KAAK,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,CAACF,MAAM,CAACN,OAAO,CAAC;EACvD,CAAC,MACI,IAAIE,EAAE,KAAKE,EAAE,EAAE;IAChBC,MAAM,GAAGP,OAAO,CAACQ,MAAM,CAACN,OAAO,CAACQ,OAAO,CAAC,CAAC,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;EACvD,CAAC,MACI;IACD,OAAO,IAAI;EACf;EACA,OAAOpC,UAAU,CAACkC,MAAM,CAAC;AAC7B;AACA,eAAe9B,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}