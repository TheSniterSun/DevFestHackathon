{"ast":null,"code":"import clone from '@turf/clone';\nimport center from '@turf/center';\nimport centroid from '@turf/centroid';\nimport turfBBox from '@turf/bbox';\nimport rhumbBearing from '@turf/rhumb-bearing';\nimport rhumbDistance from '@turf/rhumb-distance';\nimport rhumbDestination from '@turf/rhumb-destination';\nimport { featureEach, coordEach } from '@turf/meta';\nimport { isObject, point } from '@turf/helpers';\nimport { getType, getCoords, getCoord } from '@turf/invariant';\n\n/**\n * Scale a GeoJSON from a given point by a factor of scaling (ex: factor=2 would make the GeoJSON 200% larger).\n * If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.\n *\n * @name transformScale\n * @param {GeoJSON} geojson GeoJSON to be scaled\n * @param {number} factor of scaling, positive or negative values greater than 0\n * @param {Object} [options={}] Optional parameters\n * @param {string|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} scaled GeoJSON\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var scaledPoly = turf.transformScale(poly, 3);\n *\n * //addToMap\n * var addToMap = [poly, scaledPoly];\n * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformScale(geojson, factor, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var origin = options.origin;\n  var mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson required\");\n  if (typeof factor !== \"number\" || factor === 0) throw new Error(\"invalid factor\");\n  var originIsPoint = Array.isArray(origin) || typeof origin === \"object\";\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  // Scale each Feature separately\n  if (geojson.type === \"FeatureCollection\" && !originIsPoint) {\n    featureEach(geojson, function (feature, index) {\n      geojson.features[index] = scale(feature, factor, origin);\n    });\n    return geojson;\n  }\n  // Scale Feature/Geometry\n  return scale(geojson, factor, origin);\n}\n\n/**\n * Scale Feature/Geometry\n *\n * @private\n * @param {Feature|Geometry} feature GeoJSON Feature/Geometry\n * @param {number} factor of scaling, positive or negative values greater than 0\n * @param {string|Coord} [origin=\"centroid\"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @returns {Feature|Geometry} scaled GeoJSON Feature/Geometry\n */\nfunction scale(feature, factor, origin) {\n  // Default params\n  var isPoint = getType(feature) === \"Point\";\n  origin = defineOrigin(feature, origin);\n\n  // Shortcut no-scaling\n  if (factor === 1 || isPoint) return feature;\n\n  // Scale each coordinate\n  coordEach(feature, function (coord) {\n    var originalDistance = rhumbDistance(origin, coord);\n    var bearing = rhumbBearing(origin, coord);\n    var newDistance = originalDistance * factor;\n    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));\n    coord[0] = newCoord[0];\n    coord[1] = newCoord[1];\n    if (coord.length === 3) coord[2] *= factor;\n  });\n  return feature;\n}\n\n/**\n * Define Origin\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON\n * @param {string|Coord} origin sw/se/nw/ne/center/centroid\n * @returns {Feature<Point>} Point origin\n */\nfunction defineOrigin(geojson, origin) {\n  // Default params\n  if (origin === undefined || origin === null) origin = \"centroid\";\n\n  // Input Coord\n  if (Array.isArray(origin) || typeof origin === \"object\") return getCoord(origin);\n\n  // Define BBox\n  var bbox = geojson.bbox ? geojson.bbox : turfBBox(geojson);\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  switch (origin) {\n    case \"sw\":\n    case \"southwest\":\n    case \"westsouth\":\n    case \"bottomleft\":\n      return point([west, south]);\n    case \"se\":\n    case \"southeast\":\n    case \"eastsouth\":\n    case \"bottomright\":\n      return point([east, south]);\n    case \"nw\":\n    case \"northwest\":\n    case \"westnorth\":\n    case \"topleft\":\n      return point([west, north]);\n    case \"ne\":\n    case \"northeast\":\n    case \"eastnorth\":\n    case \"topright\":\n      return point([east, north]);\n    case \"center\":\n      return center(geojson);\n    case undefined:\n    case null:\n    case \"centroid\":\n      return centroid(geojson);\n    default:\n      throw new Error(\"invalid origin\");\n  }\n}\nexport default transformScale;","map":{"version":3,"names":["clone","center","centroid","turfBBox","rhumbBearing","rhumbDistance","rhumbDestination","featureEach","coordEach","isObject","point","getType","getCoords","getCoord","transformScale","geojson","factor","options","Error","origin","mutate","originIsPoint","Array","isArray","type","feature","index","features","scale","isPoint","defineOrigin","coord","originalDistance","bearing","newDistance","newCoord","length","undefined","bbox","west","south","east","north"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/transform-scale/dist/es/index.js"],"sourcesContent":["import clone from '@turf/clone';\nimport center from '@turf/center';\nimport centroid from '@turf/centroid';\nimport turfBBox from '@turf/bbox';\nimport rhumbBearing from '@turf/rhumb-bearing';\nimport rhumbDistance from '@turf/rhumb-distance';\nimport rhumbDestination from '@turf/rhumb-destination';\nimport { featureEach, coordEach } from '@turf/meta';\nimport { isObject, point } from '@turf/helpers';\nimport { getType, getCoords, getCoord } from '@turf/invariant';\n\n/**\n * Scale a GeoJSON from a given point by a factor of scaling (ex: factor=2 would make the GeoJSON 200% larger).\n * If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.\n *\n * @name transformScale\n * @param {GeoJSON} geojson GeoJSON to be scaled\n * @param {number} factor of scaling, positive or negative values greater than 0\n * @param {Object} [options={}] Optional parameters\n * @param {string|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} scaled GeoJSON\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var scaledPoly = turf.transformScale(poly, 3);\n *\n * //addToMap\n * var addToMap = [poly, scaledPoly];\n * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformScale(geojson, factor, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var origin = options.origin;\n  var mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson required\");\n  if (typeof factor !== \"number\" || factor === 0)\n    throw new Error(\"invalid factor\");\n  var originIsPoint = Array.isArray(origin) || typeof origin === \"object\";\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  // Scale each Feature separately\n  if (geojson.type === \"FeatureCollection\" && !originIsPoint) {\n    featureEach(geojson, function (feature, index) {\n      geojson.features[index] = scale(feature, factor, origin);\n    });\n    return geojson;\n  }\n  // Scale Feature/Geometry\n  return scale(geojson, factor, origin);\n}\n\n/**\n * Scale Feature/Geometry\n *\n * @private\n * @param {Feature|Geometry} feature GeoJSON Feature/Geometry\n * @param {number} factor of scaling, positive or negative values greater than 0\n * @param {string|Coord} [origin=\"centroid\"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @returns {Feature|Geometry} scaled GeoJSON Feature/Geometry\n */\nfunction scale(feature, factor, origin) {\n  // Default params\n  var isPoint = getType(feature) === \"Point\";\n  origin = defineOrigin(feature, origin);\n\n  // Shortcut no-scaling\n  if (factor === 1 || isPoint) return feature;\n\n  // Scale each coordinate\n  coordEach(feature, function (coord) {\n    var originalDistance = rhumbDistance(origin, coord);\n    var bearing = rhumbBearing(origin, coord);\n    var newDistance = originalDistance * factor;\n    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));\n    coord[0] = newCoord[0];\n    coord[1] = newCoord[1];\n    if (coord.length === 3) coord[2] *= factor;\n  });\n\n  return feature;\n}\n\n/**\n * Define Origin\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON\n * @param {string|Coord} origin sw/se/nw/ne/center/centroid\n * @returns {Feature<Point>} Point origin\n */\nfunction defineOrigin(geojson, origin) {\n  // Default params\n  if (origin === undefined || origin === null) origin = \"centroid\";\n\n  // Input Coord\n  if (Array.isArray(origin) || typeof origin === \"object\")\n    return getCoord(origin);\n\n  // Define BBox\n  var bbox = geojson.bbox ? geojson.bbox : turfBBox(geojson);\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  switch (origin) {\n    case \"sw\":\n    case \"southwest\":\n    case \"westsouth\":\n    case \"bottomleft\":\n      return point([west, south]);\n    case \"se\":\n    case \"southeast\":\n    case \"eastsouth\":\n    case \"bottomright\":\n      return point([east, south]);\n    case \"nw\":\n    case \"northwest\":\n    case \"westnorth\":\n    case \"topleft\":\n      return point([west, north]);\n    case \"ne\":\n    case \"northeast\":\n    case \"eastnorth\":\n    case \"topright\":\n      return point([east, north]);\n    case \"center\":\n      return center(geojson);\n    case undefined:\n    case null:\n    case \"centroid\":\n      return centroid(geojson);\n    default:\n      throw new Error(\"invalid origin\");\n  }\n}\n\nexport default transformScale;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}