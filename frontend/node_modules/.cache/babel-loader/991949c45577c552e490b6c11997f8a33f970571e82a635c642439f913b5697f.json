{"ast":null,"code":"import Node from \"./Node.js\";\nimport Edge from \"./Edge.js\";\nimport EdgeRing from \"./EdgeRing.js\";\nimport { flattenEach, coordReduce } from \"@turf/meta\";\nimport { featureOf } from \"@turf/invariant\";\n/**\n * Validates the geoJson.\n *\n * @param {GeoJSON} geoJson - input geoJson.\n * @throws {Error} if geoJson is invalid.\n */\nfunction validateGeoJson(geoJson) {\n  if (!geoJson) throw new Error(\"No geojson passed\");\n  if (geoJson.type !== \"FeatureCollection\" && geoJson.type !== \"GeometryCollection\" && geoJson.type !== \"MultiLineString\" && geoJson.type !== \"LineString\" && geoJson.type !== \"Feature\") throw new Error(\"Invalid input type '\" + geoJson.type + \"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature\");\n}\n/**\n * Represents a planar graph of edges and nodes that can be used to compute a polygonization.\n *\n * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,\n * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it\n * isn't a javascript transcription of the C++ source.\n *\n * This graph is directed (both directions are created)\n */\nvar Graph = /** @class */function () {\n  function Graph() {\n    this.edges = []; //< {Edge[]} dirEdges\n    // The key is the `id` of the Node (ie: coordinates.join(','))\n    this.nodes = {};\n  }\n  /**\n   * Creates a graph from a GeoJSON.\n   *\n   * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\n   * @returns {Graph} - The newly created graph\n   * @throws {Error} if geoJson is invalid.\n   */\n  Graph.fromGeoJson = function (geoJson) {\n    validateGeoJson(geoJson);\n    var graph = new Graph();\n    flattenEach(geoJson, function (feature) {\n      featureOf(feature, \"LineString\", \"Graph::fromGeoJson\");\n      // When a LineString if formed by many segments, split them\n      coordReduce(feature, function (prev, cur) {\n        if (prev) {\n          var start = graph.getNode(prev),\n            end = graph.getNode(cur);\n          graph.addEdge(start, end);\n        }\n        return cur;\n      });\n    });\n    return graph;\n  };\n  /**\n   * Creates or get a Node.\n   *\n   * @param {number[]} coordinates - Coordinates of the node\n   * @returns {Node} - The created or stored node\n   */\n  Graph.prototype.getNode = function (coordinates) {\n    var id = Node.buildId(coordinates);\n    var node = this.nodes[id];\n    if (!node) node = this.nodes[id] = new Node(coordinates);\n    return node;\n  };\n  /**\n   * Adds an Edge and its symetricall.\n   *\n   * Edges are added symetrically, i.e.: we also add its symetric\n   *\n   * @param {Node} from - Node which starts the Edge\n   * @param {Node} to - Node which ends the Edge\n   */\n  Graph.prototype.addEdge = function (from, to) {\n    var edge = new Edge(from, to),\n      symetricEdge = edge.getSymetric();\n    this.edges.push(edge);\n    this.edges.push(symetricEdge);\n  };\n  /**\n   * Removes Dangle Nodes (nodes with grade 1).\n   */\n  Graph.prototype.deleteDangles = function () {\n    var _this = this;\n    Object.keys(this.nodes).map(function (id) {\n      return _this.nodes[id];\n    }).forEach(function (node) {\n      return _this._removeIfDangle(node);\n    });\n  };\n  /**\n   * Check if node is dangle, if so, remove it.\n   *\n   * It calls itself recursively, removing a dangling node might cause another dangling node\n   *\n   * @param {Node} node - Node to check if it's a dangle\n   */\n  Graph.prototype._removeIfDangle = function (node) {\n    var _this = this;\n    // As edges are directed and symetrical, we count only innerEdges\n    if (node.innerEdges.length <= 1) {\n      var outerNodes = node.getOuterEdges().map(function (e) {\n        return e.to;\n      });\n      this.removeNode(node);\n      outerNodes.forEach(function (n) {\n        return _this._removeIfDangle(n);\n      });\n    }\n  };\n  /**\n   * Delete cut-edges (bridge edges).\n   *\n   * The graph will be traversed, all the edges will be labeled according the ring\n   * in which they are. (The label is a number incremented by 1). Edges with the same\n   * label are cut-edges.\n   */\n  Graph.prototype.deleteCutEdges = function () {\n    var _this = this;\n    this._computeNextCWEdges();\n    this._findLabeledEdgeRings();\n    // Cut-edges (bridges) are edges where both edges have the same label\n    this.edges.forEach(function (edge) {\n      if (edge.label === edge.symetric.label) {\n        _this.removeEdge(edge.symetric);\n        _this.removeEdge(edge);\n      }\n    });\n  };\n  /**\n   * Set the `next` property of each Edge.\n   *\n   * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\n   * OuterEdges are sorted CCW.\n   *\n   * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\n   */\n  Graph.prototype._computeNextCWEdges = function (node) {\n    var _this = this;\n    if (typeof node === \"undefined\") {\n      Object.keys(this.nodes).forEach(function (id) {\n        return _this._computeNextCWEdges(_this.nodes[id]);\n      });\n    } else {\n      node.getOuterEdges().forEach(function (edge, i) {\n        node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\n      });\n    }\n  };\n  /**\n   * Computes the next edge pointers going CCW around the given node, for the given edgering label.\n   *\n   * This algorithm has the effect of converting maximal edgerings into minimal edgerings\n   *\n   * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\n   * could be written in a more javascript way.\n   *\n   * @param {Node} node - Node\n   * @param {number} label - Ring's label\n   */\n  Graph.prototype._computeNextCCWEdges = function (node, label) {\n    var edges = node.getOuterEdges();\n    var firstOutDE, prevInDE;\n    for (var i = edges.length - 1; i >= 0; --i) {\n      var de = edges[i],\n        sym = de.symetric,\n        outDE = void 0,\n        inDE = void 0;\n      if (de.label === label) outDE = de;\n      if (sym.label === label) inDE = sym;\n      if (!outDE || !inDE)\n        // This edge is not in edgering\n        continue;\n      if (inDE) prevInDE = inDE;\n      if (outDE) {\n        if (prevInDE) {\n          prevInDE.next = outDE;\n          prevInDE = undefined;\n        }\n        if (!firstOutDE) firstOutDE = outDE;\n      }\n    }\n    if (prevInDE) prevInDE.next = firstOutDE;\n  };\n  /**\n   * Finds rings and labels edges according to which rings are.\n   *\n   * The label is a number which is increased for each ring.\n   *\n   * @returns {Edge[]} edges that start rings\n   */\n  Graph.prototype._findLabeledEdgeRings = function () {\n    var edgeRingStarts = [];\n    var label = 0;\n    this.edges.forEach(function (edge) {\n      if (edge.label >= 0) return;\n      edgeRingStarts.push(edge);\n      var e = edge;\n      do {\n        e.label = label;\n        e = e.next;\n      } while (!edge.isEqual(e));\n      label++;\n    });\n    return edgeRingStarts;\n  };\n  /**\n   * Computes the EdgeRings formed by the edges in this graph.\n   *\n   * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\n   */\n  Graph.prototype.getEdgeRings = function () {\n    var _this = this;\n    this._computeNextCWEdges();\n    // Clear labels\n    this.edges.forEach(function (edge) {\n      edge.label = undefined;\n    });\n    this._findLabeledEdgeRings().forEach(function (edge) {\n      // convertMaximalToMinimalEdgeRings\n      _this._findIntersectionNodes(edge).forEach(function (node) {\n        _this._computeNextCCWEdges(node, edge.label);\n      });\n    });\n    var edgeRingList = [];\n    // find all edgerings\n    this.edges.forEach(function (edge) {\n      if (edge.ring) return;\n      edgeRingList.push(_this._findEdgeRing(edge));\n    });\n    return edgeRingList;\n  };\n  /**\n   * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\n   *\n   * @param {Node} startEdge - Start Edge of the Ring\n   * @returns {Node[]} - intersection nodes\n   */\n  Graph.prototype._findIntersectionNodes = function (startEdge) {\n    var intersectionNodes = [];\n    var edge = startEdge;\n    var _loop_1 = function () {\n      // getDegree\n      var degree = 0;\n      edge.from.getOuterEdges().forEach(function (e) {\n        if (e.label === startEdge.label) ++degree;\n      });\n      if (degree > 1) intersectionNodes.push(edge.from);\n      edge = edge.next;\n    };\n    do {\n      _loop_1();\n    } while (!startEdge.isEqual(edge));\n    return intersectionNodes;\n  };\n  /**\n   * Get the edge-ring which starts from the provided Edge.\n   *\n   * @param {Edge} startEdge - starting edge of the edge ring\n   * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\n   */\n  Graph.prototype._findEdgeRing = function (startEdge) {\n    var edge = startEdge;\n    var edgeRing = new EdgeRing();\n    do {\n      edgeRing.push(edge);\n      edge.ring = edgeRing;\n      edge = edge.next;\n    } while (!startEdge.isEqual(edge));\n    return edgeRing;\n  };\n  /**\n   * Removes a node from the Graph.\n   *\n   * It also removes edges asociated to that node\n   * @param {Node} node - Node to be removed\n   */\n  Graph.prototype.removeNode = function (node) {\n    var _this = this;\n    node.getOuterEdges().forEach(function (edge) {\n      return _this.removeEdge(edge);\n    });\n    node.innerEdges.forEach(function (edge) {\n      return _this.removeEdge(edge);\n    });\n    delete this.nodes[node.id];\n  };\n  /**\n   * Remove edge from the graph and deletes the edge.\n   *\n   * @param {Edge} edge - Edge to be removed\n   */\n  Graph.prototype.removeEdge = function (edge) {\n    this.edges = this.edges.filter(function (e) {\n      return !e.isEqual(edge);\n    });\n    edge.deleteEdge();\n  };\n  return Graph;\n}();\nexport default Graph;","map":{"version":3,"names":["Node","Edge","EdgeRing","flattenEach","coordReduce","featureOf","validateGeoJson","geoJson","Error","type","Graph","edges","nodes","fromGeoJson","graph","feature","prev","cur","start","getNode","end","addEdge","prototype","coordinates","id","buildId","node","from","to","edge","symetricEdge","getSymetric","push","deleteDangles","_this","Object","keys","map","forEach","_removeIfDangle","innerEdges","length","outerNodes","getOuterEdges","e","removeNode","n","deleteCutEdges","_computeNextCWEdges","_findLabeledEdgeRings","label","symetric","removeEdge","i","getOuterEdge","next","_computeNextCCWEdges","firstOutDE","prevInDE","de","sym","outDE","inDE","undefined","edgeRingStarts","isEqual","getEdgeRings","_findIntersectionNodes","edgeRingList","ring","_findEdgeRing","startEdge","intersectionNodes","_loop_1","degree","edgeRing","filter","deleteEdge"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/polygonize/dist/es/lib/Graph.js"],"sourcesContent":["import Node from \"./Node.js\";\nimport Edge from \"./Edge.js\";\nimport EdgeRing from \"./EdgeRing.js\";\nimport { flattenEach, coordReduce } from \"@turf/meta\";\nimport { featureOf } from \"@turf/invariant\";\n/**\n * Validates the geoJson.\n *\n * @param {GeoJSON} geoJson - input geoJson.\n * @throws {Error} if geoJson is invalid.\n */\nfunction validateGeoJson(geoJson) {\n    if (!geoJson)\n        throw new Error(\"No geojson passed\");\n    if (geoJson.type !== \"FeatureCollection\" &&\n        geoJson.type !== \"GeometryCollection\" &&\n        geoJson.type !== \"MultiLineString\" &&\n        geoJson.type !== \"LineString\" &&\n        geoJson.type !== \"Feature\")\n        throw new Error(\"Invalid input type '\" + geoJson.type + \"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature\");\n}\n/**\n * Represents a planar graph of edges and nodes that can be used to compute a polygonization.\n *\n * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,\n * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it\n * isn't a javascript transcription of the C++ source.\n *\n * This graph is directed (both directions are created)\n */\nvar Graph = /** @class */ (function () {\n    function Graph() {\n        this.edges = []; //< {Edge[]} dirEdges\n        // The key is the `id` of the Node (ie: coordinates.join(','))\n        this.nodes = {};\n    }\n    /**\n     * Creates a graph from a GeoJSON.\n     *\n     * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\n     * @returns {Graph} - The newly created graph\n     * @throws {Error} if geoJson is invalid.\n     */\n    Graph.fromGeoJson = function (geoJson) {\n        validateGeoJson(geoJson);\n        var graph = new Graph();\n        flattenEach(geoJson, function (feature) {\n            featureOf(feature, \"LineString\", \"Graph::fromGeoJson\");\n            // When a LineString if formed by many segments, split them\n            coordReduce(feature, function (prev, cur) {\n                if (prev) {\n                    var start = graph.getNode(prev), end = graph.getNode(cur);\n                    graph.addEdge(start, end);\n                }\n                return cur;\n            });\n        });\n        return graph;\n    };\n    /**\n     * Creates or get a Node.\n     *\n     * @param {number[]} coordinates - Coordinates of the node\n     * @returns {Node} - The created or stored node\n     */\n    Graph.prototype.getNode = function (coordinates) {\n        var id = Node.buildId(coordinates);\n        var node = this.nodes[id];\n        if (!node)\n            node = this.nodes[id] = new Node(coordinates);\n        return node;\n    };\n    /**\n     * Adds an Edge and its symetricall.\n     *\n     * Edges are added symetrically, i.e.: we also add its symetric\n     *\n     * @param {Node} from - Node which starts the Edge\n     * @param {Node} to - Node which ends the Edge\n     */\n    Graph.prototype.addEdge = function (from, to) {\n        var edge = new Edge(from, to), symetricEdge = edge.getSymetric();\n        this.edges.push(edge);\n        this.edges.push(symetricEdge);\n    };\n    /**\n     * Removes Dangle Nodes (nodes with grade 1).\n     */\n    Graph.prototype.deleteDangles = function () {\n        var _this = this;\n        Object.keys(this.nodes)\n            .map(function (id) { return _this.nodes[id]; })\n            .forEach(function (node) { return _this._removeIfDangle(node); });\n    };\n    /**\n     * Check if node is dangle, if so, remove it.\n     *\n     * It calls itself recursively, removing a dangling node might cause another dangling node\n     *\n     * @param {Node} node - Node to check if it's a dangle\n     */\n    Graph.prototype._removeIfDangle = function (node) {\n        var _this = this;\n        // As edges are directed and symetrical, we count only innerEdges\n        if (node.innerEdges.length <= 1) {\n            var outerNodes = node.getOuterEdges().map(function (e) { return e.to; });\n            this.removeNode(node);\n            outerNodes.forEach(function (n) { return _this._removeIfDangle(n); });\n        }\n    };\n    /**\n     * Delete cut-edges (bridge edges).\n     *\n     * The graph will be traversed, all the edges will be labeled according the ring\n     * in which they are. (The label is a number incremented by 1). Edges with the same\n     * label are cut-edges.\n     */\n    Graph.prototype.deleteCutEdges = function () {\n        var _this = this;\n        this._computeNextCWEdges();\n        this._findLabeledEdgeRings();\n        // Cut-edges (bridges) are edges where both edges have the same label\n        this.edges.forEach(function (edge) {\n            if (edge.label === edge.symetric.label) {\n                _this.removeEdge(edge.symetric);\n                _this.removeEdge(edge);\n            }\n        });\n    };\n    /**\n     * Set the `next` property of each Edge.\n     *\n     * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\n     * OuterEdges are sorted CCW.\n     *\n     * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\n     */\n    Graph.prototype._computeNextCWEdges = function (node) {\n        var _this = this;\n        if (typeof node === \"undefined\") {\n            Object.keys(this.nodes).forEach(function (id) {\n                return _this._computeNextCWEdges(_this.nodes[id]);\n            });\n        }\n        else {\n            node.getOuterEdges().forEach(function (edge, i) {\n                node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\n            });\n        }\n    };\n    /**\n     * Computes the next edge pointers going CCW around the given node, for the given edgering label.\n     *\n     * This algorithm has the effect of converting maximal edgerings into minimal edgerings\n     *\n     * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\n     * could be written in a more javascript way.\n     *\n     * @param {Node} node - Node\n     * @param {number} label - Ring's label\n     */\n    Graph.prototype._computeNextCCWEdges = function (node, label) {\n        var edges = node.getOuterEdges();\n        var firstOutDE, prevInDE;\n        for (var i = edges.length - 1; i >= 0; --i) {\n            var de = edges[i], sym = de.symetric, outDE = void 0, inDE = void 0;\n            if (de.label === label)\n                outDE = de;\n            if (sym.label === label)\n                inDE = sym;\n            if (!outDE || !inDE)\n                // This edge is not in edgering\n                continue;\n            if (inDE)\n                prevInDE = inDE;\n            if (outDE) {\n                if (prevInDE) {\n                    prevInDE.next = outDE;\n                    prevInDE = undefined;\n                }\n                if (!firstOutDE)\n                    firstOutDE = outDE;\n            }\n        }\n        if (prevInDE)\n            prevInDE.next = firstOutDE;\n    };\n    /**\n     * Finds rings and labels edges according to which rings are.\n     *\n     * The label is a number which is increased for each ring.\n     *\n     * @returns {Edge[]} edges that start rings\n     */\n    Graph.prototype._findLabeledEdgeRings = function () {\n        var edgeRingStarts = [];\n        var label = 0;\n        this.edges.forEach(function (edge) {\n            if (edge.label >= 0)\n                return;\n            edgeRingStarts.push(edge);\n            var e = edge;\n            do {\n                e.label = label;\n                e = e.next;\n            } while (!edge.isEqual(e));\n            label++;\n        });\n        return edgeRingStarts;\n    };\n    /**\n     * Computes the EdgeRings formed by the edges in this graph.\n     *\n     * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\n     */\n    Graph.prototype.getEdgeRings = function () {\n        var _this = this;\n        this._computeNextCWEdges();\n        // Clear labels\n        this.edges.forEach(function (edge) {\n            edge.label = undefined;\n        });\n        this._findLabeledEdgeRings().forEach(function (edge) {\n            // convertMaximalToMinimalEdgeRings\n            _this._findIntersectionNodes(edge).forEach(function (node) {\n                _this._computeNextCCWEdges(node, edge.label);\n            });\n        });\n        var edgeRingList = [];\n        // find all edgerings\n        this.edges.forEach(function (edge) {\n            if (edge.ring)\n                return;\n            edgeRingList.push(_this._findEdgeRing(edge));\n        });\n        return edgeRingList;\n    };\n    /**\n     * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\n     *\n     * @param {Node} startEdge - Start Edge of the Ring\n     * @returns {Node[]} - intersection nodes\n     */\n    Graph.prototype._findIntersectionNodes = function (startEdge) {\n        var intersectionNodes = [];\n        var edge = startEdge;\n        var _loop_1 = function () {\n            // getDegree\n            var degree = 0;\n            edge.from.getOuterEdges().forEach(function (e) {\n                if (e.label === startEdge.label)\n                    ++degree;\n            });\n            if (degree > 1)\n                intersectionNodes.push(edge.from);\n            edge = edge.next;\n        };\n        do {\n            _loop_1();\n        } while (!startEdge.isEqual(edge));\n        return intersectionNodes;\n    };\n    /**\n     * Get the edge-ring which starts from the provided Edge.\n     *\n     * @param {Edge} startEdge - starting edge of the edge ring\n     * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\n     */\n    Graph.prototype._findEdgeRing = function (startEdge) {\n        var edge = startEdge;\n        var edgeRing = new EdgeRing();\n        do {\n            edgeRing.push(edge);\n            edge.ring = edgeRing;\n            edge = edge.next;\n        } while (!startEdge.isEqual(edge));\n        return edgeRing;\n    };\n    /**\n     * Removes a node from the Graph.\n     *\n     * It also removes edges asociated to that node\n     * @param {Node} node - Node to be removed\n     */\n    Graph.prototype.removeNode = function (node) {\n        var _this = this;\n        node.getOuterEdges().forEach(function (edge) { return _this.removeEdge(edge); });\n        node.innerEdges.forEach(function (edge) { return _this.removeEdge(edge); });\n        delete this.nodes[node.id];\n    };\n    /**\n     * Remove edge from the graph and deletes the edge.\n     *\n     * @param {Edge} edge - Edge to be removed\n     */\n    Graph.prototype.removeEdge = function (edge) {\n        this.edges = this.edges.filter(function (e) { return !e.isEqual(edge); });\n        edge.deleteEdge();\n    };\n    return Graph;\n}());\nexport default Graph;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}