{"ast":null,"code":"import within from \"@turf/boolean-within\";\nimport distance from \"@turf/distance\";\nimport { point, featureCollection } from \"@turf/helpers\";\n/**\n * Creates a {@link Point} grid from a bounding box, {@link FeatureCollection} or {@link Feature}.\n *\n * @name pointGrid\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellSide the distance between points, in units\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it\n * @param {Object} [options.properties={}] passed to each point of the grid\n * @returns {FeatureCollection<Point>} grid of points\n * @example\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n * var cellSide = 3;\n * var options = {units: 'miles'};\n *\n * var grid = turf.pointGrid(extent, cellSide, options);\n *\n * //addToMap\n * var addToMap = [grid];\n */\nfunction pointGrid(bbox, cellSide, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // Default parameters\n  if (options.mask && !options.units) options.units = \"kilometers\";\n  // Containers\n  var results = [];\n  // Typescript handles the Type Validation\n  // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');\n  // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');\n  // if (!bbox) throw new Error('bbox is required');\n  // if (!Array.isArray(bbox)) throw new Error('bbox must be array');\n  // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');\n  // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  var xFraction = cellSide / distance([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = cellSide / distance([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n  var bboxWidth = east - west;\n  var bboxHeight = north - south;\n  var columns = Math.floor(bboxWidth / cellWidth);\n  var rows = Math.floor(bboxHeight / cellHeight);\n  // adjust origin of the grid\n  var deltaX = (bboxWidth - columns * cellWidth) / 2;\n  var deltaY = (bboxHeight - rows * cellHeight) / 2;\n  var currentX = west + deltaX;\n  while (currentX <= east) {\n    var currentY = south + deltaY;\n    while (currentY <= north) {\n      var cellPt = point([currentX, currentY], options.properties);\n      if (options.mask) {\n        if (within(cellPt, options.mask)) results.push(cellPt);\n      } else {\n        results.push(cellPt);\n      }\n      currentY += cellHeight;\n    }\n    currentX += cellWidth;\n  }\n  return featureCollection(results);\n}\nexport default pointGrid;","map":{"version":3,"names":["within","distance","point","featureCollection","pointGrid","bbox","cellSide","options","mask","units","results","west","south","east","north","xFraction","cellWidth","yFraction","cellHeight","bboxWidth","bboxHeight","columns","Math","floor","rows","deltaX","deltaY","currentX","currentY","cellPt","properties","push"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/point-grid/dist/es/index.js"],"sourcesContent":["import within from \"@turf/boolean-within\";\nimport distance from \"@turf/distance\";\nimport { point, featureCollection, } from \"@turf/helpers\";\n/**\n * Creates a {@link Point} grid from a bounding box, {@link FeatureCollection} or {@link Feature}.\n *\n * @name pointGrid\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellSide the distance between points, in units\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] used in calculating cellSide, can be degrees, radians, miles, or kilometers\n * @param {Feature<Polygon|MultiPolygon>} [options.mask] if passed a Polygon or MultiPolygon, the grid Points will be created only inside it\n * @param {Object} [options.properties={}] passed to each point of the grid\n * @returns {FeatureCollection<Point>} grid of points\n * @example\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n * var cellSide = 3;\n * var options = {units: 'miles'};\n *\n * var grid = turf.pointGrid(extent, cellSide, options);\n *\n * //addToMap\n * var addToMap = [grid];\n */\nfunction pointGrid(bbox, cellSide, options) {\n    if (options === void 0) { options = {}; }\n    // Default parameters\n    if (options.mask && !options.units)\n        options.units = \"kilometers\";\n    // Containers\n    var results = [];\n    // Typescript handles the Type Validation\n    // if (cellSide === null || cellSide === undefined) throw new Error('cellSide is required');\n    // if (!isNumber(cellSide)) throw new Error('cellSide is invalid');\n    // if (!bbox) throw new Error('bbox is required');\n    // if (!Array.isArray(bbox)) throw new Error('bbox must be array');\n    // if (bbox.length !== 4) throw new Error('bbox must contain 4 numbers');\n    // if (mask && ['Polygon', 'MultiPolygon'].indexOf(getType(mask)) === -1) throw new Error('options.mask must be a (Multi)Polygon');\n    var west = bbox[0];\n    var south = bbox[1];\n    var east = bbox[2];\n    var north = bbox[3];\n    var xFraction = cellSide / distance([west, south], [east, south], options);\n    var cellWidth = xFraction * (east - west);\n    var yFraction = cellSide / distance([west, south], [west, north], options);\n    var cellHeight = yFraction * (north - south);\n    var bboxWidth = east - west;\n    var bboxHeight = north - south;\n    var columns = Math.floor(bboxWidth / cellWidth);\n    var rows = Math.floor(bboxHeight / cellHeight);\n    // adjust origin of the grid\n    var deltaX = (bboxWidth - columns * cellWidth) / 2;\n    var deltaY = (bboxHeight - rows * cellHeight) / 2;\n    var currentX = west + deltaX;\n    while (currentX <= east) {\n        var currentY = south + deltaY;\n        while (currentY <= north) {\n            var cellPt = point([currentX, currentY], options.properties);\n            if (options.mask) {\n                if (within(cellPt, options.mask))\n                    results.push(cellPt);\n            }\n            else {\n                results.push(cellPt);\n            }\n            currentY += cellHeight;\n        }\n        currentX += cellWidth;\n    }\n    return featureCollection(results);\n}\nexport default pointGrid;\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,sBAAsB;AACzC,OAAOC,QAAQ,MAAM,gBAAgB;AACrC,SAASC,KAAK,EAAEC,iBAAiB,QAAS,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EACxC,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC;EACA,IAAIA,OAAO,CAACC,IAAI,IAAI,CAACD,OAAO,CAACE,KAAK,EAC9BF,OAAO,CAACE,KAAK,GAAG,YAAY;EAChC;EACA,IAAIC,OAAO,GAAG,EAAE;EAChB;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIC,IAAI,GAAGN,IAAI,CAAC,CAAC,CAAC;EAClB,IAAIO,KAAK,GAAGP,IAAI,CAAC,CAAC,CAAC;EACnB,IAAIQ,IAAI,GAAGR,IAAI,CAAC,CAAC,CAAC;EAClB,IAAIS,KAAK,GAAGT,IAAI,CAAC,CAAC,CAAC;EACnB,IAAIU,SAAS,GAAGT,QAAQ,GAAGL,QAAQ,CAAC,CAACU,IAAI,EAAEC,KAAK,CAAC,EAAE,CAACC,IAAI,EAAED,KAAK,CAAC,EAAEL,OAAO,CAAC;EAC1E,IAAIS,SAAS,GAAGD,SAAS,IAAIF,IAAI,GAAGF,IAAI,CAAC;EACzC,IAAIM,SAAS,GAAGX,QAAQ,GAAGL,QAAQ,CAAC,CAACU,IAAI,EAAEC,KAAK,CAAC,EAAE,CAACD,IAAI,EAAEG,KAAK,CAAC,EAAEP,OAAO,CAAC;EAC1E,IAAIW,UAAU,GAAGD,SAAS,IAAIH,KAAK,GAAGF,KAAK,CAAC;EAC5C,IAAIO,SAAS,GAAGN,IAAI,GAAGF,IAAI;EAC3B,IAAIS,UAAU,GAAGN,KAAK,GAAGF,KAAK;EAC9B,IAAIS,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACJ,SAAS,GAAGH,SAAS,CAAC;EAC/C,IAAIQ,IAAI,GAAGF,IAAI,CAACC,KAAK,CAACH,UAAU,GAAGF,UAAU,CAAC;EAC9C;EACA,IAAIO,MAAM,GAAG,CAACN,SAAS,GAAGE,OAAO,GAAGL,SAAS,IAAI,CAAC;EAClD,IAAIU,MAAM,GAAG,CAACN,UAAU,GAAGI,IAAI,GAAGN,UAAU,IAAI,CAAC;EACjD,IAAIS,QAAQ,GAAGhB,IAAI,GAAGc,MAAM;EAC5B,OAAOE,QAAQ,IAAId,IAAI,EAAE;IACrB,IAAIe,QAAQ,GAAGhB,KAAK,GAAGc,MAAM;IAC7B,OAAOE,QAAQ,IAAId,KAAK,EAAE;MACtB,IAAIe,MAAM,GAAG3B,KAAK,CAAC,CAACyB,QAAQ,EAAEC,QAAQ,CAAC,EAAErB,OAAO,CAACuB,UAAU,CAAC;MAC5D,IAAIvB,OAAO,CAACC,IAAI,EAAE;QACd,IAAIR,MAAM,CAAC6B,MAAM,EAAEtB,OAAO,CAACC,IAAI,CAAC,EAC5BE,OAAO,CAACqB,IAAI,CAACF,MAAM,CAAC;MAC5B,CAAC,MACI;QACDnB,OAAO,CAACqB,IAAI,CAACF,MAAM,CAAC;MACxB;MACAD,QAAQ,IAAIV,UAAU;IAC1B;IACAS,QAAQ,IAAIX,SAAS;EACzB;EACA,OAAOb,iBAAiB,CAACO,OAAO,CAAC;AACrC;AACA,eAAeN,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}