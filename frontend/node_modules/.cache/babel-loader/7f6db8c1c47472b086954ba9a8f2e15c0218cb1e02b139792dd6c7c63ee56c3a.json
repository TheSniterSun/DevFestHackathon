{"ast":null,"code":"// https://en.wikipedia.org/wiki/Rhumb_line\nimport { convertLength, earthRadius } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Calculates the distance along a rhumb line between two {@link Point|points} in degrees, radians,\n * miles, or kilometers.\n *\n * @name rhumbDistance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.rhumbDistance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction rhumbDistance(from, to, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var origin = getCoord(from);\n  var destination = getCoord(to);\n  // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n  // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n  destination[0] += destination[0] - origin[0] > 180 ? -360 : origin[0] - destination[0] > 180 ? 360 : 0;\n  var distanceInMeters = calculateRhumbDistance(origin, destination);\n  var distance = convertLength(distanceInMeters, \"meters\", options.units);\n  return distance;\n}\n/**\n * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.\n * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js\n *\n * @private\n * @param   {Array<number>} origin point.\n * @param   {Array<number>} destination point.\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n * @returns {number} Distance in km between this point and destination point (same units as radius).\n *\n * @example\n *     var p1 = new LatLon(51.127, 1.338);\n *     var p2 = new LatLon(50.964, 1.853);\n *     var d = p1.distanceTo(p2); // 40.31 km\n */\nfunction calculateRhumbDistance(origin, destination, radius) {\n  // φ => phi\n  // λ => lambda\n  // ψ => psi\n  // Δ => Delta\n  // δ => delta\n  // θ => theta\n  radius = radius === undefined ? earthRadius : Number(radius);\n  // see www.edwilliams.org/avform.htm#Rhumb\n  var R = radius;\n  var phi1 = origin[1] * Math.PI / 180;\n  var phi2 = destination[1] * Math.PI / 180;\n  var DeltaPhi = phi2 - phi1;\n  var DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;\n  // if dLon over 180° take shorter rhumb line across the anti-meridian:\n  if (DeltaLambda > Math.PI) {\n    DeltaLambda -= 2 * Math.PI;\n  }\n  // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n  // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n  var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n  // distance is pythagoras on 'stretched' Mercator projection\n  var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda); // angular distance in radians\n  var dist = delta * R;\n  return dist;\n}\nexport default rhumbDistance;","map":{"version":3,"names":["convertLength","earthRadius","getCoord","rhumbDistance","from","to","options","origin","destination","distanceInMeters","calculateRhumbDistance","distance","units","radius","undefined","Number","R","phi1","Math","PI","phi2","DeltaPhi","DeltaLambda","abs","DeltaPsi","log","tan","q","cos","delta","sqrt","dist"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/rhumb-distance/dist/es/index.js"],"sourcesContent":["// https://en.wikipedia.org/wiki/Rhumb_line\nimport { convertLength, earthRadius } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Calculates the distance along a rhumb line between two {@link Point|points} in degrees, radians,\n * miles, or kilometers.\n *\n * @name rhumbDistance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.rhumbDistance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction rhumbDistance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var origin = getCoord(from);\n    var destination = getCoord(to);\n    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n    destination[0] +=\n        destination[0] - origin[0] > 180\n            ? -360\n            : origin[0] - destination[0] > 180\n                ? 360\n                : 0;\n    var distanceInMeters = calculateRhumbDistance(origin, destination);\n    var distance = convertLength(distanceInMeters, \"meters\", options.units);\n    return distance;\n}\n/**\n * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.\n * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js\n *\n * @private\n * @param   {Array<number>} origin point.\n * @param   {Array<number>} destination point.\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n * @returns {number} Distance in km between this point and destination point (same units as radius).\n *\n * @example\n *     var p1 = new LatLon(51.127, 1.338);\n *     var p2 = new LatLon(50.964, 1.853);\n *     var d = p1.distanceTo(p2); // 40.31 km\n */\nfunction calculateRhumbDistance(origin, destination, radius) {\n    // φ => phi\n    // λ => lambda\n    // ψ => psi\n    // Δ => Delta\n    // δ => delta\n    // θ => theta\n    radius = radius === undefined ? earthRadius : Number(radius);\n    // see www.edwilliams.org/avform.htm#Rhumb\n    var R = radius;\n    var phi1 = (origin[1] * Math.PI) / 180;\n    var phi2 = (destination[1] * Math.PI) / 180;\n    var DeltaPhi = phi2 - phi1;\n    var DeltaLambda = (Math.abs(destination[0] - origin[0]) * Math.PI) / 180;\n    // if dLon over 180° take shorter rhumb line across the anti-meridian:\n    if (DeltaLambda > Math.PI) {\n        DeltaLambda -= 2 * Math.PI;\n    }\n    // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n    // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n    var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n    var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n    // distance is pythagoras on 'stretched' Mercator projection\n    var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda); // angular distance in radians\n    var dist = delta * R;\n    return dist;\n}\nexport default rhumbDistance;\n"],"mappings":"AAAA;AACA,SAASA,aAAa,EAAEC,WAAW,QAAQ,eAAe;AAC1D,SAASC,QAAQ,QAAQ,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACC,IAAI,EAAEC,EAAE,EAAEC,OAAO,EAAE;EACtC,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC,IAAIC,MAAM,GAAGL,QAAQ,CAACE,IAAI,CAAC;EAC3B,IAAII,WAAW,GAAGN,QAAQ,CAACG,EAAE,CAAC;EAC9B;EACA;EACAG,WAAW,CAAC,CAAC,CAAC,IACVA,WAAW,CAAC,CAAC,CAAC,GAAGD,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,GAC1B,CAAC,GAAG,GACJA,MAAM,CAAC,CAAC,CAAC,GAAGC,WAAW,CAAC,CAAC,CAAC,GAAG,GAAG,GAC5B,GAAG,GACH,CAAC;EACf,IAAIC,gBAAgB,GAAGC,sBAAsB,CAACH,MAAM,EAAEC,WAAW,CAAC;EAClE,IAAIG,QAAQ,GAAGX,aAAa,CAACS,gBAAgB,EAAE,QAAQ,EAAEH,OAAO,CAACM,KAAK,CAAC;EACvE,OAAOD,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,sBAAsBA,CAACH,MAAM,EAAEC,WAAW,EAAEK,MAAM,EAAE;EACzD;EACA;EACA;EACA;EACA;EACA;EACAA,MAAM,GAAGA,MAAM,KAAKC,SAAS,GAAGb,WAAW,GAAGc,MAAM,CAACF,MAAM,CAAC;EAC5D;EACA,IAAIG,CAAC,GAAGH,MAAM;EACd,IAAII,IAAI,GAAIV,MAAM,CAAC,CAAC,CAAC,GAAGW,IAAI,CAACC,EAAE,GAAI,GAAG;EACtC,IAAIC,IAAI,GAAIZ,WAAW,CAAC,CAAC,CAAC,GAAGU,IAAI,CAACC,EAAE,GAAI,GAAG;EAC3C,IAAIE,QAAQ,GAAGD,IAAI,GAAGH,IAAI;EAC1B,IAAIK,WAAW,GAAIJ,IAAI,CAACK,GAAG,CAACf,WAAW,CAAC,CAAC,CAAC,GAAGD,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGW,IAAI,CAACC,EAAE,GAAI,GAAG;EACxE;EACA,IAAIG,WAAW,GAAGJ,IAAI,CAACC,EAAE,EAAE;IACvBG,WAAW,IAAI,CAAC,GAAGJ,IAAI,CAACC,EAAE;EAC9B;EACA;EACA;EACA,IAAIK,QAAQ,GAAGN,IAAI,CAACO,GAAG,CAACP,IAAI,CAACQ,GAAG,CAACN,IAAI,GAAG,CAAC,GAAGF,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC,GAAGD,IAAI,CAACQ,GAAG,CAACT,IAAI,GAAG,CAAC,GAAGC,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC,CAAC;EAC5F,IAAIQ,CAAC,GAAGT,IAAI,CAACK,GAAG,CAACC,QAAQ,CAAC,GAAG,MAAM,GAAGH,QAAQ,GAAGG,QAAQ,GAAGN,IAAI,CAACU,GAAG,CAACX,IAAI,CAAC;EAC1E;EACA,IAAIY,KAAK,GAAGX,IAAI,CAACY,IAAI,CAACT,QAAQ,GAAGA,QAAQ,GAAGM,CAAC,GAAGA,CAAC,GAAGL,WAAW,GAAGA,WAAW,CAAC,CAAC,CAAC;EAChF,IAAIS,IAAI,GAAGF,KAAK,GAAGb,CAAC;EACpB,OAAOe,IAAI;AACf;AACA,eAAe5B,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}