{"ast":null,"code":"import { coordAll, featureEach } from '@turf/meta';\nimport { getCoords } from '@turf/invariant';\nimport { isObject, isNumber, featureCollection } from '@turf/helpers';\nimport centerMean from '@turf/center-mean';\nimport pointsWithinPolygon from '@turf/points-within-polygon';\nimport ellipse from '@turf/ellipse';\n\n/**\n * Takes a {@link FeatureCollection} and returns a standard deviational ellipse,\n * also known as a “directional distribution.” The standard deviational ellipse\n * aims to show the direction and the distribution of a dataset by drawing\n * an ellipse that contains about one standard deviation’s worth (~ 70%) of the\n * data.\n *\n * This module mirrors the functionality of [Directional Distribution](http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-statistics-toolbox/directional-distribution.htm)\n * in ArcGIS and the [QGIS Standard Deviational Ellipse Plugin](http://arken.nmbu.no/~havatv/gis/qgisplugins/SDEllipse/)\n *\n * **Bibliography**\n *\n * • Robert S. Yuill, “The Standard Deviational Ellipse; An Updated Tool for\n * Spatial Description,” _Geografiska Annaler_ 53, no. 1 (1971): 28–39,\n * doi:{@link https://doi.org/10.2307/490885|10.2307/490885}.\n *\n * • Paul Hanly Furfey, “A Note on Lefever’s “Standard Deviational Ellipse,”\n * _American Journal of Sociology_ 33, no. 1 (1927): 94—98,\n * doi:{@link https://doi.org/10.1086/214336|10.1086/214336}.\n *\n *\n * @name standardDeviationalEllipse\n * @param {FeatureCollection<Point>} points GeoJSON points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.weight] the property name used to weight the center\n * @param {number} [options.steps=64] number of steps for the polygon\n * @param {Object} [options.properties={}] properties to pass to the resulting ellipse\n * @returns {Feature<Polygon>} an elliptical Polygon that includes approximately 1 SD of the dataset within it.\n * @example\n *\n * var bbox = [-74, 40.72, -73.98, 40.74];\n * var points = turf.randomPoint(400, {bbox: bbox});\n * var sdEllipse = turf.standardDeviationalEllipse(points);\n *\n * //addToMap\n * var addToMap = [points, sdEllipse];\n *\n */\nfunction standardDeviationalEllipse(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var steps = options.steps || 64;\n  var weightTerm = options.weight;\n  var properties = options.properties || {};\n\n  // Validation:\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isObject(properties)) throw new Error(\"properties must be a number\");\n\n  // Calculate mean center & number of features:\n  var numberOfFeatures = coordAll(points).length;\n  var meanCenter = centerMean(points, {\n    weight: weightTerm\n  });\n\n  // Calculate angle of rotation:\n  // [X, Y] = mean center of all [x, y].\n  // theta = arctan( (A + B) / C )\n  // A = sum((x - X)^2) - sum((y - Y)^2)\n  // B = sqrt(A^2 + 4(sum((x - X)(y - Y))^2))\n  // C = 2(sum((x - X)(y - Y)))\n\n  var xDeviationSquaredSum = 0;\n  var yDeviationSquaredSum = 0;\n  var xyDeviationSum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;\n    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;\n    xyDeviationSum += deviation.x * deviation.y * weight;\n  });\n  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;\n  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));\n  var bigC = 2 * xyDeviationSum;\n  var theta = Math.atan((bigA + bigB) / bigC);\n  var thetaDeg = theta * 180 / Math.PI;\n\n  // Calculate axes:\n  // sigmaX = sqrt((1 / n - 2) * sum((((x - X) * cos(theta)) - ((y - Y) * sin(theta)))^2))\n  // sigmaY = sqrt((1 / n - 2) * sum((((x - X) * sin(theta)) - ((y - Y) * cos(theta)))^2))\n  var sigmaXsum = 0;\n  var sigmaYsum = 0;\n  var weightsum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    sigmaXsum += Math.pow(deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta), 2) * weight;\n    sigmaYsum += Math.pow(deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta), 2) * weight;\n    weightsum += weight;\n  });\n  var sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);\n  var sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);\n  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {\n    units: \"degrees\",\n    angle: thetaDeg,\n    steps: steps,\n    properties: properties\n  });\n  var pointsWithinEllipse = pointsWithinPolygon(points, featureCollection([theEllipse]));\n  var standardDeviationalEllipseProperties = {\n    meanCenterCoordinates: getCoords(meanCenter),\n    semiMajorAxis: sigmaX,\n    semiMinorAxis: sigmaY,\n    numberOfFeatures: numberOfFeatures,\n    angle: thetaDeg,\n    percentageWithinEllipse: 100 * coordAll(pointsWithinEllipse).length / numberOfFeatures\n  };\n  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;\n  return theEllipse;\n}\n\n/**\n * Get x_i - X and y_i - Y\n *\n * @private\n * @param {Array} coordinates Array of [x_i, y_i]\n * @param {Array} center Array of [X, Y]\n * @returns {Object} { x: n, y: m }\n */\nfunction getDeviations(coordinates, center) {\n  return {\n    x: coordinates[0] - center[0],\n    y: coordinates[1] - center[1]\n  };\n}\nexport default standardDeviationalEllipse;","map":{"version":3,"names":["coordAll","featureEach","getCoords","isObject","isNumber","featureCollection","centerMean","pointsWithinPolygon","ellipse","standardDeviationalEllipse","points","options","Error","steps","weightTerm","weight","properties","numberOfFeatures","length","meanCenter","xDeviationSquaredSum","yDeviationSquaredSum","xyDeviationSum","point","deviation","getDeviations","Math","pow","x","y","bigA","bigB","sqrt","bigC","theta","atan","thetaDeg","PI","sigmaXsum","sigmaYsum","weightsum","cos","sin","sigmaX","sigmaY","theEllipse","units","angle","pointsWithinEllipse","standardDeviationalEllipseProperties","meanCenterCoordinates","semiMajorAxis","semiMinorAxis","percentageWithinEllipse","coordinates","center"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/standard-deviational-ellipse/dist/es/index.js"],"sourcesContent":["import { coordAll, featureEach } from '@turf/meta';\nimport { getCoords } from '@turf/invariant';\nimport { isObject, isNumber, featureCollection } from '@turf/helpers';\nimport centerMean from '@turf/center-mean';\nimport pointsWithinPolygon from '@turf/points-within-polygon';\nimport ellipse from '@turf/ellipse';\n\n/**\n * Takes a {@link FeatureCollection} and returns a standard deviational ellipse,\n * also known as a “directional distribution.” The standard deviational ellipse\n * aims to show the direction and the distribution of a dataset by drawing\n * an ellipse that contains about one standard deviation’s worth (~ 70%) of the\n * data.\n *\n * This module mirrors the functionality of [Directional Distribution](http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-statistics-toolbox/directional-distribution.htm)\n * in ArcGIS and the [QGIS Standard Deviational Ellipse Plugin](http://arken.nmbu.no/~havatv/gis/qgisplugins/SDEllipse/)\n *\n * **Bibliography**\n *\n * • Robert S. Yuill, “The Standard Deviational Ellipse; An Updated Tool for\n * Spatial Description,” _Geografiska Annaler_ 53, no. 1 (1971): 28–39,\n * doi:{@link https://doi.org/10.2307/490885|10.2307/490885}.\n *\n * • Paul Hanly Furfey, “A Note on Lefever’s “Standard Deviational Ellipse,”\n * _American Journal of Sociology_ 33, no. 1 (1927): 94—98,\n * doi:{@link https://doi.org/10.1086/214336|10.1086/214336}.\n *\n *\n * @name standardDeviationalEllipse\n * @param {FeatureCollection<Point>} points GeoJSON points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.weight] the property name used to weight the center\n * @param {number} [options.steps=64] number of steps for the polygon\n * @param {Object} [options.properties={}] properties to pass to the resulting ellipse\n * @returns {Feature<Polygon>} an elliptical Polygon that includes approximately 1 SD of the dataset within it.\n * @example\n *\n * var bbox = [-74, 40.72, -73.98, 40.74];\n * var points = turf.randomPoint(400, {bbox: bbox});\n * var sdEllipse = turf.standardDeviationalEllipse(points);\n *\n * //addToMap\n * var addToMap = [points, sdEllipse];\n *\n */\nfunction standardDeviationalEllipse(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var steps = options.steps || 64;\n  var weightTerm = options.weight;\n  var properties = options.properties || {};\n\n  // Validation:\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isObject(properties)) throw new Error(\"properties must be a number\");\n\n  // Calculate mean center & number of features:\n  var numberOfFeatures = coordAll(points).length;\n  var meanCenter = centerMean(points, { weight: weightTerm });\n\n  // Calculate angle of rotation:\n  // [X, Y] = mean center of all [x, y].\n  // theta = arctan( (A + B) / C )\n  // A = sum((x - X)^2) - sum((y - Y)^2)\n  // B = sqrt(A^2 + 4(sum((x - X)(y - Y))^2))\n  // C = 2(sum((x - X)(y - Y)))\n\n  var xDeviationSquaredSum = 0;\n  var yDeviationSquaredSum = 0;\n  var xyDeviationSum = 0;\n\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;\n    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;\n    xyDeviationSum += deviation.x * deviation.y * weight;\n  });\n\n  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;\n  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));\n  var bigC = 2 * xyDeviationSum;\n  var theta = Math.atan((bigA + bigB) / bigC);\n  var thetaDeg = (theta * 180) / Math.PI;\n\n  // Calculate axes:\n  // sigmaX = sqrt((1 / n - 2) * sum((((x - X) * cos(theta)) - ((y - Y) * sin(theta)))^2))\n  // sigmaY = sqrt((1 / n - 2) * sum((((x - X) * sin(theta)) - ((y - Y) * cos(theta)))^2))\n  var sigmaXsum = 0;\n  var sigmaYsum = 0;\n  var weightsum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    sigmaXsum +=\n      Math.pow(\n        deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),\n        2\n      ) * weight;\n    sigmaYsum +=\n      Math.pow(\n        deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),\n        2\n      ) * weight;\n    weightsum += weight;\n  });\n\n  var sigmaX = Math.sqrt((2 * sigmaXsum) / weightsum);\n  var sigmaY = Math.sqrt((2 * sigmaYsum) / weightsum);\n\n  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {\n    units: \"degrees\",\n    angle: thetaDeg,\n    steps: steps,\n    properties: properties,\n  });\n  var pointsWithinEllipse = pointsWithinPolygon(\n    points,\n    featureCollection([theEllipse])\n  );\n  var standardDeviationalEllipseProperties = {\n    meanCenterCoordinates: getCoords(meanCenter),\n    semiMajorAxis: sigmaX,\n    semiMinorAxis: sigmaY,\n    numberOfFeatures: numberOfFeatures,\n    angle: thetaDeg,\n    percentageWithinEllipse:\n      (100 * coordAll(pointsWithinEllipse).length) / numberOfFeatures,\n  };\n  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;\n\n  return theEllipse;\n}\n\n/**\n * Get x_i - X and y_i - Y\n *\n * @private\n * @param {Array} coordinates Array of [x_i, y_i]\n * @param {Array} center Array of [X, Y]\n * @returns {Object} { x: n, y: m }\n */\nfunction getDeviations(coordinates, center) {\n  return {\n    x: coordinates[0] - center[0],\n    y: coordinates[1] - center[1],\n  };\n}\n\nexport default standardDeviationalEllipse;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}