{"ast":null,"code":"import { isObject, featureCollection, polygon } from '@turf/helpers';\nimport { collectionOf } from '@turf/invariant';\nimport { voronoi as voronoi$1 } from 'd3-voronoi';\n\n/**\n * @private\n * @param {Array<Array<number>>} coords representing a polygon\n * @returns {Feature<Polygon>} polygon\n */\nfunction coordsToPolygon(coords) {\n  coords = coords.slice();\n  coords.push(coords[0]);\n  return polygon([coords]);\n}\n\n/**\n * Takes a FeatureCollection of points, and a bounding box, and returns a FeatureCollection\n * of Voronoi polygons.\n *\n * The Voronoi algorithim used comes from the d3-voronoi package.\n *\n * @name voronoi\n * @param {FeatureCollection<Point>} points to find the Voronoi polygons around.\n * @param {Object} [options={}] Optional parameters\n * @param {number[]} [options.bbox=[-180, -85, 180, -85]] clipping rectangle, in [minX, minY, maxX, MaxY] order.\n * @returns {FeatureCollection<Polygon>} a set of polygons, one per input point.\n * @example\n * var options = {\n *   bbox: [-70, 40, -60, 60]\n * };\n * var points = turf.randomPoint(100, options);\n * var voronoiPolygons = turf.voronoi(points, options);\n *\n * //addToMap\n * var addToMap = [voronoiPolygons, points];\n */\nfunction voronoi(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var bbox = options.bbox || [-180, -85, 180, 85];\n\n  // Input Validation\n  if (!points) throw new Error(\"points is required\");\n  if (!Array.isArray(bbox)) throw new Error(\"bbox is invalid\");\n  collectionOf(points, \"Point\", \"points\");\n\n  // Main\n  return featureCollection(voronoi$1().x(function (feature) {\n    return feature.geometry.coordinates[0];\n  }).y(function (feature) {\n    return feature.geometry.coordinates[1];\n  }).extent([[bbox[0], bbox[1]], [bbox[2], bbox[3]]]).polygons(points.features).map(coordsToPolygon));\n}\nexport default voronoi;","map":{"version":3,"names":["isObject","featureCollection","polygon","collectionOf","voronoi","voronoi$1","coordsToPolygon","coords","slice","push","points","options","Error","bbox","Array","isArray","x","feature","geometry","coordinates","y","extent","polygons","features","map"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/voronoi/dist/es/index.js"],"sourcesContent":["import { isObject, featureCollection, polygon } from '@turf/helpers';\nimport { collectionOf } from '@turf/invariant';\nimport { voronoi as voronoi$1 } from 'd3-voronoi';\n\n/**\n * @private\n * @param {Array<Array<number>>} coords representing a polygon\n * @returns {Feature<Polygon>} polygon\n */\nfunction coordsToPolygon(coords) {\n  coords = coords.slice();\n  coords.push(coords[0]);\n  return polygon([coords]);\n}\n\n/**\n * Takes a FeatureCollection of points, and a bounding box, and returns a FeatureCollection\n * of Voronoi polygons.\n *\n * The Voronoi algorithim used comes from the d3-voronoi package.\n *\n * @name voronoi\n * @param {FeatureCollection<Point>} points to find the Voronoi polygons around.\n * @param {Object} [options={}] Optional parameters\n * @param {number[]} [options.bbox=[-180, -85, 180, -85]] clipping rectangle, in [minX, minY, maxX, MaxY] order.\n * @returns {FeatureCollection<Polygon>} a set of polygons, one per input point.\n * @example\n * var options = {\n *   bbox: [-70, 40, -60, 60]\n * };\n * var points = turf.randomPoint(100, options);\n * var voronoiPolygons = turf.voronoi(points, options);\n *\n * //addToMap\n * var addToMap = [voronoiPolygons, points];\n */\nfunction voronoi(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var bbox = options.bbox || [-180, -85, 180, 85];\n\n  // Input Validation\n  if (!points) throw new Error(\"points is required\");\n  if (!Array.isArray(bbox)) throw new Error(\"bbox is invalid\");\n  collectionOf(points, \"Point\", \"points\");\n\n  // Main\n  return featureCollection(\n    voronoi$1()\n      .x(function (feature) {\n        return feature.geometry.coordinates[0];\n      })\n      .y(function (feature) {\n        return feature.geometry.coordinates[1];\n      })\n      .extent([\n        [bbox[0], bbox[1]],\n        [bbox[2], bbox[3]],\n      ])\n      .polygons(points.features)\n      .map(coordsToPolygon)\n  );\n}\n\nexport default voronoi;\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,iBAAiB,EAAEC,OAAO,QAAQ,eAAe;AACpE,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,OAAO,IAAIC,SAAS,QAAQ,YAAY;;AAEjD;AACA;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,MAAM,EAAE;EAC/BA,MAAM,GAAGA,MAAM,CAACC,KAAK,CAAC,CAAC;EACvBD,MAAM,CAACE,IAAI,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;EACtB,OAAOL,OAAO,CAAC,CAACK,MAAM,CAAC,CAAC;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASH,OAAOA,CAACM,MAAM,EAAEC,OAAO,EAAE;EAChC;EACAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAI,CAACX,QAAQ,CAACW,OAAO,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EAC7D,IAAIC,IAAI,GAAGF,OAAO,CAACE,IAAI,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC;;EAE/C;EACA,IAAI,CAACH,MAAM,EAAE,MAAM,IAAIE,KAAK,CAAC,oBAAoB,CAAC;EAClD,IAAI,CAACE,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE,MAAM,IAAID,KAAK,CAAC,iBAAiB,CAAC;EAC5DT,YAAY,CAACO,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC;;EAEvC;EACA,OAAOT,iBAAiB,CACtBI,SAAS,CAAC,CAAC,CACRW,CAAC,CAAC,UAAUC,OAAO,EAAE;IACpB,OAAOA,OAAO,CAACC,QAAQ,CAACC,WAAW,CAAC,CAAC,CAAC;EACxC,CAAC,CAAC,CACDC,CAAC,CAAC,UAAUH,OAAO,EAAE;IACpB,OAAOA,OAAO,CAACC,QAAQ,CAACC,WAAW,CAAC,CAAC,CAAC;EACxC,CAAC,CAAC,CACDE,MAAM,CAAC,CACN,CAACR,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,EAClB,CAACA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CACnB,CAAC,CACDS,QAAQ,CAACZ,MAAM,CAACa,QAAQ,CAAC,CACzBC,GAAG,CAAClB,eAAe,CACxB,CAAC;AACH;AAEA,eAAeF,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}