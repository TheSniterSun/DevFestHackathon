{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n  centimeters: exports.earthRadius * 100,\n  centimetres: exports.earthRadius * 100,\n  degrees: exports.earthRadius / 111325,\n  feet: exports.earthRadius * 3.28084,\n  inches: exports.earthRadius * 39.37,\n  kilometers: exports.earthRadius / 1000,\n  kilometres: exports.earthRadius / 1000,\n  meters: exports.earthRadius,\n  metres: exports.earthRadius,\n  miles: exports.earthRadius / 1609.344,\n  millimeters: exports.earthRadius * 1000,\n  millimetres: exports.earthRadius * 1000,\n  nauticalmiles: exports.earthRadius / 1852,\n  radians: 1,\n  yards: exports.earthRadius * 1.0936\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n  centimeters: 100,\n  centimetres: 100,\n  degrees: 1 / 111325,\n  feet: 3.28084,\n  inches: 39.37,\n  kilometers: 1 / 1000,\n  kilometres: 1 / 1000,\n  meters: 1,\n  metres: 1,\n  miles: 1 / 1609.344,\n  millimeters: 1000,\n  millimetres: 1000,\n  nauticalmiles: 1 / 1852,\n  radians: 1 / exports.earthRadius,\n  yards: 1.0936133\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var feat = {\n    type: \"Feature\"\n  };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n  if (_options === void 0) {\n    _options = {};\n  }\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  var geom = {\n    type: \"Point\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return point(coords, properties);\n  }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n    var ring = coordinates_1[_i];\n    if (ring.length < 4) {\n      throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n    }\n    for (var j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  var geom = {\n    type: \"Polygon\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return polygon(coords, properties);\n  }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  var geom = {\n    type: \"LineString\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return featureCollection(coordinates.map(function (coords) {\n    return lineString(coords, properties);\n  }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var fc = {\n    type: \"FeatureCollection\"\n  };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiLineString\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiPoint\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"MultiPolygon\",\n    coordinates: coordinates\n  };\n  return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var geom = {\n    type: \"GeometryCollection\",\n    geometries: geometries\n  };\n  return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  var multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n  var factor = exports.factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n  if (units === void 0) {\n    units = \"kilometers\";\n  }\n  var factor = exports.factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n  var angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n  var degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n  var radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"kilometers\";\n  }\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n  if (originalUnit === void 0) {\n    originalUnit = \"meters\";\n  }\n  if (finalUnit === void 0) {\n    finalUnit = \"kilometers\";\n  }\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  var startFactor = exports.areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  var finalFactor = exports.areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n  return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach(function (num) {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexports.validateId = validateId;","map":{"version":3,"names":["Object","defineProperty","exports","value","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","unitsFactors","areaFactors","acres","hectares","feature","geom","properties","options","feat","type","id","bbox","geometry","coordinates","_options","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","Error","Array","isArray","length","isNumber","points","featureCollection","map","coords","_i","coordinates_1","ring","j","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","multiplier","Math","pow","radiansToLength","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","PI","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isNaN","isObject","input","constructor","validateBBox","forEach","validateId","indexOf"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/helpers/dist/js/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.37,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}