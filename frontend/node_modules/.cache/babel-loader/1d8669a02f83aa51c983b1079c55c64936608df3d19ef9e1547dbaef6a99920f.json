{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n})(this, function () {\n  'use strict';\n\n  /**\n   * splaytree v3.1.2\n   * Fast Splay tree for Node and browser\n   *\n   * @author Alexander Milevski <info@w8r.name>\n   * @license MIT\n   * @preserve\n   */\n\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n  function __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function () {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n      f,\n      y,\n      t,\n      g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (_) try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2]) _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  }\n  var Node = /** @class */function () {\n    function Node(key, data) {\n      this.next = null;\n      this.key = key;\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n    return Node;\n  }();\n\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\n  function DEFAULT_COMPARE(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\n  function splay(i, t, comparator) {\n    var N = new Node(null, null);\n    var l = N;\n    var r = N;\n    while (true) {\n      var cmp = comparator(i, t.key);\n      //if (i < t.key) {\n      if (cmp < 0) {\n        if (t.left === null) break;\n        //if (i < t.left.key) {\n        if (comparator(i, t.left.key) < 0) {\n          var y = t.left; /* rotate right */\n          t.left = y.right;\n          y.right = t;\n          t = y;\n          if (t.left === null) break;\n        }\n        r.left = t; /* link right */\n        r = t;\n        t = t.left;\n        //} else if (i > t.key) {\n      } else if (cmp > 0) {\n        if (t.right === null) break;\n        //if (i > t.right.key) {\n        if (comparator(i, t.right.key) > 0) {\n          var y = t.right; /* rotate left */\n          t.right = y.left;\n          y.left = t;\n          t = y;\n          if (t.right === null) break;\n        }\n        l.right = t; /* link left */\n        l = t;\n        t = t.right;\n      } else break;\n    }\n    /* assemble */\n    l.right = t.left;\n    r.left = t.right;\n    t.left = N.right;\n    t.right = N.left;\n    return t;\n  }\n  function insert(i, data, t, comparator) {\n    var node = new Node(i, data);\n    if (t === null) {\n      node.left = node.right = null;\n      return node;\n    }\n    t = splay(i, t, comparator);\n    var cmp = comparator(i, t.key);\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp >= 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n    return node;\n  }\n  function split(key, v, comparator) {\n    var left = null;\n    var right = null;\n    if (v) {\n      v = splay(key, v, comparator);\n      var cmp = comparator(v.key, key);\n      if (cmp === 0) {\n        left = v.left;\n        right = v.right;\n      } else if (cmp < 0) {\n        right = v.right;\n        v.right = null;\n        left = v;\n      } else {\n        left = v.left;\n        v.left = null;\n        right = v;\n      }\n    }\n    return {\n      left: left,\n      right: right\n    };\n  }\n  function merge(left, right, comparator) {\n    if (right === null) return left;\n    if (left === null) return right;\n    right = splay(left.key, right, comparator);\n    right.left = left;\n    return right;\n  }\n  /**\r\n   * Prints level of the tree\r\n   */\n  function printRow(root, prefix, isTail, out, printNode) {\n    if (root) {\n      out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n      var indent = prefix + (isTail ? '    ' : '│   ');\n      if (root.left) printRow(root.left, indent, false, out, printNode);\n      if (root.right) printRow(root.right, indent, true, out, printNode);\n    }\n  }\n  var Tree = /** @class */function () {\n    function Tree(comparator) {\n      if (comparator === void 0) {\n        comparator = DEFAULT_COMPARE;\n      }\n      this._root = null;\n      this._size = 0;\n      this._comparator = comparator;\n    }\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\n    Tree.prototype.insert = function (key, data) {\n      this._size++;\n      return this._root = insert(key, data, this._root, this._comparator);\n    };\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\n    Tree.prototype.add = function (key, data) {\n      var node = new Node(key, data);\n      if (this._root === null) {\n        node.left = node.right = null;\n        this._size++;\n        this._root = node;\n      }\n      var comparator = this._comparator;\n      var t = splay(key, this._root, comparator);\n      var cmp = comparator(key, t.key);\n      if (cmp === 0) this._root = t;else {\n        if (cmp < 0) {\n          node.left = t.left;\n          node.right = t;\n          t.left = null;\n        } else if (cmp > 0) {\n          node.right = t.right;\n          node.left = t;\n          t.right = null;\n        }\n        this._size++;\n        this._root = node;\n      }\n      return this._root;\n    };\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\n    Tree.prototype.remove = function (key) {\n      this._root = this._remove(key, this._root, this._comparator);\n    };\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\n    Tree.prototype._remove = function (i, t, comparator) {\n      var x;\n      if (t === null) return null;\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n      if (cmp === 0) {\n        /* found it */\n        if (t.left === null) {\n          x = t.right;\n        } else {\n          x = splay(i, t.left, comparator);\n          x.right = t.right;\n        }\n        this._size--;\n        return x;\n      }\n      return t; /* It wasn't there */\n    };\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\n    Tree.prototype.pop = function () {\n      var node = this._root;\n      if (node) {\n        while (node.left) node = node.left;\n        this._root = splay(node.key, this._root, this._comparator);\n        this._root = this._remove(node.key, this._root, this._comparator);\n        return {\n          key: node.key,\n          data: node.data\n        };\n      }\n      return null;\n    };\n    /**\r\n     * Find without splaying\r\n     */\n    Tree.prototype.findStatic = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n      return null;\n    };\n    Tree.prototype.find = function (key) {\n      if (this._root) {\n        this._root = splay(key, this._root, this._comparator);\n        if (this._comparator(key, this._root.key) !== 0) return null;\n      }\n      return this._root;\n    };\n    Tree.prototype.contains = function (key) {\n      var current = this._root;\n      var compare = this._comparator;\n      while (current) {\n        var cmp = compare(key, current.key);\n        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n      }\n      return false;\n    };\n    Tree.prototype.forEach = function (visitor, ctx) {\n      var current = this._root;\n      var Q = []; /* Initialize stack s */\n      var done = false;\n      while (!done) {\n        if (current !== null) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length !== 0) {\n            current = Q.pop();\n            visitor.call(ctx, current);\n            current = current.right;\n          } else done = true;\n        }\n      }\n      return this;\n    };\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\n    Tree.prototype.range = function (low, high, fn, ctx) {\n      var Q = [];\n      var compare = this._comparator;\n      var node = this._root;\n      var cmp;\n      while (Q.length !== 0 || node) {\n        if (node) {\n          Q.push(node);\n          node = node.left;\n        } else {\n          node = Q.pop();\n          cmp = compare(node.key, high);\n          if (cmp > 0) {\n            break;\n          } else if (compare(node.key, low) >= 0) {\n            if (fn.call(ctx, node)) return this; // stop if smth is returned\n          }\n          node = node.right;\n        }\n      }\n      return this;\n    };\n    /**\r\n     * Returns array of keys\r\n     */\n    Tree.prototype.keys = function () {\n      var keys = [];\n      this.forEach(function (_a) {\n        var key = _a.key;\n        return keys.push(key);\n      });\n      return keys;\n    };\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\n    Tree.prototype.values = function () {\n      var values = [];\n      this.forEach(function (_a) {\n        var data = _a.data;\n        return values.push(data);\n      });\n      return values;\n    };\n    Tree.prototype.min = function () {\n      if (this._root) return this.minNode(this._root).key;\n      return null;\n    };\n    Tree.prototype.max = function () {\n      if (this._root) return this.maxNode(this._root).key;\n      return null;\n    };\n    Tree.prototype.minNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n      if (t) while (t.left) t = t.left;\n      return t;\n    };\n    Tree.prototype.maxNode = function (t) {\n      if (t === void 0) {\n        t = this._root;\n      }\n      if (t) while (t.right) t = t.right;\n      return t;\n    };\n    /**\r\n     * Returns node at given index\r\n     */\n    Tree.prototype.at = function (index) {\n      var current = this._root;\n      var done = false;\n      var i = 0;\n      var Q = [];\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = Q.pop();\n            if (i === index) return current;\n            i++;\n            current = current.right;\n          } else done = true;\n        }\n      }\n      return null;\n    };\n    Tree.prototype.next = function (d) {\n      var root = this._root;\n      var successor = null;\n      if (d.right) {\n        successor = d.right;\n        while (successor.left) successor = successor.left;\n        return successor;\n      }\n      var comparator = this._comparator;\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) {\n          successor = root;\n          root = root.left;\n        } else root = root.right;\n      }\n      return successor;\n    };\n    Tree.prototype.prev = function (d) {\n      var root = this._root;\n      var predecessor = null;\n      if (d.left !== null) {\n        predecessor = d.left;\n        while (predecessor.right) predecessor = predecessor.right;\n        return predecessor;\n      }\n      var comparator = this._comparator;\n      while (root) {\n        var cmp = comparator(d.key, root.key);\n        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n          predecessor = root;\n          root = root.right;\n        }\n      }\n      return predecessor;\n    };\n    Tree.prototype.clear = function () {\n      this._root = null;\n      this._size = 0;\n      return this;\n    };\n    Tree.prototype.toList = function () {\n      return toList(this._root);\n    };\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\n    Tree.prototype.load = function (keys, values, presort) {\n      if (values === void 0) {\n        values = [];\n      }\n      if (presort === void 0) {\n        presort = false;\n      }\n      var size = keys.length;\n      var comparator = this._comparator;\n      // sort if needed\n      if (presort) sort(keys, values, 0, size - 1, comparator);\n      if (this._root === null) {\n        // empty tree\n        this._root = loadRecursive(keys, values, 0, size);\n        this._size = size;\n      } else {\n        // that re-builds the whole tree from two in-order traversals\n        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n        size = this._size + size;\n        this._root = sortedListToBST({\n          head: mergedList\n        }, 0, size);\n      }\n      return this;\n    };\n    Tree.prototype.isEmpty = function () {\n      return this._root === null;\n    };\n    Object.defineProperty(Tree.prototype, \"size\", {\n      get: function () {\n        return this._size;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Tree.prototype, \"root\", {\n      get: function () {\n        return this._root;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Tree.prototype.toString = function (printNode) {\n      if (printNode === void 0) {\n        printNode = function (n) {\n          return String(n.key);\n        };\n      }\n      var out = [];\n      printRow(this._root, '', true, function (v) {\n        return out.push(v);\n      }, printNode);\n      return out.join('');\n    };\n    Tree.prototype.update = function (key, newKey, newData) {\n      var comparator = this._comparator;\n      var _a = split(key, this._root, comparator),\n        left = _a.left,\n        right = _a.right;\n      if (comparator(key, newKey) < 0) {\n        right = insert(newKey, newData, right, comparator);\n      } else {\n        left = insert(newKey, newData, left, comparator);\n      }\n      this._root = merge(left, right, comparator);\n    };\n    Tree.prototype.split = function (key) {\n      return split(key, this._root, this._comparator);\n    };\n    Tree.prototype[Symbol.iterator] = function () {\n      var current, Q, done;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            current = this._root;\n            Q = [];\n            done = false;\n            _a.label = 1;\n          case 1:\n            if (!!done) return [3 /*break*/, 6];\n            if (!(current !== null)) return [3 /*break*/, 2];\n            Q.push(current);\n            current = current.left;\n            return [3 /*break*/, 5];\n          case 2:\n            if (!(Q.length !== 0)) return [3 /*break*/, 4];\n            current = Q.pop();\n            return [4 /*yield*/, current];\n          case 3:\n            _a.sent();\n            current = current.right;\n            return [3 /*break*/, 5];\n          case 4:\n            done = true;\n            _a.label = 5;\n          case 5:\n            return [3 /*break*/, 1];\n          case 6:\n            return [2 /*return*/];\n        }\n      });\n    };\n    return Tree;\n  }();\n  function loadRecursive(keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key = keys[middle];\n      var data = values[middle];\n      var node = new Node(key, data);\n      node.left = loadRecursive(keys, values, start, middle);\n      node.right = loadRecursive(keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n  function createList(keys, values) {\n    var head = new Node(null, null);\n    var p = head;\n    for (var i = 0; i < keys.length; i++) {\n      p = p.next = new Node(keys[i], values[i]);\n    }\n    p.next = null;\n    return head.next;\n  }\n  function toList(root) {\n    var current = root;\n    var Q = [];\n    var done = false;\n    var head = new Node(null, null);\n    var p = head;\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = p = p.next = Q.pop();\n          current = current.right;\n        } else done = true;\n      }\n    }\n    p.next = null; // that'll work even if the tree was empty\n    return head.next;\n  }\n  function sortedListToBST(list, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var left = sortedListToBST(list, start, middle);\n      var root = list.head;\n      root.left = left;\n      list.head = list.head.next;\n      root.right = sortedListToBST(list, middle + 1, end);\n      return root;\n    }\n    return null;\n  }\n  function mergeLists(l1, l2, compare) {\n    var head = new Node(null, null); // dummy\n    var p = head;\n    var p1 = l1;\n    var p2 = l2;\n    while (p1 !== null && p2 !== null) {\n      if (compare(p1.key, p2.key) < 0) {\n        p.next = p1;\n        p1 = p1.next;\n      } else {\n        p.next = p2;\n        p2 = p2.next;\n      }\n      p = p.next;\n    }\n    if (p1 !== null) {\n      p.next = p1;\n    } else if (p2 !== null) {\n      p.next = p2;\n    }\n    return head.next;\n  }\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) return;\n    var pivot = keys[left + right >> 1];\n    var i = left - 1;\n    var j = right + 1;\n    while (true) {\n      do i++; while (compare(keys[i], pivot) < 0);\n      do j--; while (compare(keys[j], pivot) > 0);\n      if (i >= j) break;\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n    sort(keys, values, left, j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  /**\n   * A bounding box has the format:\n   *\n   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n   *\n   */\n\n  const isInBbox = (bbox, point) => {\n    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n  };\n\n  /* Returns either null, or a bbox (aka an ordered pair of points)\n   * If there is only one point of overlap, a bbox with identical points\n   * will be returned */\n  const getBboxOverlap = (b1, b2) => {\n    // check if the bboxes overlap at all\n    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n\n    // find the middle two X values\n    const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n    const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n    // find the middle two Y values\n    const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n    const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n    // put those middle values together to get the overlap\n    return {\n      ll: {\n        x: lowerX,\n        y: lowerY\n      },\n      ur: {\n        x: upperX,\n        y: upperY\n      }\n    };\n  };\n\n  /* Javascript doesn't do integer math. Everything is\n   * floating point with percision Number.EPSILON.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n   */\n\n  let epsilon$1 = Number.EPSILON;\n\n  // IE Polyfill\n  if (epsilon$1 === undefined) epsilon$1 = Math.pow(2, -52);\n  const EPSILON_SQ = epsilon$1 * epsilon$1;\n\n  /* FLP comparator */\n  const cmp = (a, b) => {\n    // check if they're both 0\n    if (-epsilon$1 < a && a < epsilon$1) {\n      if (-epsilon$1 < b && b < epsilon$1) {\n        return 0;\n      }\n    }\n\n    // check if they're flp equal\n    const ab = a - b;\n    if (ab * ab < EPSILON_SQ * a * b) {\n      return 0;\n    }\n\n    // normal comparison\n    return a < b ? -1 : 1;\n  };\n\n  /**\n   * This class rounds incoming values sufficiently so that\n   * floating points problems are, for the most part, avoided.\n   *\n   * Incoming points are have their x & y values tested against\n   * all previously seen x & y values. If either is 'too close'\n   * to a previously seen value, it's value is 'snapped' to the\n   * previously seen value.\n   *\n   * All points should be rounded by this class before being\n   * stored in any data structures in the rest of this algorithm.\n   */\n\n  class PtRounder {\n    constructor() {\n      this.reset();\n    }\n    reset() {\n      this.xRounder = new CoordRounder();\n      this.yRounder = new CoordRounder();\n    }\n    round(x, y) {\n      return {\n        x: this.xRounder.round(x),\n        y: this.yRounder.round(y)\n      };\n    }\n  }\n  class CoordRounder {\n    constructor() {\n      this.tree = new Tree();\n      // preseed with 0 so we don't end up with values < Number.EPSILON\n      this.round(0);\n    }\n\n    // Note: this can rounds input values backwards or forwards.\n    //       You might ask, why not restrict this to just rounding\n    //       forwards? Wouldn't that allow left endpoints to always\n    //       remain left endpoints during splitting (never change to\n    //       right). No - it wouldn't, because we snap intersections\n    //       to endpoints (to establish independence from the segment\n    //       angle for t-intersections).\n    round(coord) {\n      const node = this.tree.add(coord);\n      const prevNode = this.tree.prev(node);\n      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n        this.tree.remove(coord);\n        return prevNode.key;\n      }\n      const nextNode = this.tree.next(node);\n      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n        this.tree.remove(coord);\n        return nextNode.key;\n      }\n      return coord;\n    }\n  }\n\n  // singleton available by import\n  const rounder = new PtRounder();\n  const epsilon = 1.1102230246251565e-16;\n  const splitter = 134217729;\n  const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n  // fast_expansion_sum_zeroelim routine from oritinal code\n  function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if (fnow > enow === fnow > -enow) {\n      Q = enow;\n      enow = e[++eindex];\n    } else {\n      Q = fnow;\n      fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n      if (fnow > enow === fnow > -enow) {\n        Qnew = enow + Q;\n        hh = Q - (Qnew - enow);\n        enow = e[++eindex];\n      } else {\n        Qnew = fnow + Q;\n        hh = Q - (Qnew - fnow);\n        fnow = f[++findex];\n      }\n      Q = Qnew;\n      if (hh !== 0) {\n        h[hindex++] = hh;\n      }\n      while (eindex < elen && findex < flen) {\n        if (fnow > enow === fnow > -enow) {\n          Qnew = Q + enow;\n          bvirt = Qnew - Q;\n          hh = Q - (Qnew - bvirt) + (enow - bvirt);\n          enow = e[++eindex];\n        } else {\n          Qnew = Q + fnow;\n          bvirt = Qnew - Q;\n          hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n          fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n          h[hindex++] = hh;\n        }\n      }\n    }\n    while (eindex < elen) {\n      Qnew = Q + enow;\n      bvirt = Qnew - Q;\n      hh = Q - (Qnew - bvirt) + (enow - bvirt);\n      enow = e[++eindex];\n      Q = Qnew;\n      if (hh !== 0) {\n        h[hindex++] = hh;\n      }\n    }\n    while (findex < flen) {\n      Qnew = Q + fnow;\n      bvirt = Qnew - Q;\n      hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n      fnow = f[++findex];\n      Q = Qnew;\n      if (hh !== 0) {\n        h[hindex++] = hh;\n      }\n    }\n    if (Q !== 0 || hindex === 0) {\n      h[hindex++] = Q;\n    }\n    return hindex;\n  }\n  function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n  }\n  function vec(n) {\n    return new Float64Array(n);\n  }\n  const ccwerrboundA = (3 + 16 * epsilon) * epsilon;\n  const ccwerrboundB = (2 + 12 * epsilon) * epsilon;\n  const ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n  const B = vec(4);\n  const C1 = vec(8);\n  const C2 = vec(12);\n  const D = vec(16);\n  const u = vec(4);\n  function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n      return det;\n    }\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n      return det;\n    }\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n    return D[Dlen - 1];\n  }\n  function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n  }\n\n  /* Cross Product of two vectors with first point at origin */\n  const crossProduct = (a, b) => a.x * b.y - a.y * b.x;\n\n  /* Dot Product of two vectors with first point at origin */\n  const dotProduct = (a, b) => a.x * b.x + a.y * b.y;\n\n  /* Comparator for two vectors with same starting point */\n  const compareVectorAngles = (basePt, endPt1, endPt2) => {\n    const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n    if (res > 0) return -1;\n    if (res < 0) return 1;\n    return 0;\n  };\n  const length = v => Math.sqrt(dotProduct(v, v));\n\n  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n  const sineOfAngle = (pShared, pBase, pAngle) => {\n    const vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    const vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n\n  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n  const cosineOfAngle = (pShared, pBase, pAngle) => {\n    const vBase = {\n      x: pBase.x - pShared.x,\n      y: pBase.y - pShared.y\n    };\n    const vAngle = {\n      x: pAngle.x - pShared.x,\n      y: pAngle.y - pShared.y\n    };\n    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n  };\n\n  /* Get the x coordinate where the given line (defined by a point and vector)\n   * crosses the horizontal line with the given y coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n  const horizontalIntersection = (pt, v, y) => {\n    if (v.y === 0) return null;\n    return {\n      x: pt.x + v.x / v.y * (y - pt.y),\n      y: y\n    };\n  };\n\n  /* Get the y coordinate where the given line (defined by a point and vector)\n   * crosses the vertical line with the given x coordiante.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n  const verticalIntersection = (pt, v, x) => {\n    if (v.x === 0) return null;\n    return {\n      x: x,\n      y: pt.y + v.y / v.x * (x - pt.x)\n    };\n  };\n\n  /* Get the intersection of two lines, each defined by a base point and a vector.\n   * In the case of parrallel lines (including overlapping ones) returns null. */\n  const intersection$1 = (pt1, v1, pt2, v2) => {\n    // take some shortcuts for vertical and horizontal lines\n    // this also ensures we don't calculate an intersection and then discover\n    // it's actually outside the bounding box of the line\n    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n    // General case for non-overlapping segments.\n    // This algorithm is based on Schneider and Eberly.\n    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n    const kross = crossProduct(v1, v2);\n    if (kross == 0) return null;\n    const ve = {\n      x: pt2.x - pt1.x,\n      y: pt2.y - pt1.y\n    };\n    const d1 = crossProduct(ve, v1) / kross;\n    const d2 = crossProduct(ve, v2) / kross;\n\n    // take the average of the two calculations to minimize rounding error\n    const x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n    const y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n    const x = (x1 + x2) / 2;\n    const y = (y1 + y2) / 2;\n    return {\n      x: x,\n      y: y\n    };\n  };\n  class SweepEvent {\n    // for ordering sweep events in the sweep event queue\n    static compare(a, b) {\n      // favor event with a point that the sweep line hits first\n      const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n      if (ptCmp !== 0) return ptCmp;\n\n      // the points are the same, so link them if needed\n      if (a.point !== b.point) a.link(b);\n\n      // favor right events over left\n      if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n      // we have two matching left or right endpoints\n      // ordering of this case is the same as for their segments\n      return Segment.compare(a.segment, b.segment);\n    }\n\n    // for ordering points in sweep line order\n    static comparePoints(aPt, bPt) {\n      if (aPt.x < bPt.x) return -1;\n      if (aPt.x > bPt.x) return 1;\n      if (aPt.y < bPt.y) return -1;\n      if (aPt.y > bPt.y) return 1;\n      return 0;\n    }\n\n    // Warning: 'point' input will be modified and re-used (for performance)\n    constructor(point, isLeft) {\n      if (point.events === undefined) point.events = [this];else point.events.push(this);\n      this.point = point;\n      this.isLeft = isLeft;\n      // this.segment, this.otherSE set by factory\n    }\n    link(other) {\n      if (other.point === this.point) {\n        throw new Error(\"Tried to link already linked events\");\n      }\n      const otherEvents = other.point.events;\n      for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n        const evt = otherEvents[i];\n        this.point.events.push(evt);\n        evt.point = this.point;\n      }\n      this.checkForConsuming();\n    }\n\n    /* Do a pass over our linked events and check to see if any pair\n     * of segments match, and should be consumed. */\n    checkForConsuming() {\n      // FIXME: The loops in this method run O(n^2) => no good.\n      //        Maintain little ordered sweep event trees?\n      //        Can we maintaining an ordering that avoids the need\n      //        for the re-sorting with getLeftmostComparator in geom-out?\n\n      // Compare each pair of events to see if other events also match\n      const numEvents = this.point.events.length;\n      for (let i = 0; i < numEvents; i++) {\n        const evt1 = this.point.events[i];\n        if (evt1.segment.consumedBy !== undefined) continue;\n        for (let j = i + 1; j < numEvents; j++) {\n          const evt2 = this.point.events[j];\n          if (evt2.consumedBy !== undefined) continue;\n          if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n          evt1.segment.consume(evt2.segment);\n        }\n      }\n    }\n    getAvailableLinkedEvents() {\n      // point.events is always of length 2 or greater\n      const events = [];\n      for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n        const evt = this.point.events[i];\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n          events.push(evt);\n        }\n      }\n      return events;\n    }\n\n    /**\n     * Returns a comparator function for sorting linked events that will\n     * favor the event that will give us the smallest left-side angle.\n     * All ring construction starts as low as possible heading to the right,\n     * so by always turning left as sharp as possible we'll get polygons\n     * without uncessary loops & holes.\n     *\n     * The comparator function has a compute cache such that it avoids\n     * re-computing already-computed values.\n     */\n    getLeftmostComparator(baseEvent) {\n      const cache = new Map();\n      const fillCache = linkedEvent => {\n        const nextEvent = linkedEvent.otherSE;\n        cache.set(linkedEvent, {\n          sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n          cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n        });\n      };\n      return (a, b) => {\n        if (!cache.has(a)) fillCache(a);\n        if (!cache.has(b)) fillCache(b);\n        const {\n          sine: asine,\n          cosine: acosine\n        } = cache.get(a);\n        const {\n          sine: bsine,\n          cosine: bcosine\n        } = cache.get(b);\n\n        // both on or above x-axis\n        if (asine >= 0 && bsine >= 0) {\n          if (acosine < bcosine) return 1;\n          if (acosine > bcosine) return -1;\n          return 0;\n        }\n\n        // both below x-axis\n        if (asine < 0 && bsine < 0) {\n          if (acosine < bcosine) return -1;\n          if (acosine > bcosine) return 1;\n          return 0;\n        }\n\n        // one above x-axis, one below\n        if (bsine < asine) return -1;\n        if (bsine > asine) return 1;\n        return 0;\n      };\n    }\n  }\n\n  // Give segments unique ID's to get consistent sorting of\n  // segments and sweep events when all else is identical\n  let segmentId = 0;\n  class Segment {\n    /* This compare() function is for ordering segments in the sweep\n     * line tree, and does so according to the following criteria:\n     *\n     * Consider the vertical line that lies an infinestimal step to the\n     * right of the right-more of the two left endpoints of the input\n     * segments. Imagine slowly moving a point up from negative infinity\n     * in the increasing y direction. Which of the two segments will that\n     * point intersect first? That segment comes 'before' the other one.\n     *\n     * If neither segment would be intersected by such a line, (if one\n     * or more of the segments are vertical) then the line to be considered\n     * is directly on the right-more of the two left inputs.\n     */\n    static compare(a, b) {\n      const alx = a.leftSE.point.x;\n      const blx = b.leftSE.point.x;\n      const arx = a.rightSE.point.x;\n      const brx = b.rightSE.point.x;\n\n      // check if they're even in the same vertical plane\n      if (brx < alx) return 1;\n      if (arx < blx) return -1;\n      const aly = a.leftSE.point.y;\n      const bly = b.leftSE.point.y;\n      const ary = a.rightSE.point.y;\n      const bry = b.rightSE.point.y;\n\n      // is left endpoint of segment B the right-more?\n      if (alx < blx) {\n        // are the two segments in the same horizontal plane?\n        if (bly < aly && bly < ary) return 1;\n        if (bly > aly && bly > ary) return -1;\n\n        // is the B left endpoint colinear to segment A?\n        const aCmpBLeft = a.comparePoint(b.leftSE.point);\n        if (aCmpBLeft < 0) return 1;\n        if (aCmpBLeft > 0) return -1;\n\n        // is the A right endpoint colinear to segment B ?\n        const bCmpARight = b.comparePoint(a.rightSE.point);\n        if (bCmpARight !== 0) return bCmpARight;\n\n        // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n        return -1;\n      }\n\n      // is left endpoint of segment A the right-more?\n      if (alx > blx) {\n        if (aly < bly && aly < bry) return -1;\n        if (aly > bly && aly > bry) return 1;\n\n        // is the A left endpoint colinear to segment B?\n        const bCmpALeft = b.comparePoint(a.leftSE.point);\n        if (bCmpALeft !== 0) return bCmpALeft;\n\n        // is the B right endpoint colinear to segment A?\n        const aCmpBRight = a.comparePoint(b.rightSE.point);\n        if (aCmpBRight < 0) return 1;\n        if (aCmpBRight > 0) return -1;\n\n        // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n        return 1;\n      }\n\n      // if we get here, the two left endpoints are in the same\n      // vertical plane, ie alx === blx\n\n      // consider the lower left-endpoint to come first\n      if (aly < bly) return -1;\n      if (aly > bly) return 1;\n\n      // left endpoints are identical\n      // check for colinearity by using the left-more right endpoint\n\n      // is the A right endpoint more left-more?\n      if (arx < brx) {\n        const bCmpARight = b.comparePoint(a.rightSE.point);\n        if (bCmpARight !== 0) return bCmpARight;\n      }\n\n      // is the B right endpoint more left-more?\n      if (arx > brx) {\n        const aCmpBRight = a.comparePoint(b.rightSE.point);\n        if (aCmpBRight < 0) return 1;\n        if (aCmpBRight > 0) return -1;\n      }\n      if (arx !== brx) {\n        // are these two [almost] vertical segments with opposite orientation?\n        // if so, the one with the lower right endpoint comes first\n        const ay = ary - aly;\n        const ax = arx - alx;\n        const by = bry - bly;\n        const bx = brx - blx;\n        if (ay > ax && by < bx) return 1;\n        if (ay < ax && by > bx) return -1;\n      }\n\n      // we have colinear segments with matching orientation\n      // consider the one with more left-more right endpoint to be first\n      if (arx > brx) return 1;\n      if (arx < brx) return -1;\n\n      // if we get here, two two right endpoints are in the same\n      // vertical plane, ie arx === brx\n\n      // consider the lower right-endpoint to come first\n      if (ary < bry) return -1;\n      if (ary > bry) return 1;\n\n      // right endpoints identical as well, so the segments are idential\n      // fall back on creation order as consistent tie-breaker\n      if (a.id < b.id) return -1;\n      if (a.id > b.id) return 1;\n\n      // identical segment, ie a === b\n      return 0;\n    }\n\n    /* Warning: a reference to ringWindings input will be stored,\n     *  and possibly will be later modified */\n    constructor(leftSE, rightSE, rings, windings) {\n      this.id = ++segmentId;\n      this.leftSE = leftSE;\n      leftSE.segment = this;\n      leftSE.otherSE = rightSE;\n      this.rightSE = rightSE;\n      rightSE.segment = this;\n      rightSE.otherSE = leftSE;\n      this.rings = rings;\n      this.windings = windings;\n      // left unset for performance, set later in algorithm\n      // this.ringOut, this.consumedBy, this.prev\n    }\n    static fromRing(pt1, pt2, ring) {\n      let leftPt, rightPt, winding;\n\n      // ordering the two points according to sweep line ordering\n      const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n      if (cmpPts < 0) {\n        leftPt = pt1;\n        rightPt = pt2;\n        winding = 1;\n      } else if (cmpPts > 0) {\n        leftPt = pt2;\n        rightPt = pt1;\n        winding = -1;\n      } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n      const leftSE = new SweepEvent(leftPt, true);\n      const rightSE = new SweepEvent(rightPt, false);\n      return new Segment(leftSE, rightSE, [ring], [winding]);\n    }\n\n    /* When a segment is split, the rightSE is replaced with a new sweep event */\n    replaceRightSE(newRightSE) {\n      this.rightSE = newRightSE;\n      this.rightSE.segment = this;\n      this.rightSE.otherSE = this.leftSE;\n      this.leftSE.otherSE = this.rightSE;\n    }\n    bbox() {\n      const y1 = this.leftSE.point.y;\n      const y2 = this.rightSE.point.y;\n      return {\n        ll: {\n          x: this.leftSE.point.x,\n          y: y1 < y2 ? y1 : y2\n        },\n        ur: {\n          x: this.rightSE.point.x,\n          y: y1 > y2 ? y1 : y2\n        }\n      };\n    }\n\n    /* A vector from the left point to the right */\n    vector() {\n      return {\n        x: this.rightSE.point.x - this.leftSE.point.x,\n        y: this.rightSE.point.y - this.leftSE.point.y\n      };\n    }\n    isAnEndpoint(pt) {\n      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n    }\n\n    /* Compare this segment with a point.\n     *\n     * A point P is considered to be colinear to a segment if there\n     * exists a distance D such that if we travel along the segment\n     * from one * endpoint towards the other a distance D, we find\n     * ourselves at point P.\n     *\n     * Return value indicates:\n     *\n     *   1: point lies above the segment (to the left of vertical)\n     *   0: point is colinear to segment\n     *  -1: point lies below the segment (to the right of vertical)\n     */\n    comparePoint(point) {\n      if (this.isAnEndpoint(point)) return 0;\n      const lPt = this.leftSE.point;\n      const rPt = this.rightSE.point;\n      const v = this.vector();\n\n      // Exactly vertical segments.\n      if (lPt.x === rPt.x) {\n        if (point.x === lPt.x) return 0;\n        return point.x < lPt.x ? 1 : -1;\n      }\n\n      // Nearly vertical segments with an intersection.\n      // Check to see where a point on the line with matching Y coordinate is.\n      const yDist = (point.y - lPt.y) / v.y;\n      const xFromYDist = lPt.x + yDist * v.x;\n      if (point.x === xFromYDist) return 0;\n\n      // General case.\n      // Check to see where a point on the line with matching X coordinate is.\n      const xDist = (point.x - lPt.x) / v.x;\n      const yFromXDist = lPt.y + xDist * v.y;\n      if (point.y === yFromXDist) return 0;\n      return point.y < yFromXDist ? -1 : 1;\n    }\n\n    /**\n     * Given another segment, returns the first non-trivial intersection\n     * between the two segments (in terms of sweep line ordering), if it exists.\n     *\n     * A 'non-trivial' intersection is one that will cause one or both of the\n     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n     *\n     *   * endpoint of segA with endpoint of segB --> trivial\n     *   * endpoint of segA with point along segB --> non-trivial\n     *   * endpoint of segB with point along segA --> non-trivial\n     *   * point along segA with point along segB --> non-trivial\n     *\n     * If no non-trivial intersection exists, return null\n     * Else, return null.\n     */\n    getIntersection(other) {\n      // If bboxes don't overlap, there can't be any intersections\n      const tBbox = this.bbox();\n      const oBbox = other.bbox();\n      const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n      if (bboxOverlap === null) return null;\n\n      // We first check to see if the endpoints can be considered intersections.\n      // This will 'snap' intersections to endpoints if possible, and will\n      // handle cases of colinearity.\n\n      const tlp = this.leftSE.point;\n      const trp = this.rightSE.point;\n      const olp = other.leftSE.point;\n      const orp = other.rightSE.point;\n\n      // does each endpoint touch the other segment?\n      // note that we restrict the 'touching' definition to only allow segments\n      // to touch endpoints that lie forward from where we are in the sweep line pass\n      const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n      const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n      const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n      const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n\n      // do left endpoints match?\n      if (touchesThisLSE && touchesOtherLSE) {\n        // these two cases are for colinear segments with matching left\n        // endpoints, and one segment being longer than the other\n        if (touchesThisRSE && !touchesOtherRSE) return trp;\n        if (!touchesThisRSE && touchesOtherRSE) return orp;\n        // either the two segments match exactly (two trival intersections)\n        // or just on their left endpoint (one trivial intersection\n        return null;\n      }\n\n      // does this left endpoint matches (other doesn't)\n      if (touchesThisLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesOtherRSE) {\n          if (tlp.x === orp.x && tlp.y === orp.y) return null;\n        }\n        // t-intersection on left endpoint\n        return tlp;\n      }\n\n      // does other left endpoint matches (this doesn't)\n      if (touchesOtherLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesThisRSE) {\n          if (trp.x === olp.x && trp.y === olp.y) return null;\n        }\n        // t-intersection on left endpoint\n        return olp;\n      }\n\n      // trivial intersection on right endpoints\n      if (touchesThisRSE && touchesOtherRSE) return null;\n\n      // t-intersections on just one right endpoint\n      if (touchesThisRSE) return trp;\n      if (touchesOtherRSE) return orp;\n\n      // None of our endpoints intersect. Look for a general intersection between\n      // infinite lines laid over the segments\n      const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n\n      // are the segments parrallel? Note that if they were colinear with overlap,\n      // they would have an endpoint intersection and that case was already handled above\n      if (pt === null) return null;\n\n      // is the intersection found between the lines not on the segments?\n      if (!isInBbox(bboxOverlap, pt)) return null;\n\n      // round the the computed point if needed\n      return rounder.round(pt.x, pt.y);\n    }\n\n    /**\n     * Split the given segment into multiple segments on the given points.\n     *  * Each existing segment will retain its leftSE and a new rightSE will be\n     *    generated for it.\n     *  * A new segment will be generated which will adopt the original segment's\n     *    rightSE, and a new leftSE will be generated for it.\n     *  * If there are more than two points given to split on, new segments\n     *    in the middle will be generated with new leftSE and rightSE's.\n     *  * An array of the newly generated SweepEvents will be returned.\n     *\n     * Warning: input array of points is modified\n     */\n    split(point) {\n      const newEvents = [];\n      const alreadyLinked = point.events !== undefined;\n      const newLeftSE = new SweepEvent(point, true);\n      const newRightSE = new SweepEvent(point, false);\n      const oldRightSE = this.rightSE;\n      this.replaceRightSE(newRightSE);\n      newEvents.push(newRightSE);\n      newEvents.push(newLeftSE);\n      const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n\n      // when splitting a nearly vertical downward-facing segment,\n      // sometimes one of the resulting new segments is vertical, in which\n      // case its left and right events may need to be swapped\n      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n        newSeg.swapEvents();\n      }\n      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n        this.swapEvents();\n      }\n\n      // in the point we just used to create new sweep events with was already\n      // linked to other events, we need to check if either of the affected\n      // segments should be consumed\n      if (alreadyLinked) {\n        newLeftSE.checkForConsuming();\n        newRightSE.checkForConsuming();\n      }\n      return newEvents;\n    }\n\n    /* Swap which event is left and right */\n    swapEvents() {\n      const tmpEvt = this.rightSE;\n      this.rightSE = this.leftSE;\n      this.leftSE = tmpEvt;\n      this.leftSE.isLeft = true;\n      this.rightSE.isLeft = false;\n      for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n        this.windings[i] *= -1;\n      }\n    }\n\n    /* Consume another segment. We take their rings under our wing\n     * and mark them as consumed. Use for perfectly overlapping segments */\n    consume(other) {\n      let consumer = this;\n      let consumee = other;\n      while (consumer.consumedBy) consumer = consumer.consumedBy;\n      while (consumee.consumedBy) consumee = consumee.consumedBy;\n      const cmp = Segment.compare(consumer, consumee);\n      if (cmp === 0) return; // already consumed\n      // the winner of the consumption is the earlier segment\n      // according to sweep line ordering\n      if (cmp > 0) {\n        const tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      }\n\n      // make sure a segment doesn't consume it's prev\n      if (consumer.prev === consumee) {\n        const tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      }\n      for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n        const ring = consumee.rings[i];\n        const winding = consumee.windings[i];\n        const index = consumer.rings.indexOf(ring);\n        if (index === -1) {\n          consumer.rings.push(ring);\n          consumer.windings.push(winding);\n        } else consumer.windings[index] += winding;\n      }\n      consumee.rings = null;\n      consumee.windings = null;\n      consumee.consumedBy = consumer;\n\n      // mark sweep events consumed as to maintain ordering in sweep event queue\n      consumee.leftSE.consumedBy = consumer.leftSE;\n      consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n\n    /* The first segment previous segment chain that is in the result */\n    prevInResult() {\n      if (this._prevInResult !== undefined) return this._prevInResult;\n      if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n      return this._prevInResult;\n    }\n    beforeState() {\n      if (this._beforeState !== undefined) return this._beforeState;\n      if (!this.prev) this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };else {\n        const seg = this.prev.consumedBy || this.prev;\n        this._beforeState = seg.afterState();\n      }\n      return this._beforeState;\n    }\n    afterState() {\n      if (this._afterState !== undefined) return this._afterState;\n      const beforeState = this.beforeState();\n      this._afterState = {\n        rings: beforeState.rings.slice(0),\n        windings: beforeState.windings.slice(0),\n        multiPolys: []\n      };\n      const ringsAfter = this._afterState.rings;\n      const windingsAfter = this._afterState.windings;\n      const mpsAfter = this._afterState.multiPolys;\n\n      // calculate ringsAfter, windingsAfter\n      for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n        const ring = this.rings[i];\n        const winding = this.windings[i];\n        const index = ringsAfter.indexOf(ring);\n        if (index === -1) {\n          ringsAfter.push(ring);\n          windingsAfter.push(winding);\n        } else windingsAfter[index] += winding;\n      }\n\n      // calcualte polysAfter\n      const polysAfter = [];\n      const polysExclude = [];\n      for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n        if (windingsAfter[i] === 0) continue; // non-zero rule\n        const ring = ringsAfter[i];\n        const poly = ring.poly;\n        if (polysExclude.indexOf(poly) !== -1) continue;\n        if (ring.isExterior) polysAfter.push(poly);else {\n          if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n          const index = polysAfter.indexOf(ring.poly);\n          if (index !== -1) polysAfter.splice(index, 1);\n        }\n      }\n\n      // calculate multiPolysAfter\n      for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n        const mp = polysAfter[i].multiPoly;\n        if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n      }\n      return this._afterState;\n    }\n\n    /* Is this segment part of the final result? */\n    isInResult() {\n      // if we've been consumed, we're not in the result\n      if (this.consumedBy) return false;\n      if (this._isInResult !== undefined) return this._isInResult;\n      const mpsBefore = this.beforeState().multiPolys;\n      const mpsAfter = this.afterState().multiPolys;\n      switch (operation.type) {\n        case \"union\":\n          {\n            // UNION - included iff:\n            //  * On one side of us there is 0 poly interiors AND\n            //  * On the other side there is 1 or more.\n            const noBefores = mpsBefore.length === 0;\n            const noAfters = mpsAfter.length === 0;\n            this._isInResult = noBefores !== noAfters;\n            break;\n          }\n        case \"intersection\":\n          {\n            // INTERSECTION - included iff:\n            //  * on one side of us all multipolys are rep. with poly interiors AND\n            //  * on the other side of us, not all multipolys are repsented\n            //    with poly interiors\n            let least;\n            let most;\n            if (mpsBefore.length < mpsAfter.length) {\n              least = mpsBefore.length;\n              most = mpsAfter.length;\n            } else {\n              least = mpsAfter.length;\n              most = mpsBefore.length;\n            }\n            this._isInResult = most === operation.numMultiPolys && least < most;\n            break;\n          }\n        case \"xor\":\n          {\n            // XOR - included iff:\n            //  * the difference between the number of multipolys represented\n            //    with poly interiors on our two sides is an odd number\n            const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n            this._isInResult = diff % 2 === 1;\n            break;\n          }\n        case \"difference\":\n          {\n            // DIFFERENCE included iff:\n            //  * on exactly one side, we have just the subject\n            const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;\n            this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n            break;\n          }\n        default:\n          throw new Error(`Unrecognized operation type found ${operation.type}`);\n      }\n      return this._isInResult;\n    }\n  }\n  class RingIn {\n    constructor(geomRing, poly, isExterior) {\n      if (!Array.isArray(geomRing) || geomRing.length === 0) {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      this.poly = poly;\n      this.isExterior = isExterior;\n      this.segments = [];\n      if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n      this.bbox = {\n        ll: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        },\n        ur: {\n          x: firstPoint.x,\n          y: firstPoint.y\n        }\n      };\n      let prevPoint = firstPoint;\n      for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n        if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n        // skip repeated points\n        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n        this.segments.push(Segment.fromRing(prevPoint, point, this));\n        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n        prevPoint = point;\n      }\n      // add segment from last to first if last is not the same as first\n      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n      }\n    }\n    getSweepEvents() {\n      const sweepEvents = [];\n      for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n        const segment = this.segments[i];\n        sweepEvents.push(segment.leftSE);\n        sweepEvents.push(segment.rightSE);\n      }\n      return sweepEvents;\n    }\n  }\n  class PolyIn {\n    constructor(geomPoly, multiPoly) {\n      if (!Array.isArray(geomPoly)) {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      this.exteriorRing = new RingIn(geomPoly[0], this, true);\n      // copy by value\n      this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      };\n      this.interiorRings = [];\n      for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n        const ring = new RingIn(geomPoly[i], this, false);\n        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n        this.interiorRings.push(ring);\n      }\n      this.multiPoly = multiPoly;\n    }\n    getSweepEvents() {\n      const sweepEvents = this.exteriorRing.getSweepEvents();\n      for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n        for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(ringSweepEvents[j]);\n        }\n      }\n      return sweepEvents;\n    }\n  }\n  class MultiPolyIn {\n    constructor(geom, isSubject) {\n      if (!Array.isArray(geom)) {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      try {\n        // if the input looks like a polygon, convert it to a multipolygon\n        if (typeof geom[0][0][0] === \"number\") geom = [geom];\n      } catch (ex) {\n        // The input is either malformed or has empty arrays.\n        // In either case, it will be handled later on.\n      }\n      this.polys = [];\n      this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n      for (let i = 0, iMax = geom.length; i < iMax; i++) {\n        const poly = new PolyIn(geom[i], this);\n        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n        this.polys.push(poly);\n      }\n      this.isSubject = isSubject;\n    }\n    getSweepEvents() {\n      const sweepEvents = [];\n      for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n        const polySweepEvents = this.polys[i].getSweepEvents();\n        for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(polySweepEvents[j]);\n        }\n      }\n      return sweepEvents;\n    }\n  }\n  class RingOut {\n    /* Given the segments from the sweep line pass, compute & return a series\n     * of closed rings from all the segments marked to be part of the result */\n    static factory(allSegments) {\n      const ringsOut = [];\n      for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n        const segment = allSegments[i];\n        if (!segment.isInResult() || segment.ringOut) continue;\n        let prevEvent = null;\n        let event = segment.leftSE;\n        let nextEvent = segment.rightSE;\n        const events = [event];\n        const startingPoint = event.point;\n        const intersectionLEs = [];\n\n        /* Walk the chain of linked events to form a closed ring */\n        while (true) {\n          prevEvent = event;\n          event = nextEvent;\n          events.push(event);\n\n          /* Is the ring complete? */\n          if (event.point === startingPoint) break;\n          while (true) {\n            const availableLEs = event.getAvailableLinkedEvents();\n\n            /* Did we hit a dead end? This shouldn't happen.\n             * Indicates some earlier part of the algorithm malfunctioned. */\n            if (availableLEs.length === 0) {\n              const firstPt = events[0].point;\n              const lastPt = events[events.length - 1].point;\n              throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n            }\n\n            /* Only one way to go, so cotinue on the path */\n            if (availableLEs.length === 1) {\n              nextEvent = availableLEs[0].otherSE;\n              break;\n            }\n\n            /* We must have an intersection. Check for a completed loop */\n            let indexLE = null;\n            for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n              if (intersectionLEs[j].point === event.point) {\n                indexLE = j;\n                break;\n              }\n            }\n            /* Found a completed loop. Cut that off and make a ring */\n            if (indexLE !== null) {\n              const intersectionLE = intersectionLEs.splice(indexLE)[0];\n              const ringEvents = events.splice(intersectionLE.index);\n              ringEvents.unshift(ringEvents[0].otherSE);\n              ringsOut.push(new RingOut(ringEvents.reverse()));\n              continue;\n            }\n            /* register the intersection */\n            intersectionLEs.push({\n              index: events.length,\n              point: event.point\n            });\n            /* Choose the left-most option to continue the walk */\n            const comparator = event.getLeftmostComparator(prevEvent);\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\n            break;\n          }\n        }\n        ringsOut.push(new RingOut(events));\n      }\n      return ringsOut;\n    }\n    constructor(events) {\n      this.events = events;\n      for (let i = 0, iMax = events.length; i < iMax; i++) {\n        events[i].segment.ringOut = this;\n      }\n      this.poly = null;\n    }\n    getGeom() {\n      // Remove superfluous points (ie extra points along a straight line),\n      let prevPt = this.events[0].point;\n      const points = [prevPt];\n      for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n        const pt = this.events[i].point;\n        const nextPt = this.events[i + 1].point;\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n        points.push(pt);\n        prevPt = pt;\n      }\n\n      // ring was all (within rounding error of angle calc) colinear points\n      if (points.length === 1) return null;\n\n      // check if the starting point is necessary\n      const pt = points[0];\n      const nextPt = points[1];\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n      points.push(points[0]);\n      const step = this.isExteriorRing() ? 1 : -1;\n      const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n      const iEnd = this.isExteriorRing() ? points.length : -1;\n      const orderedPoints = [];\n      for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);\n      return orderedPoints;\n    }\n    isExteriorRing() {\n      if (this._isExteriorRing === undefined) {\n        const enclosing = this.enclosingRing();\n        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n      }\n      return this._isExteriorRing;\n    }\n    enclosingRing() {\n      if (this._enclosingRing === undefined) {\n        this._enclosingRing = this._calcEnclosingRing();\n      }\n      return this._enclosingRing;\n    }\n\n    /* Returns the ring that encloses this one, if any */\n    _calcEnclosingRing() {\n      // start with the ealier sweep line event so that the prevSeg\n      // chain doesn't lead us inside of a loop of ours\n      let leftMostEvt = this.events[0];\n      for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n        const evt = this.events[i];\n        if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n      }\n      let prevSeg = leftMostEvt.segment.prevInResult();\n      let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      while (true) {\n        // no segment found, thus no ring can enclose us\n        if (!prevSeg) return null;\n\n        // no segments below prev segment found, thus the ring of the prev\n        // segment must loop back around and enclose us\n        if (!prevPrevSeg) return prevSeg.ringOut;\n\n        // if the two segments are of different rings, the ring of the prev\n        // segment must either loop around us or the ring of the prev prev\n        // seg, which would make us and the ring of the prev peers\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n            return prevSeg.ringOut;\n          } else return prevSeg.ringOut.enclosingRing();\n        }\n\n        // two segments are from the same ring, so this was a penisula\n        // of that ring. iterate downward, keep searching\n        prevSeg = prevPrevSeg.prevInResult();\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      }\n    }\n  }\n  class PolyOut {\n    constructor(exteriorRing) {\n      this.exteriorRing = exteriorRing;\n      exteriorRing.poly = this;\n      this.interiorRings = [];\n    }\n    addInterior(ring) {\n      this.interiorRings.push(ring);\n      ring.poly = this;\n    }\n    getGeom() {\n      const geom = [this.exteriorRing.getGeom()];\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (geom[0] === null) return null;\n      for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        const ringGeom = this.interiorRings[i].getGeom();\n        // interior ring was all (within rounding error of angle calc) colinear points\n        if (ringGeom === null) continue;\n        geom.push(ringGeom);\n      }\n      return geom;\n    }\n  }\n  class MultiPolyOut {\n    constructor(rings) {\n      this.rings = rings;\n      this.polys = this._composePolys(rings);\n    }\n    getGeom() {\n      const geom = [];\n      for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n        const polyGeom = this.polys[i].getGeom();\n        // exterior ring was all (within rounding error of angle calc) colinear points\n        if (polyGeom === null) continue;\n        geom.push(polyGeom);\n      }\n      return geom;\n    }\n    _composePolys(rings) {\n      const polys = [];\n      for (let i = 0, iMax = rings.length; i < iMax; i++) {\n        const ring = rings[i];\n        if (ring.poly) continue;\n        if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n          const enclosingRing = ring.enclosingRing();\n          if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n          enclosingRing.poly.addInterior(ring);\n        }\n      }\n      return polys;\n    }\n  }\n\n  /**\n   * NOTE:  We must be careful not to change any segments while\n   *        they are in the SplayTree. AFAIK, there's no way to tell\n   *        the tree to rebalance itself - thus before splitting\n   *        a segment that's in the tree, we remove it from the tree,\n   *        do the split, then re-insert it. (Even though splitting a\n   *        segment *shouldn't* change its correct position in the\n   *        sweep line tree, the reality is because of rounding errors,\n   *        it sometimes does.)\n   */\n\n  class SweepLine {\n    constructor(queue) {\n      let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n      this.queue = queue;\n      this.tree = new Tree(comparator);\n      this.segments = [];\n    }\n    process(event) {\n      const segment = event.segment;\n      const newEvents = [];\n\n      // if we've already been consumed by another segment,\n      // clean up our body parts and get out\n      if (event.consumedBy) {\n        if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n        return newEvents;\n      }\n      const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n      if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n      let prevNode = node;\n      let nextNode = node;\n      let prevSeg = undefined;\n      let nextSeg = undefined;\n\n      // skip consumed segments still in tree\n      while (prevSeg === undefined) {\n        prevNode = this.tree.prev(prevNode);\n        if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n      }\n\n      // skip consumed segments still in tree\n      while (nextSeg === undefined) {\n        nextNode = this.tree.next(nextNode);\n        if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n      }\n      if (event.isLeft) {\n        // Check for intersections against the previous segment in the sweep line\n        let prevMySplitter = null;\n        if (prevSeg) {\n          const prevInter = prevSeg.getIntersection(segment);\n          if (prevInter !== null) {\n            if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n            if (!prevSeg.isAnEndpoint(prevInter)) {\n              const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n              for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        }\n\n        // Check for intersections against the next segment in the sweep line\n        let nextMySplitter = null;\n        if (nextSeg) {\n          const nextInter = nextSeg.getIntersection(segment);\n          if (nextInter !== null) {\n            if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n            if (!nextSeg.isAnEndpoint(nextInter)) {\n              const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n              for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        }\n\n        // For simplicity, even if we find more than one intersection we only\n        // spilt on the 'earliest' (sweep-line style) of the intersections.\n        // The other intersection will be handled in a future process().\n        if (prevMySplitter !== null || nextMySplitter !== null) {\n          let mySplitter = null;\n          if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n            const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n          }\n\n          // Rounding errors can cause changes in ordering,\n          // so remove afected segments and right sweep events before splitting\n          this.queue.remove(segment.rightSE);\n          newEvents.push(segment.rightSE);\n          const newEventsFromSplit = segment.split(mySplitter);\n          for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n            newEvents.push(newEventsFromSplit[i]);\n          }\n        }\n        if (newEvents.length > 0) {\n          // We found some intersections, so re-do the current event to\n          // make sure sweep line ordering is totally consistent for later\n          // use with the segment 'prev' pointers\n          this.tree.remove(segment);\n          newEvents.push(event);\n        } else {\n          // done with left event\n          this.segments.push(segment);\n          segment.prev = prevSeg;\n        }\n      } else {\n        // event.isRight\n\n        // since we're about to be removed from the sweep line, check for\n        // intersections between our previous and next segments\n        if (prevSeg && nextSeg) {\n          const inter = prevSeg.getIntersection(nextSeg);\n          if (inter !== null) {\n            if (!prevSeg.isAnEndpoint(inter)) {\n              const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n              for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n            if (!nextSeg.isAnEndpoint(inter)) {\n              const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n              for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        }\n        this.tree.remove(segment);\n      }\n      return newEvents;\n    }\n\n    /* Safely split a segment that is currently in the datastructures\n     * IE - a segment other than the one that is currently being processed. */\n    _splitSafely(seg, pt) {\n      // Rounding errors can cause changes in ordering,\n      // so remove afected segments and right sweep events before splitting\n      // removeNode() doesn't work, so have re-find the seg\n      // https://github.com/w8r/splay-tree/pull/5\n      this.tree.remove(seg);\n      const rightSE = seg.rightSE;\n      this.queue.remove(rightSE);\n      const newEvents = seg.split(pt);\n      newEvents.push(rightSE);\n      // splitting can trigger consumption\n      if (seg.consumedBy === undefined) this.tree.add(seg);\n      return newEvents;\n    }\n  }\n\n  // Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\n  const POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n  const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n  class Operation {\n    run(type, geom, moreGeoms) {\n      operation.type = type;\n      rounder.reset();\n\n      /* Convert inputs to MultiPoly objects */\n      const multipolys = [new MultiPolyIn(geom, true)];\n      for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n        multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n      }\n      operation.numMultiPolys = multipolys.length;\n\n      /* BBox optimization for difference operation\n       * If the bbox of a multipolygon that's part of the clipping doesn't\n       * intersect the bbox of the subject at all, we can just drop that\n       * multiploygon. */\n      if (operation.type === \"difference\") {\n        // in place removal\n        const subject = multipolys[0];\n        let i = 1;\n        while (i < multipolys.length) {\n          if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);\n        }\n      }\n\n      /* BBox optimization for intersection operation\n       * If we can find any pair of multipolygons whose bbox does not overlap,\n       * then the result will be empty. */\n      if (operation.type === \"intersection\") {\n        // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n        //       it could be optimized to O(n * ln(n))\n        for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n          const mpA = multipolys[i];\n          for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n          }\n        }\n      }\n\n      /* Put segment endpoints in a priority queue */\n      const queue = new Tree(SweepEvent.compare);\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const sweepEvents = multipolys[i].getSweepEvents();\n        for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n          queue.insert(sweepEvents[j]);\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n          }\n        }\n      }\n\n      /* Pass the sweep line over those endpoints */\n      const sweepLine = new SweepLine(queue);\n      let prevQueueSize = queue.size;\n      let node = queue.pop();\n      while (node) {\n        const evt = node.key;\n        if (queue.size === prevQueueSize) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          const seg = evt.segment;\n          throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n        }\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n        }\n        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n        }\n        const newEvents = sweepLine.process(evt);\n        for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n          const evt = newEvents[i];\n          if (evt.consumedBy === undefined) queue.insert(evt);\n        }\n        prevQueueSize = queue.size;\n        node = queue.pop();\n      }\n\n      // free some memory we don't need anymore\n      rounder.reset();\n\n      /* Collect and compile segments we're keeping into a multipolygon */\n      const ringsOut = RingOut.factory(sweepLine.segments);\n      const result = new MultiPolyOut(ringsOut);\n      return result.getGeom();\n    }\n  }\n\n  // singleton available by import\n  const operation = new Operation();\n  const union = function (geom) {\n    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      moreGeoms[_key - 1] = arguments[_key];\n    }\n    return operation.run(\"union\", geom, moreGeoms);\n  };\n  const intersection = function (geom) {\n    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      moreGeoms[_key2 - 1] = arguments[_key2];\n    }\n    return operation.run(\"intersection\", geom, moreGeoms);\n  };\n  const xor = function (geom) {\n    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      moreGeoms[_key3 - 1] = arguments[_key3];\n    }\n    return operation.run(\"xor\", geom, moreGeoms);\n  };\n  const difference = function (subjectGeom) {\n    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      clippingGeoms[_key4 - 1] = arguments[_key4];\n    }\n    return operation.run(\"difference\", subjectGeom, clippingGeoms);\n  };\n  var index = {\n    union: union,\n    intersection: intersection,\n    xor: xor,\n    difference: difference\n  };\n  return index;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","polygonClipping","__generator","thisArg","body","_","label","sent","t","trys","ops","f","y","g","next","verb","Symbol","iterator","n","v","step","op","TypeError","call","done","value","pop","length","push","e","Node","key","data","left","right","DEFAULT_COMPARE","a","b","splay","i","comparator","N","l","r","cmp","insert","node","split","merge","printRow","root","prefix","isTail","out","printNode","indent","Tree","_root","_size","_comparator","prototype","add","remove","_remove","x","findStatic","current","compare","find","contains","forEach","visitor","ctx","Q","range","low","high","fn","keys","_a","values","min","minNode","max","maxNode","at","index","d","successor","prev","predecessor","clear","toList","load","presort","size","sort","loadRecursive","mergedList","mergeLists","createList","sortedListToBST","head","isEmpty","Object","defineProperty","get","enumerable","configurable","toString","String","join","update","newKey","newData","start","end","middle","Math","floor","p","list","l1","l2","p1","p2","pivot","j","tmp","isInBbox","bbox","point","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","lowerY","upperY","epsilon$1","Number","EPSILON","undefined","pow","EPSILON_SQ","ab","PtRounder","constructor","reset","xRounder","CoordRounder","yRounder","round","tree","coord","prevNode","nextNode","rounder","epsilon","splitter","resulterrbound","sum","elen","flen","h","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","Float64Array","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","abs","C1len","C2len","Dlen","orient2d","detleft","detright","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","res","sqrt","sineOfAngle","pShared","pBase","pAngle","vBase","vAngle","cosineOfAngle","horizontalIntersection","pt","verticalIntersection","intersection$1","pt1","v1","pt2","v2","kross","ve","d1","d2","x1","x2","y1","y2","SweepEvent","ptCmp","comparePoints","link","isLeft","Segment","segment","aPt","bPt","events","other","Error","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","getAvailableLinkedEvents","ringOut","isInResult","getLeftmostComparator","baseEvent","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","asine","acosine","bsine","bcosine","segmentId","alx","leftSE","blx","arx","rightSE","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","id","rings","windings","fromRing","ring","leftPt","rightPt","winding","cmpPts","replaceRightSE","newRightSE","vector","isAnEndpoint","lPt","rPt","yDist","xFromYDist","xDist","yFromXDist","getIntersection","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","newEvents","alreadyLinked","newLeftSE","oldRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","indexOf","prevInResult","_prevInResult","beforeState","_beforeState","multiPolys","seg","afterState","_afterState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","poly","isExterior","splice","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","isJustSubject","mps","isSubject","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","getSweepEvents","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","firstPt","lastPt","indexLE","intersectionLE","ringEvents","unshift","reverse","getGeom","prevPt","points","nextPt","shift","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","addInterior","ringGeom","MultiPolyOut","_composePolys","polyGeom","SweepLine","queue","arguments","process","nextSeg","prevMySplitter","prevInter","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","cmpSplitters","inter","POLYGON_CLIPPING_MAX_QUEUE_SIZE","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","run","moreGeoms","multipolys","subject","mpA","sweepLine","prevQueueSize","result","union","_len","_key","intersection","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/polygon-clipping/dist/polygon-clipping.umd.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.polygonClipping = factory());\n})(this, (function () { 'use strict';\n\n    /**\n     * splaytree v3.1.2\n     * Fast Splay tree for Node and browser\n     *\n     * @author Alexander Milevski <info@w8r.name>\n     * @license MIT\n     * @preserve\n     */\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\n\n    function __generator(thisArg, body) {\n      var _ = {\n          label: 0,\n          sent: function () {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n          },\n          trys: [],\n          ops: []\n        },\n        f,\n        y,\n        t,\n        g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n            case 7:\n              op = _.ops.pop();\n              _.trys.pop();\n              continue;\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n                _.ops.push(op);\n                break;\n              }\n              if (t[2]) _.ops.pop();\n              _.trys.pop();\n              continue;\n          }\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    }\n    var Node = /** @class */function () {\n      function Node(key, data) {\n        this.next = null;\n        this.key = key;\n        this.data = data;\n        this.left = null;\n        this.right = null;\n      }\n      return Node;\n    }();\n\n    /* follows \"An implementation of top-down splaying\"\r\n     * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n     */\n    function DEFAULT_COMPARE(a, b) {\n      return a > b ? 1 : a < b ? -1 : 0;\n    }\n    /**\r\n     * Simple top down splay, not requiring i to be in the tree t.\r\n     */\n    function splay(i, t, comparator) {\n      var N = new Node(null, null);\n      var l = N;\n      var r = N;\n      while (true) {\n        var cmp = comparator(i, t.key);\n        //if (i < t.key) {\n        if (cmp < 0) {\n          if (t.left === null) break;\n          //if (i < t.left.key) {\n          if (comparator(i, t.left.key) < 0) {\n            var y = t.left; /* rotate right */\n            t.left = y.right;\n            y.right = t;\n            t = y;\n            if (t.left === null) break;\n          }\n          r.left = t; /* link right */\n          r = t;\n          t = t.left;\n          //} else if (i > t.key) {\n        } else if (cmp > 0) {\n          if (t.right === null) break;\n          //if (i > t.right.key) {\n          if (comparator(i, t.right.key) > 0) {\n            var y = t.right; /* rotate left */\n            t.right = y.left;\n            y.left = t;\n            t = y;\n            if (t.right === null) break;\n          }\n          l.right = t; /* link left */\n          l = t;\n          t = t.right;\n        } else break;\n      }\n      /* assemble */\n      l.right = t.left;\n      r.left = t.right;\n      t.left = N.right;\n      t.right = N.left;\n      return t;\n    }\n    function insert(i, data, t, comparator) {\n      var node = new Node(i, data);\n      if (t === null) {\n        node.left = node.right = null;\n        return node;\n      }\n      t = splay(i, t, comparator);\n      var cmp = comparator(i, t.key);\n      if (cmp < 0) {\n        node.left = t.left;\n        node.right = t;\n        t.left = null;\n      } else if (cmp >= 0) {\n        node.right = t.right;\n        node.left = t;\n        t.right = null;\n      }\n      return node;\n    }\n    function split(key, v, comparator) {\n      var left = null;\n      var right = null;\n      if (v) {\n        v = splay(key, v, comparator);\n        var cmp = comparator(v.key, key);\n        if (cmp === 0) {\n          left = v.left;\n          right = v.right;\n        } else if (cmp < 0) {\n          right = v.right;\n          v.right = null;\n          left = v;\n        } else {\n          left = v.left;\n          v.left = null;\n          right = v;\n        }\n      }\n      return {\n        left: left,\n        right: right\n      };\n    }\n    function merge(left, right, comparator) {\n      if (right === null) return left;\n      if (left === null) return right;\n      right = splay(left.key, right, comparator);\n      right.left = left;\n      return right;\n    }\n    /**\r\n     * Prints level of the tree\r\n     */\n    function printRow(root, prefix, isTail, out, printNode) {\n      if (root) {\n        out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\n        var indent = prefix + (isTail ? '    ' : '│   ');\n        if (root.left) printRow(root.left, indent, false, out, printNode);\n        if (root.right) printRow(root.right, indent, true, out, printNode);\n      }\n    }\n    var Tree = /** @class */function () {\n      function Tree(comparator) {\n        if (comparator === void 0) {\n          comparator = DEFAULT_COMPARE;\n        }\n        this._root = null;\n        this._size = 0;\n        this._comparator = comparator;\n      }\n      /**\r\n       * Inserts a key, allows duplicates\r\n       */\n      Tree.prototype.insert = function (key, data) {\n        this._size++;\n        return this._root = insert(key, data, this._root, this._comparator);\n      };\n      /**\r\n       * Adds a key, if it is not present in the tree\r\n       */\n      Tree.prototype.add = function (key, data) {\n        var node = new Node(key, data);\n        if (this._root === null) {\n          node.left = node.right = null;\n          this._size++;\n          this._root = node;\n        }\n        var comparator = this._comparator;\n        var t = splay(key, this._root, comparator);\n        var cmp = comparator(key, t.key);\n        if (cmp === 0) this._root = t;else {\n          if (cmp < 0) {\n            node.left = t.left;\n            node.right = t;\n            t.left = null;\n          } else if (cmp > 0) {\n            node.right = t.right;\n            node.left = t;\n            t.right = null;\n          }\n          this._size++;\n          this._root = node;\n        }\n        return this._root;\n      };\n      /**\r\n       * @param  {Key} key\r\n       * @return {Node|null}\r\n       */\n      Tree.prototype.remove = function (key) {\n        this._root = this._remove(key, this._root, this._comparator);\n      };\n      /**\r\n       * Deletes i from the tree if it's there\r\n       */\n      Tree.prototype._remove = function (i, t, comparator) {\n        var x;\n        if (t === null) return null;\n        t = splay(i, t, comparator);\n        var cmp = comparator(i, t.key);\n        if (cmp === 0) {\n          /* found it */\n          if (t.left === null) {\n            x = t.right;\n          } else {\n            x = splay(i, t.left, comparator);\n            x.right = t.right;\n          }\n          this._size--;\n          return x;\n        }\n        return t; /* It wasn't there */\n      };\n      /**\r\n       * Removes and returns the node with smallest key\r\n       */\n      Tree.prototype.pop = function () {\n        var node = this._root;\n        if (node) {\n          while (node.left) node = node.left;\n          this._root = splay(node.key, this._root, this._comparator);\n          this._root = this._remove(node.key, this._root, this._comparator);\n          return {\n            key: node.key,\n            data: node.data\n          };\n        }\n        return null;\n      };\n      /**\r\n       * Find without splaying\r\n       */\n      Tree.prototype.findStatic = function (key) {\n        var current = this._root;\n        var compare = this._comparator;\n        while (current) {\n          var cmp = compare(key, current.key);\n          if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;\n        }\n        return null;\n      };\n      Tree.prototype.find = function (key) {\n        if (this._root) {\n          this._root = splay(key, this._root, this._comparator);\n          if (this._comparator(key, this._root.key) !== 0) return null;\n        }\n        return this._root;\n      };\n      Tree.prototype.contains = function (key) {\n        var current = this._root;\n        var compare = this._comparator;\n        while (current) {\n          var cmp = compare(key, current.key);\n          if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;\n        }\n        return false;\n      };\n      Tree.prototype.forEach = function (visitor, ctx) {\n        var current = this._root;\n        var Q = []; /* Initialize stack s */\n        var done = false;\n        while (!done) {\n          if (current !== null) {\n            Q.push(current);\n            current = current.left;\n          } else {\n            if (Q.length !== 0) {\n              current = Q.pop();\n              visitor.call(ctx, current);\n              current = current.right;\n            } else done = true;\n          }\n        }\n        return this;\n      };\n      /**\r\n       * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n       */\n      Tree.prototype.range = function (low, high, fn, ctx) {\n        var Q = [];\n        var compare = this._comparator;\n        var node = this._root;\n        var cmp;\n        while (Q.length !== 0 || node) {\n          if (node) {\n            Q.push(node);\n            node = node.left;\n          } else {\n            node = Q.pop();\n            cmp = compare(node.key, high);\n            if (cmp > 0) {\n              break;\n            } else if (compare(node.key, low) >= 0) {\n              if (fn.call(ctx, node)) return this; // stop if smth is returned\n            }\n            node = node.right;\n          }\n        }\n        return this;\n      };\n      /**\r\n       * Returns array of keys\r\n       */\n      Tree.prototype.keys = function () {\n        var keys = [];\n        this.forEach(function (_a) {\n          var key = _a.key;\n          return keys.push(key);\n        });\n        return keys;\n      };\n      /**\r\n       * Returns array of all the data in the nodes\r\n       */\n      Tree.prototype.values = function () {\n        var values = [];\n        this.forEach(function (_a) {\n          var data = _a.data;\n          return values.push(data);\n        });\n        return values;\n      };\n      Tree.prototype.min = function () {\n        if (this._root) return this.minNode(this._root).key;\n        return null;\n      };\n      Tree.prototype.max = function () {\n        if (this._root) return this.maxNode(this._root).key;\n        return null;\n      };\n      Tree.prototype.minNode = function (t) {\n        if (t === void 0) {\n          t = this._root;\n        }\n        if (t) while (t.left) t = t.left;\n        return t;\n      };\n      Tree.prototype.maxNode = function (t) {\n        if (t === void 0) {\n          t = this._root;\n        }\n        if (t) while (t.right) t = t.right;\n        return t;\n      };\n      /**\r\n       * Returns node at given index\r\n       */\n      Tree.prototype.at = function (index) {\n        var current = this._root;\n        var done = false;\n        var i = 0;\n        var Q = [];\n        while (!done) {\n          if (current) {\n            Q.push(current);\n            current = current.left;\n          } else {\n            if (Q.length > 0) {\n              current = Q.pop();\n              if (i === index) return current;\n              i++;\n              current = current.right;\n            } else done = true;\n          }\n        }\n        return null;\n      };\n      Tree.prototype.next = function (d) {\n        var root = this._root;\n        var successor = null;\n        if (d.right) {\n          successor = d.right;\n          while (successor.left) successor = successor.left;\n          return successor;\n        }\n        var comparator = this._comparator;\n        while (root) {\n          var cmp = comparator(d.key, root.key);\n          if (cmp === 0) break;else if (cmp < 0) {\n            successor = root;\n            root = root.left;\n          } else root = root.right;\n        }\n        return successor;\n      };\n      Tree.prototype.prev = function (d) {\n        var root = this._root;\n        var predecessor = null;\n        if (d.left !== null) {\n          predecessor = d.left;\n          while (predecessor.right) predecessor = predecessor.right;\n          return predecessor;\n        }\n        var comparator = this._comparator;\n        while (root) {\n          var cmp = comparator(d.key, root.key);\n          if (cmp === 0) break;else if (cmp < 0) root = root.left;else {\n            predecessor = root;\n            root = root.right;\n          }\n        }\n        return predecessor;\n      };\n      Tree.prototype.clear = function () {\n        this._root = null;\n        this._size = 0;\n        return this;\n      };\n      Tree.prototype.toList = function () {\n        return toList(this._root);\n      };\n      /**\r\n       * Bulk-load items. Both array have to be same size\r\n       */\n      Tree.prototype.load = function (keys, values, presort) {\n        if (values === void 0) {\n          values = [];\n        }\n        if (presort === void 0) {\n          presort = false;\n        }\n        var size = keys.length;\n        var comparator = this._comparator;\n        // sort if needed\n        if (presort) sort(keys, values, 0, size - 1, comparator);\n        if (this._root === null) {\n          // empty tree\n          this._root = loadRecursive(keys, values, 0, size);\n          this._size = size;\n        } else {\n          // that re-builds the whole tree from two in-order traversals\n          var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n          size = this._size + size;\n          this._root = sortedListToBST({\n            head: mergedList\n          }, 0, size);\n        }\n        return this;\n      };\n      Tree.prototype.isEmpty = function () {\n        return this._root === null;\n      };\n      Object.defineProperty(Tree.prototype, \"size\", {\n        get: function () {\n          return this._size;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(Tree.prototype, \"root\", {\n        get: function () {\n          return this._root;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Tree.prototype.toString = function (printNode) {\n        if (printNode === void 0) {\n          printNode = function (n) {\n            return String(n.key);\n          };\n        }\n        var out = [];\n        printRow(this._root, '', true, function (v) {\n          return out.push(v);\n        }, printNode);\n        return out.join('');\n      };\n      Tree.prototype.update = function (key, newKey, newData) {\n        var comparator = this._comparator;\n        var _a = split(key, this._root, comparator),\n          left = _a.left,\n          right = _a.right;\n        if (comparator(key, newKey) < 0) {\n          right = insert(newKey, newData, right, comparator);\n        } else {\n          left = insert(newKey, newData, left, comparator);\n        }\n        this._root = merge(left, right, comparator);\n      };\n      Tree.prototype.split = function (key) {\n        return split(key, this._root, this._comparator);\n      };\n      Tree.prototype[Symbol.iterator] = function () {\n        var current, Q, done;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              current = this._root;\n              Q = [];\n              done = false;\n              _a.label = 1;\n            case 1:\n              if (!!done) return [3 /*break*/, 6];\n              if (!(current !== null)) return [3 /*break*/, 2];\n              Q.push(current);\n              current = current.left;\n              return [3 /*break*/, 5];\n            case 2:\n              if (!(Q.length !== 0)) return [3 /*break*/, 4];\n              current = Q.pop();\n              return [4 /*yield*/, current];\n            case 3:\n              _a.sent();\n              current = current.right;\n              return [3 /*break*/, 5];\n            case 4:\n              done = true;\n              _a.label = 5;\n            case 5:\n              return [3 /*break*/, 1];\n            case 6:\n              return [2 /*return*/];\n          }\n        });\n      };\n      return Tree;\n    }();\n    function loadRecursive(keys, values, start, end) {\n      var size = end - start;\n      if (size > 0) {\n        var middle = start + Math.floor(size / 2);\n        var key = keys[middle];\n        var data = values[middle];\n        var node = new Node(key, data);\n        node.left = loadRecursive(keys, values, start, middle);\n        node.right = loadRecursive(keys, values, middle + 1, end);\n        return node;\n      }\n      return null;\n    }\n    function createList(keys, values) {\n      var head = new Node(null, null);\n      var p = head;\n      for (var i = 0; i < keys.length; i++) {\n        p = p.next = new Node(keys[i], values[i]);\n      }\n      p.next = null;\n      return head.next;\n    }\n    function toList(root) {\n      var current = root;\n      var Q = [];\n      var done = false;\n      var head = new Node(null, null);\n      var p = head;\n      while (!done) {\n        if (current) {\n          Q.push(current);\n          current = current.left;\n        } else {\n          if (Q.length > 0) {\n            current = p = p.next = Q.pop();\n            current = current.right;\n          } else done = true;\n        }\n      }\n      p.next = null; // that'll work even if the tree was empty\n      return head.next;\n    }\n    function sortedListToBST(list, start, end) {\n      var size = end - start;\n      if (size > 0) {\n        var middle = start + Math.floor(size / 2);\n        var left = sortedListToBST(list, start, middle);\n        var root = list.head;\n        root.left = left;\n        list.head = list.head.next;\n        root.right = sortedListToBST(list, middle + 1, end);\n        return root;\n      }\n      return null;\n    }\n    function mergeLists(l1, l2, compare) {\n      var head = new Node(null, null); // dummy\n      var p = head;\n      var p1 = l1;\n      var p2 = l2;\n      while (p1 !== null && p2 !== null) {\n        if (compare(p1.key, p2.key) < 0) {\n          p.next = p1;\n          p1 = p1.next;\n        } else {\n          p.next = p2;\n          p2 = p2.next;\n        }\n        p = p.next;\n      }\n      if (p1 !== null) {\n        p.next = p1;\n      } else if (p2 !== null) {\n        p.next = p2;\n      }\n      return head.next;\n    }\n    function sort(keys, values, left, right, compare) {\n      if (left >= right) return;\n      var pivot = keys[left + right >> 1];\n      var i = left - 1;\n      var j = right + 1;\n      while (true) {\n        do i++; while (compare(keys[i], pivot) < 0);\n        do j--; while (compare(keys[j], pivot) > 0);\n        if (i >= j) break;\n        var tmp = keys[i];\n        keys[i] = keys[j];\n        keys[j] = tmp;\n        tmp = values[i];\n        values[i] = values[j];\n        values[j] = tmp;\n      }\n      sort(keys, values, left, j, compare);\n      sort(keys, values, j + 1, right, compare);\n    }\n\n    /**\n     * A bounding box has the format:\n     *\n     *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n     *\n     */\n\n    const isInBbox = (bbox, point) => {\n      return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n    };\n\n    /* Returns either null, or a bbox (aka an ordered pair of points)\n     * If there is only one point of overlap, a bbox with identical points\n     * will be returned */\n    const getBboxOverlap = (b1, b2) => {\n      // check if the bboxes overlap at all\n      if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n\n      // find the middle two X values\n      const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n      const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n      // find the middle two Y values\n      const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n      const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n      // put those middle values together to get the overlap\n      return {\n        ll: {\n          x: lowerX,\n          y: lowerY\n        },\n        ur: {\n          x: upperX,\n          y: upperY\n        }\n      };\n    };\n\n    /* Javascript doesn't do integer math. Everything is\n     * floating point with percision Number.EPSILON.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n     */\n\n    let epsilon$1 = Number.EPSILON;\n\n    // IE Polyfill\n    if (epsilon$1 === undefined) epsilon$1 = Math.pow(2, -52);\n    const EPSILON_SQ = epsilon$1 * epsilon$1;\n\n    /* FLP comparator */\n    const cmp = (a, b) => {\n      // check if they're both 0\n      if (-epsilon$1 < a && a < epsilon$1) {\n        if (-epsilon$1 < b && b < epsilon$1) {\n          return 0;\n        }\n      }\n\n      // check if they're flp equal\n      const ab = a - b;\n      if (ab * ab < EPSILON_SQ * a * b) {\n        return 0;\n      }\n\n      // normal comparison\n      return a < b ? -1 : 1;\n    };\n\n    /**\n     * This class rounds incoming values sufficiently so that\n     * floating points problems are, for the most part, avoided.\n     *\n     * Incoming points are have their x & y values tested against\n     * all previously seen x & y values. If either is 'too close'\n     * to a previously seen value, it's value is 'snapped' to the\n     * previously seen value.\n     *\n     * All points should be rounded by this class before being\n     * stored in any data structures in the rest of this algorithm.\n     */\n\n    class PtRounder {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this.xRounder = new CoordRounder();\n        this.yRounder = new CoordRounder();\n      }\n      round(x, y) {\n        return {\n          x: this.xRounder.round(x),\n          y: this.yRounder.round(y)\n        };\n      }\n    }\n    class CoordRounder {\n      constructor() {\n        this.tree = new Tree();\n        // preseed with 0 so we don't end up with values < Number.EPSILON\n        this.round(0);\n      }\n\n      // Note: this can rounds input values backwards or forwards.\n      //       You might ask, why not restrict this to just rounding\n      //       forwards? Wouldn't that allow left endpoints to always\n      //       remain left endpoints during splitting (never change to\n      //       right). No - it wouldn't, because we snap intersections\n      //       to endpoints (to establish independence from the segment\n      //       angle for t-intersections).\n      round(coord) {\n        const node = this.tree.add(coord);\n        const prevNode = this.tree.prev(node);\n        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n          this.tree.remove(coord);\n          return prevNode.key;\n        }\n        const nextNode = this.tree.next(node);\n        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n          this.tree.remove(coord);\n          return nextNode.key;\n        }\n        return coord;\n      }\n    }\n\n    // singleton available by import\n    const rounder = new PtRounder();\n\n    const epsilon = 1.1102230246251565e-16;\n    const splitter = 134217729;\n    const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n    // fast_expansion_sum_zeroelim routine from oritinal code\n    function sum(elen, e, flen, f, h) {\n      let Q, Qnew, hh, bvirt;\n      let enow = e[0];\n      let fnow = f[0];\n      let eindex = 0;\n      let findex = 0;\n      if (fnow > enow === fnow > -enow) {\n        Q = enow;\n        enow = e[++eindex];\n      } else {\n        Q = fnow;\n        fnow = f[++findex];\n      }\n      let hindex = 0;\n      if (eindex < elen && findex < flen) {\n        if (fnow > enow === fnow > -enow) {\n          Qnew = enow + Q;\n          hh = Q - (Qnew - enow);\n          enow = e[++eindex];\n        } else {\n          Qnew = fnow + Q;\n          hh = Q - (Qnew - fnow);\n          fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n          h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n          if (fnow > enow === fnow > -enow) {\n            Qnew = Q + enow;\n            bvirt = Qnew - Q;\n            hh = Q - (Qnew - bvirt) + (enow - bvirt);\n            enow = e[++eindex];\n          } else {\n            Qnew = Q + fnow;\n            bvirt = Qnew - Q;\n            hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n            fnow = f[++findex];\n          }\n          Q = Qnew;\n          if (hh !== 0) {\n            h[hindex++] = hh;\n          }\n        }\n      }\n      while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n          h[hindex++] = hh;\n        }\n      }\n      while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n          h[hindex++] = hh;\n        }\n      }\n      if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n      }\n      return hindex;\n    }\n    function estimate(elen, e) {\n      let Q = e[0];\n      for (let i = 1; i < elen; i++) Q += e[i];\n      return Q;\n    }\n    function vec(n) {\n      return new Float64Array(n);\n    }\n\n    const ccwerrboundA = (3 + 16 * epsilon) * epsilon;\n    const ccwerrboundB = (2 + 12 * epsilon) * epsilon;\n    const ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n    const B = vec(4);\n    const C1 = vec(8);\n    const C2 = vec(12);\n    const D = vec(16);\n    const u = vec(4);\n    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n      let acxtail, acytail, bcxtail, bcytail;\n      let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n      const acx = ax - cx;\n      const bcx = bx - cx;\n      const acy = ay - cy;\n      const bcy = by - cy;\n      s1 = acx * bcy;\n      c = splitter * acx;\n      ahi = c - (c - acx);\n      alo = acx - ahi;\n      c = splitter * bcy;\n      bhi = c - (c - bcy);\n      blo = bcy - bhi;\n      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n      t1 = acy * bcx;\n      c = splitter * acy;\n      ahi = c - (c - acy);\n      alo = acy - ahi;\n      c = splitter * bcx;\n      bhi = c - (c - bcx);\n      blo = bcx - bhi;\n      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n      _i = s0 - t0;\n      bvirt = s0 - _i;\n      B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n      _j = s1 + _i;\n      bvirt = _j - s1;\n      _0 = s1 - (_j - bvirt) + (_i - bvirt);\n      _i = _0 - t1;\n      bvirt = _0 - _i;\n      B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n      u3 = _j + _i;\n      bvirt = u3 - _j;\n      B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n      B[3] = u3;\n      let det = estimate(4, B);\n      let errbound = ccwerrboundB * detsum;\n      if (det >= errbound || -det >= errbound) {\n        return det;\n      }\n      bvirt = ax - acx;\n      acxtail = ax - (acx + bvirt) + (bvirt - cx);\n      bvirt = bx - bcx;\n      bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n      bvirt = ay - acy;\n      acytail = ay - (acy + bvirt) + (bvirt - cy);\n      bvirt = by - bcy;\n      bcytail = by - (bcy + bvirt) + (bvirt - cy);\n      if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n      }\n      errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n      det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);\n      if (det >= errbound || -det >= errbound) return det;\n      s1 = acxtail * bcy;\n      c = splitter * acxtail;\n      ahi = c - (c - acxtail);\n      alo = acxtail - ahi;\n      c = splitter * bcy;\n      bhi = c - (c - bcy);\n      blo = bcy - bhi;\n      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n      t1 = acytail * bcx;\n      c = splitter * acytail;\n      ahi = c - (c - acytail);\n      alo = acytail - ahi;\n      c = splitter * bcx;\n      bhi = c - (c - bcx);\n      blo = bcx - bhi;\n      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n      _i = s0 - t0;\n      bvirt = s0 - _i;\n      u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n      _j = s1 + _i;\n      bvirt = _j - s1;\n      _0 = s1 - (_j - bvirt) + (_i - bvirt);\n      _i = _0 - t1;\n      bvirt = _0 - _i;\n      u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n      u3 = _j + _i;\n      bvirt = u3 - _j;\n      u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n      u[3] = u3;\n      const C1len = sum(4, B, 4, u, C1);\n      s1 = acx * bcytail;\n      c = splitter * acx;\n      ahi = c - (c - acx);\n      alo = acx - ahi;\n      c = splitter * bcytail;\n      bhi = c - (c - bcytail);\n      blo = bcytail - bhi;\n      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n      t1 = acy * bcxtail;\n      c = splitter * acy;\n      ahi = c - (c - acy);\n      alo = acy - ahi;\n      c = splitter * bcxtail;\n      bhi = c - (c - bcxtail);\n      blo = bcxtail - bhi;\n      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n      _i = s0 - t0;\n      bvirt = s0 - _i;\n      u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n      _j = s1 + _i;\n      bvirt = _j - s1;\n      _0 = s1 - (_j - bvirt) + (_i - bvirt);\n      _i = _0 - t1;\n      bvirt = _0 - _i;\n      u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n      u3 = _j + _i;\n      bvirt = u3 - _j;\n      u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n      u[3] = u3;\n      const C2len = sum(C1len, C1, 4, u, C2);\n      s1 = acxtail * bcytail;\n      c = splitter * acxtail;\n      ahi = c - (c - acxtail);\n      alo = acxtail - ahi;\n      c = splitter * bcytail;\n      bhi = c - (c - bcytail);\n      blo = bcytail - bhi;\n      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n      t1 = acytail * bcxtail;\n      c = splitter * acytail;\n      ahi = c - (c - acytail);\n      alo = acytail - ahi;\n      c = splitter * bcxtail;\n      bhi = c - (c - bcxtail);\n      blo = bcxtail - bhi;\n      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n      _i = s0 - t0;\n      bvirt = s0 - _i;\n      u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n      _j = s1 + _i;\n      bvirt = _j - s1;\n      _0 = s1 - (_j - bvirt) + (_i - bvirt);\n      _i = _0 - t1;\n      bvirt = _0 - _i;\n      u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n      u3 = _j + _i;\n      bvirt = u3 - _j;\n      u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n      u[3] = u3;\n      const Dlen = sum(C2len, C2, 4, u, D);\n      return D[Dlen - 1];\n    }\n    function orient2d(ax, ay, bx, by, cx, cy) {\n      const detleft = (ay - cy) * (bx - cx);\n      const detright = (ax - cx) * (by - cy);\n      const det = detleft - detright;\n      const detsum = Math.abs(detleft + detright);\n      if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n      return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n    }\n\n    /* Cross Product of two vectors with first point at origin */\n    const crossProduct = (a, b) => a.x * b.y - a.y * b.x;\n\n    /* Dot Product of two vectors with first point at origin */\n    const dotProduct = (a, b) => a.x * b.x + a.y * b.y;\n\n    /* Comparator for two vectors with same starting point */\n    const compareVectorAngles = (basePt, endPt1, endPt2) => {\n      const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n      if (res > 0) return -1;\n      if (res < 0) return 1;\n      return 0;\n    };\n    const length = v => Math.sqrt(dotProduct(v, v));\n\n    /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n    const sineOfAngle = (pShared, pBase, pAngle) => {\n      const vBase = {\n        x: pBase.x - pShared.x,\n        y: pBase.y - pShared.y\n      };\n      const vAngle = {\n        x: pAngle.x - pShared.x,\n        y: pAngle.y - pShared.y\n      };\n      return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n    };\n\n    /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n    const cosineOfAngle = (pShared, pBase, pAngle) => {\n      const vBase = {\n        x: pBase.x - pShared.x,\n        y: pBase.y - pShared.y\n      };\n      const vAngle = {\n        x: pAngle.x - pShared.x,\n        y: pAngle.y - pShared.y\n      };\n      return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n    };\n\n    /* Get the x coordinate where the given line (defined by a point and vector)\n     * crosses the horizontal line with the given y coordiante.\n     * In the case of parrallel lines (including overlapping ones) returns null. */\n    const horizontalIntersection = (pt, v, y) => {\n      if (v.y === 0) return null;\n      return {\n        x: pt.x + v.x / v.y * (y - pt.y),\n        y: y\n      };\n    };\n\n    /* Get the y coordinate where the given line (defined by a point and vector)\n     * crosses the vertical line with the given x coordiante.\n     * In the case of parrallel lines (including overlapping ones) returns null. */\n    const verticalIntersection = (pt, v, x) => {\n      if (v.x === 0) return null;\n      return {\n        x: x,\n        y: pt.y + v.y / v.x * (x - pt.x)\n      };\n    };\n\n    /* Get the intersection of two lines, each defined by a base point and a vector.\n     * In the case of parrallel lines (including overlapping ones) returns null. */\n    const intersection$1 = (pt1, v1, pt2, v2) => {\n      // take some shortcuts for vertical and horizontal lines\n      // this also ensures we don't calculate an intersection and then discover\n      // it's actually outside the bounding box of the line\n      if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n      if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n      if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n      if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n      // General case for non-overlapping segments.\n      // This algorithm is based on Schneider and Eberly.\n      // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n      const kross = crossProduct(v1, v2);\n      if (kross == 0) return null;\n      const ve = {\n        x: pt2.x - pt1.x,\n        y: pt2.y - pt1.y\n      };\n      const d1 = crossProduct(ve, v1) / kross;\n      const d2 = crossProduct(ve, v2) / kross;\n\n      // take the average of the two calculations to minimize rounding error\n      const x1 = pt1.x + d2 * v1.x,\n        x2 = pt2.x + d1 * v2.x;\n      const y1 = pt1.y + d2 * v1.y,\n        y2 = pt2.y + d1 * v2.y;\n      const x = (x1 + x2) / 2;\n      const y = (y1 + y2) / 2;\n      return {\n        x: x,\n        y: y\n      };\n    };\n\n    class SweepEvent {\n      // for ordering sweep events in the sweep event queue\n      static compare(a, b) {\n        // favor event with a point that the sweep line hits first\n        const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n        if (ptCmp !== 0) return ptCmp;\n\n        // the points are the same, so link them if needed\n        if (a.point !== b.point) a.link(b);\n\n        // favor right events over left\n        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n        // we have two matching left or right endpoints\n        // ordering of this case is the same as for their segments\n        return Segment.compare(a.segment, b.segment);\n      }\n\n      // for ordering points in sweep line order\n      static comparePoints(aPt, bPt) {\n        if (aPt.x < bPt.x) return -1;\n        if (aPt.x > bPt.x) return 1;\n        if (aPt.y < bPt.y) return -1;\n        if (aPt.y > bPt.y) return 1;\n        return 0;\n      }\n\n      // Warning: 'point' input will be modified and re-used (for performance)\n      constructor(point, isLeft) {\n        if (point.events === undefined) point.events = [this];else point.events.push(this);\n        this.point = point;\n        this.isLeft = isLeft;\n        // this.segment, this.otherSE set by factory\n      }\n      link(other) {\n        if (other.point === this.point) {\n          throw new Error(\"Tried to link already linked events\");\n        }\n        const otherEvents = other.point.events;\n        for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n          const evt = otherEvents[i];\n          this.point.events.push(evt);\n          evt.point = this.point;\n        }\n        this.checkForConsuming();\n      }\n\n      /* Do a pass over our linked events and check to see if any pair\n       * of segments match, and should be consumed. */\n      checkForConsuming() {\n        // FIXME: The loops in this method run O(n^2) => no good.\n        //        Maintain little ordered sweep event trees?\n        //        Can we maintaining an ordering that avoids the need\n        //        for the re-sorting with getLeftmostComparator in geom-out?\n\n        // Compare each pair of events to see if other events also match\n        const numEvents = this.point.events.length;\n        for (let i = 0; i < numEvents; i++) {\n          const evt1 = this.point.events[i];\n          if (evt1.segment.consumedBy !== undefined) continue;\n          for (let j = i + 1; j < numEvents; j++) {\n            const evt2 = this.point.events[j];\n            if (evt2.consumedBy !== undefined) continue;\n            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n            evt1.segment.consume(evt2.segment);\n          }\n        }\n      }\n      getAvailableLinkedEvents() {\n        // point.events is always of length 2 or greater\n        const events = [];\n        for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n          const evt = this.point.events[i];\n          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n            events.push(evt);\n          }\n        }\n        return events;\n      }\n\n      /**\n       * Returns a comparator function for sorting linked events that will\n       * favor the event that will give us the smallest left-side angle.\n       * All ring construction starts as low as possible heading to the right,\n       * so by always turning left as sharp as possible we'll get polygons\n       * without uncessary loops & holes.\n       *\n       * The comparator function has a compute cache such that it avoids\n       * re-computing already-computed values.\n       */\n      getLeftmostComparator(baseEvent) {\n        const cache = new Map();\n        const fillCache = linkedEvent => {\n          const nextEvent = linkedEvent.otherSE;\n          cache.set(linkedEvent, {\n            sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n            cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n          });\n        };\n        return (a, b) => {\n          if (!cache.has(a)) fillCache(a);\n          if (!cache.has(b)) fillCache(b);\n          const {\n            sine: asine,\n            cosine: acosine\n          } = cache.get(a);\n          const {\n            sine: bsine,\n            cosine: bcosine\n          } = cache.get(b);\n\n          // both on or above x-axis\n          if (asine >= 0 && bsine >= 0) {\n            if (acosine < bcosine) return 1;\n            if (acosine > bcosine) return -1;\n            return 0;\n          }\n\n          // both below x-axis\n          if (asine < 0 && bsine < 0) {\n            if (acosine < bcosine) return -1;\n            if (acosine > bcosine) return 1;\n            return 0;\n          }\n\n          // one above x-axis, one below\n          if (bsine < asine) return -1;\n          if (bsine > asine) return 1;\n          return 0;\n        };\n      }\n    }\n\n    // Give segments unique ID's to get consistent sorting of\n    // segments and sweep events when all else is identical\n    let segmentId = 0;\n    class Segment {\n      /* This compare() function is for ordering segments in the sweep\n       * line tree, and does so according to the following criteria:\n       *\n       * Consider the vertical line that lies an infinestimal step to the\n       * right of the right-more of the two left endpoints of the input\n       * segments. Imagine slowly moving a point up from negative infinity\n       * in the increasing y direction. Which of the two segments will that\n       * point intersect first? That segment comes 'before' the other one.\n       *\n       * If neither segment would be intersected by such a line, (if one\n       * or more of the segments are vertical) then the line to be considered\n       * is directly on the right-more of the two left inputs.\n       */\n      static compare(a, b) {\n        const alx = a.leftSE.point.x;\n        const blx = b.leftSE.point.x;\n        const arx = a.rightSE.point.x;\n        const brx = b.rightSE.point.x;\n\n        // check if they're even in the same vertical plane\n        if (brx < alx) return 1;\n        if (arx < blx) return -1;\n        const aly = a.leftSE.point.y;\n        const bly = b.leftSE.point.y;\n        const ary = a.rightSE.point.y;\n        const bry = b.rightSE.point.y;\n\n        // is left endpoint of segment B the right-more?\n        if (alx < blx) {\n          // are the two segments in the same horizontal plane?\n          if (bly < aly && bly < ary) return 1;\n          if (bly > aly && bly > ary) return -1;\n\n          // is the B left endpoint colinear to segment A?\n          const aCmpBLeft = a.comparePoint(b.leftSE.point);\n          if (aCmpBLeft < 0) return 1;\n          if (aCmpBLeft > 0) return -1;\n\n          // is the A right endpoint colinear to segment B ?\n          const bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight;\n\n          // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n          return -1;\n        }\n\n        // is left endpoint of segment A the right-more?\n        if (alx > blx) {\n          if (aly < bly && aly < bry) return -1;\n          if (aly > bly && aly > bry) return 1;\n\n          // is the A left endpoint colinear to segment B?\n          const bCmpALeft = b.comparePoint(a.leftSE.point);\n          if (bCmpALeft !== 0) return bCmpALeft;\n\n          // is the B right endpoint colinear to segment A?\n          const aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1;\n\n          // colinear segments, consider the one with left-more\n          // left endpoint to be first (arbitrary?)\n          return 1;\n        }\n\n        // if we get here, the two left endpoints are in the same\n        // vertical plane, ie alx === blx\n\n        // consider the lower left-endpoint to come first\n        if (aly < bly) return -1;\n        if (aly > bly) return 1;\n\n        // left endpoints are identical\n        // check for colinearity by using the left-more right endpoint\n\n        // is the A right endpoint more left-more?\n        if (arx < brx) {\n          const bCmpARight = b.comparePoint(a.rightSE.point);\n          if (bCmpARight !== 0) return bCmpARight;\n        }\n\n        // is the B right endpoint more left-more?\n        if (arx > brx) {\n          const aCmpBRight = a.comparePoint(b.rightSE.point);\n          if (aCmpBRight < 0) return 1;\n          if (aCmpBRight > 0) return -1;\n        }\n        if (arx !== brx) {\n          // are these two [almost] vertical segments with opposite orientation?\n          // if so, the one with the lower right endpoint comes first\n          const ay = ary - aly;\n          const ax = arx - alx;\n          const by = bry - bly;\n          const bx = brx - blx;\n          if (ay > ax && by < bx) return 1;\n          if (ay < ax && by > bx) return -1;\n        }\n\n        // we have colinear segments with matching orientation\n        // consider the one with more left-more right endpoint to be first\n        if (arx > brx) return 1;\n        if (arx < brx) return -1;\n\n        // if we get here, two two right endpoints are in the same\n        // vertical plane, ie arx === brx\n\n        // consider the lower right-endpoint to come first\n        if (ary < bry) return -1;\n        if (ary > bry) return 1;\n\n        // right endpoints identical as well, so the segments are idential\n        // fall back on creation order as consistent tie-breaker\n        if (a.id < b.id) return -1;\n        if (a.id > b.id) return 1;\n\n        // identical segment, ie a === b\n        return 0;\n      }\n\n      /* Warning: a reference to ringWindings input will be stored,\n       *  and possibly will be later modified */\n      constructor(leftSE, rightSE, rings, windings) {\n        this.id = ++segmentId;\n        this.leftSE = leftSE;\n        leftSE.segment = this;\n        leftSE.otherSE = rightSE;\n        this.rightSE = rightSE;\n        rightSE.segment = this;\n        rightSE.otherSE = leftSE;\n        this.rings = rings;\n        this.windings = windings;\n        // left unset for performance, set later in algorithm\n        // this.ringOut, this.consumedBy, this.prev\n      }\n      static fromRing(pt1, pt2, ring) {\n        let leftPt, rightPt, winding;\n\n        // ordering the two points according to sweep line ordering\n        const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n        if (cmpPts < 0) {\n          leftPt = pt1;\n          rightPt = pt2;\n          winding = 1;\n        } else if (cmpPts > 0) {\n          leftPt = pt2;\n          rightPt = pt1;\n          winding = -1;\n        } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n        const leftSE = new SweepEvent(leftPt, true);\n        const rightSE = new SweepEvent(rightPt, false);\n        return new Segment(leftSE, rightSE, [ring], [winding]);\n      }\n\n      /* When a segment is split, the rightSE is replaced with a new sweep event */\n      replaceRightSE(newRightSE) {\n        this.rightSE = newRightSE;\n        this.rightSE.segment = this;\n        this.rightSE.otherSE = this.leftSE;\n        this.leftSE.otherSE = this.rightSE;\n      }\n      bbox() {\n        const y1 = this.leftSE.point.y;\n        const y2 = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: y1 < y2 ? y1 : y2\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: y1 > y2 ? y1 : y2\n          }\n        };\n      }\n\n      /* A vector from the left point to the right */\n      vector() {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n      isAnEndpoint(pt) {\n        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n      }\n\n      /* Compare this segment with a point.\n       *\n       * A point P is considered to be colinear to a segment if there\n       * exists a distance D such that if we travel along the segment\n       * from one * endpoint towards the other a distance D, we find\n       * ourselves at point P.\n       *\n       * Return value indicates:\n       *\n       *   1: point lies above the segment (to the left of vertical)\n       *   0: point is colinear to segment\n       *  -1: point lies below the segment (to the right of vertical)\n       */\n      comparePoint(point) {\n        if (this.isAnEndpoint(point)) return 0;\n        const lPt = this.leftSE.point;\n        const rPt = this.rightSE.point;\n        const v = this.vector();\n\n        // Exactly vertical segments.\n        if (lPt.x === rPt.x) {\n          if (point.x === lPt.x) return 0;\n          return point.x < lPt.x ? 1 : -1;\n        }\n\n        // Nearly vertical segments with an intersection.\n        // Check to see where a point on the line with matching Y coordinate is.\n        const yDist = (point.y - lPt.y) / v.y;\n        const xFromYDist = lPt.x + yDist * v.x;\n        if (point.x === xFromYDist) return 0;\n\n        // General case.\n        // Check to see where a point on the line with matching X coordinate is.\n        const xDist = (point.x - lPt.x) / v.x;\n        const yFromXDist = lPt.y + xDist * v.y;\n        if (point.y === yFromXDist) return 0;\n        return point.y < yFromXDist ? -1 : 1;\n      }\n\n      /**\n       * Given another segment, returns the first non-trivial intersection\n       * between the two segments (in terms of sweep line ordering), if it exists.\n       *\n       * A 'non-trivial' intersection is one that will cause one or both of the\n       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n       *\n       *   * endpoint of segA with endpoint of segB --> trivial\n       *   * endpoint of segA with point along segB --> non-trivial\n       *   * endpoint of segB with point along segA --> non-trivial\n       *   * point along segA with point along segB --> non-trivial\n       *\n       * If no non-trivial intersection exists, return null\n       * Else, return null.\n       */\n      getIntersection(other) {\n        // If bboxes don't overlap, there can't be any intersections\n        const tBbox = this.bbox();\n        const oBbox = other.bbox();\n        const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n        if (bboxOverlap === null) return null;\n\n        // We first check to see if the endpoints can be considered intersections.\n        // This will 'snap' intersections to endpoints if possible, and will\n        // handle cases of colinearity.\n\n        const tlp = this.leftSE.point;\n        const trp = this.rightSE.point;\n        const olp = other.leftSE.point;\n        const orp = other.rightSE.point;\n\n        // does each endpoint touch the other segment?\n        // note that we restrict the 'touching' definition to only allow segments\n        // to touch endpoints that lie forward from where we are in the sweep line pass\n        const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n        const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n        const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n        const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n\n        // do left endpoints match?\n        if (touchesThisLSE && touchesOtherLSE) {\n          // these two cases are for colinear segments with matching left\n          // endpoints, and one segment being longer than the other\n          if (touchesThisRSE && !touchesOtherRSE) return trp;\n          if (!touchesThisRSE && touchesOtherRSE) return orp;\n          // either the two segments match exactly (two trival intersections)\n          // or just on their left endpoint (one trivial intersection\n          return null;\n        }\n\n        // does this left endpoint matches (other doesn't)\n        if (touchesThisLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesOtherRSE) {\n            if (tlp.x === orp.x && tlp.y === orp.y) return null;\n          }\n          // t-intersection on left endpoint\n          return tlp;\n        }\n\n        // does other left endpoint matches (this doesn't)\n        if (touchesOtherLSE) {\n          // check for segments that just intersect on opposing endpoints\n          if (touchesThisRSE) {\n            if (trp.x === olp.x && trp.y === olp.y) return null;\n          }\n          // t-intersection on left endpoint\n          return olp;\n        }\n\n        // trivial intersection on right endpoints\n        if (touchesThisRSE && touchesOtherRSE) return null;\n\n        // t-intersections on just one right endpoint\n        if (touchesThisRSE) return trp;\n        if (touchesOtherRSE) return orp;\n\n        // None of our endpoints intersect. Look for a general intersection between\n        // infinite lines laid over the segments\n        const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n\n        // are the segments parrallel? Note that if they were colinear with overlap,\n        // they would have an endpoint intersection and that case was already handled above\n        if (pt === null) return null;\n\n        // is the intersection found between the lines not on the segments?\n        if (!isInBbox(bboxOverlap, pt)) return null;\n\n        // round the the computed point if needed\n        return rounder.round(pt.x, pt.y);\n      }\n\n      /**\n       * Split the given segment into multiple segments on the given points.\n       *  * Each existing segment will retain its leftSE and a new rightSE will be\n       *    generated for it.\n       *  * A new segment will be generated which will adopt the original segment's\n       *    rightSE, and a new leftSE will be generated for it.\n       *  * If there are more than two points given to split on, new segments\n       *    in the middle will be generated with new leftSE and rightSE's.\n       *  * An array of the newly generated SweepEvents will be returned.\n       *\n       * Warning: input array of points is modified\n       */\n      split(point) {\n        const newEvents = [];\n        const alreadyLinked = point.events !== undefined;\n        const newLeftSE = new SweepEvent(point, true);\n        const newRightSE = new SweepEvent(point, false);\n        const oldRightSE = this.rightSE;\n        this.replaceRightSE(newRightSE);\n        newEvents.push(newRightSE);\n        newEvents.push(newLeftSE);\n        const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n\n        // when splitting a nearly vertical downward-facing segment,\n        // sometimes one of the resulting new segments is vertical, in which\n        // case its left and right events may need to be swapped\n        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n          newSeg.swapEvents();\n        }\n        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n          this.swapEvents();\n        }\n\n        // in the point we just used to create new sweep events with was already\n        // linked to other events, we need to check if either of the affected\n        // segments should be consumed\n        if (alreadyLinked) {\n          newLeftSE.checkForConsuming();\n          newRightSE.checkForConsuming();\n        }\n        return newEvents;\n      }\n\n      /* Swap which event is left and right */\n      swapEvents() {\n        const tmpEvt = this.rightSE;\n        this.rightSE = this.leftSE;\n        this.leftSE = tmpEvt;\n        this.leftSE.isLeft = true;\n        this.rightSE.isLeft = false;\n        for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n          this.windings[i] *= -1;\n        }\n      }\n\n      /* Consume another segment. We take their rings under our wing\n       * and mark them as consumed. Use for perfectly overlapping segments */\n      consume(other) {\n        let consumer = this;\n        let consumee = other;\n        while (consumer.consumedBy) consumer = consumer.consumedBy;\n        while (consumee.consumedBy) consumee = consumee.consumedBy;\n        const cmp = Segment.compare(consumer, consumee);\n        if (cmp === 0) return; // already consumed\n        // the winner of the consumption is the earlier segment\n        // according to sweep line ordering\n        if (cmp > 0) {\n          const tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        }\n\n        // make sure a segment doesn't consume it's prev\n        if (consumer.prev === consumee) {\n          const tmp = consumer;\n          consumer = consumee;\n          consumee = tmp;\n        }\n        for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n          const ring = consumee.rings[i];\n          const winding = consumee.windings[i];\n          const index = consumer.rings.indexOf(ring);\n          if (index === -1) {\n            consumer.rings.push(ring);\n            consumer.windings.push(winding);\n          } else consumer.windings[index] += winding;\n        }\n        consumee.rings = null;\n        consumee.windings = null;\n        consumee.consumedBy = consumer;\n\n        // mark sweep events consumed as to maintain ordering in sweep event queue\n        consumee.leftSE.consumedBy = consumer.leftSE;\n        consumee.rightSE.consumedBy = consumer.rightSE;\n      }\n\n      /* The first segment previous segment chain that is in the result */\n      prevInResult() {\n        if (this._prevInResult !== undefined) return this._prevInResult;\n        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n        return this._prevInResult;\n      }\n      beforeState() {\n        if (this._beforeState !== undefined) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          const seg = this.prev.consumedBy || this.prev;\n          this._beforeState = seg.afterState();\n        }\n        return this._beforeState;\n      }\n      afterState() {\n        if (this._afterState !== undefined) return this._afterState;\n        const beforeState = this.beforeState();\n        this._afterState = {\n          rings: beforeState.rings.slice(0),\n          windings: beforeState.windings.slice(0),\n          multiPolys: []\n        };\n        const ringsAfter = this._afterState.rings;\n        const windingsAfter = this._afterState.windings;\n        const mpsAfter = this._afterState.multiPolys;\n\n        // calculate ringsAfter, windingsAfter\n        for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n          const ring = this.rings[i];\n          const winding = this.windings[i];\n          const index = ringsAfter.indexOf(ring);\n          if (index === -1) {\n            ringsAfter.push(ring);\n            windingsAfter.push(winding);\n          } else windingsAfter[index] += winding;\n        }\n\n        // calcualte polysAfter\n        const polysAfter = [];\n        const polysExclude = [];\n        for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n          if (windingsAfter[i] === 0) continue; // non-zero rule\n          const ring = ringsAfter[i];\n          const poly = ring.poly;\n          if (polysExclude.indexOf(poly) !== -1) continue;\n          if (ring.isExterior) polysAfter.push(poly);else {\n            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n            const index = polysAfter.indexOf(ring.poly);\n            if (index !== -1) polysAfter.splice(index, 1);\n          }\n        }\n\n        // calculate multiPolysAfter\n        for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n          const mp = polysAfter[i].multiPoly;\n          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n        }\n        return this._afterState;\n      }\n\n      /* Is this segment part of the final result? */\n      isInResult() {\n        // if we've been consumed, we're not in the result\n        if (this.consumedBy) return false;\n        if (this._isInResult !== undefined) return this._isInResult;\n        const mpsBefore = this.beforeState().multiPolys;\n        const mpsAfter = this.afterState().multiPolys;\n        switch (operation.type) {\n          case \"union\":\n            {\n              // UNION - included iff:\n              //  * On one side of us there is 0 poly interiors AND\n              //  * On the other side there is 1 or more.\n              const noBefores = mpsBefore.length === 0;\n              const noAfters = mpsAfter.length === 0;\n              this._isInResult = noBefores !== noAfters;\n              break;\n            }\n          case \"intersection\":\n            {\n              // INTERSECTION - included iff:\n              //  * on one side of us all multipolys are rep. with poly interiors AND\n              //  * on the other side of us, not all multipolys are repsented\n              //    with poly interiors\n              let least;\n              let most;\n              if (mpsBefore.length < mpsAfter.length) {\n                least = mpsBefore.length;\n                most = mpsAfter.length;\n              } else {\n                least = mpsAfter.length;\n                most = mpsBefore.length;\n              }\n              this._isInResult = most === operation.numMultiPolys && least < most;\n              break;\n            }\n          case \"xor\":\n            {\n              // XOR - included iff:\n              //  * the difference between the number of multipolys represented\n              //    with poly interiors on our two sides is an odd number\n              const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n              this._isInResult = diff % 2 === 1;\n              break;\n            }\n          case \"difference\":\n            {\n              // DIFFERENCE included iff:\n              //  * on exactly one side, we have just the subject\n              const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;\n              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n              break;\n            }\n          default:\n            throw new Error(`Unrecognized operation type found ${operation.type}`);\n        }\n        return this._isInResult;\n      }\n    }\n\n    class RingIn {\n      constructor(geomRing, poly, isExterior) {\n        if (!Array.isArray(geomRing) || geomRing.length === 0) {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        this.poly = poly;\n        this.isExterior = isExterior;\n        this.segments = [];\n        if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n        this.bbox = {\n          ll: {\n            x: firstPoint.x,\n            y: firstPoint.y\n          },\n          ur: {\n            x: firstPoint.x,\n            y: firstPoint.y\n          }\n        };\n        let prevPoint = firstPoint;\n        for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n          if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n            throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n          }\n          let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n          // skip repeated points\n          if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n          this.segments.push(Segment.fromRing(prevPoint, point, this));\n          if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n          if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n          if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n          if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n          prevPoint = point;\n        }\n        // add segment from last to first if last is not the same as first\n        if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n          this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n        }\n      }\n      getSweepEvents() {\n        const sweepEvents = [];\n        for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n          const segment = this.segments[i];\n          sweepEvents.push(segment.leftSE);\n          sweepEvents.push(segment.rightSE);\n        }\n        return sweepEvents;\n      }\n    }\n    class PolyIn {\n      constructor(geomPoly, multiPoly) {\n        if (!Array.isArray(geomPoly)) {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        this.exteriorRing = new RingIn(geomPoly[0], this, true);\n        // copy by value\n        this.bbox = {\n          ll: {\n            x: this.exteriorRing.bbox.ll.x,\n            y: this.exteriorRing.bbox.ll.y\n          },\n          ur: {\n            x: this.exteriorRing.bbox.ur.x,\n            y: this.exteriorRing.bbox.ur.y\n          }\n        };\n        this.interiorRings = [];\n        for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n          const ring = new RingIn(geomPoly[i], this, false);\n          if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n          if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n          if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n          if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n          this.interiorRings.push(ring);\n        }\n        this.multiPoly = multiPoly;\n      }\n      getSweepEvents() {\n        const sweepEvents = this.exteriorRing.getSweepEvents();\n        for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n          for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(ringSweepEvents[j]);\n          }\n        }\n        return sweepEvents;\n      }\n    }\n    class MultiPolyIn {\n      constructor(geom, isSubject) {\n        if (!Array.isArray(geom)) {\n          throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        }\n        try {\n          // if the input looks like a polygon, convert it to a multipolygon\n          if (typeof geom[0][0][0] === \"number\") geom = [geom];\n        } catch (ex) {\n          // The input is either malformed or has empty arrays.\n          // In either case, it will be handled later on.\n        }\n        this.polys = [];\n        this.bbox = {\n          ll: {\n            x: Number.POSITIVE_INFINITY,\n            y: Number.POSITIVE_INFINITY\n          },\n          ur: {\n            x: Number.NEGATIVE_INFINITY,\n            y: Number.NEGATIVE_INFINITY\n          }\n        };\n        for (let i = 0, iMax = geom.length; i < iMax; i++) {\n          const poly = new PolyIn(geom[i], this);\n          if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n          if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n          if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n          if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n          this.polys.push(poly);\n        }\n        this.isSubject = isSubject;\n      }\n      getSweepEvents() {\n        const sweepEvents = [];\n        for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n          const polySweepEvents = this.polys[i].getSweepEvents();\n          for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n            sweepEvents.push(polySweepEvents[j]);\n          }\n        }\n        return sweepEvents;\n      }\n    }\n\n    class RingOut {\n      /* Given the segments from the sweep line pass, compute & return a series\n       * of closed rings from all the segments marked to be part of the result */\n      static factory(allSegments) {\n        const ringsOut = [];\n        for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n          const segment = allSegments[i];\n          if (!segment.isInResult() || segment.ringOut) continue;\n          let prevEvent = null;\n          let event = segment.leftSE;\n          let nextEvent = segment.rightSE;\n          const events = [event];\n          const startingPoint = event.point;\n          const intersectionLEs = [];\n\n          /* Walk the chain of linked events to form a closed ring */\n          while (true) {\n            prevEvent = event;\n            event = nextEvent;\n            events.push(event);\n\n            /* Is the ring complete? */\n            if (event.point === startingPoint) break;\n            while (true) {\n              const availableLEs = event.getAvailableLinkedEvents();\n\n              /* Did we hit a dead end? This shouldn't happen.\n               * Indicates some earlier part of the algorithm malfunctioned. */\n              if (availableLEs.length === 0) {\n                const firstPt = events[0].point;\n                const lastPt = events[events.length - 1].point;\n                throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n              }\n\n              /* Only one way to go, so cotinue on the path */\n              if (availableLEs.length === 1) {\n                nextEvent = availableLEs[0].otherSE;\n                break;\n              }\n\n              /* We must have an intersection. Check for a completed loop */\n              let indexLE = null;\n              for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n                if (intersectionLEs[j].point === event.point) {\n                  indexLE = j;\n                  break;\n                }\n              }\n              /* Found a completed loop. Cut that off and make a ring */\n              if (indexLE !== null) {\n                const intersectionLE = intersectionLEs.splice(indexLE)[0];\n                const ringEvents = events.splice(intersectionLE.index);\n                ringEvents.unshift(ringEvents[0].otherSE);\n                ringsOut.push(new RingOut(ringEvents.reverse()));\n                continue;\n              }\n              /* register the intersection */\n              intersectionLEs.push({\n                index: events.length,\n                point: event.point\n              });\n              /* Choose the left-most option to continue the walk */\n              const comparator = event.getLeftmostComparator(prevEvent);\n              nextEvent = availableLEs.sort(comparator)[0].otherSE;\n              break;\n            }\n          }\n          ringsOut.push(new RingOut(events));\n        }\n        return ringsOut;\n      }\n      constructor(events) {\n        this.events = events;\n        for (let i = 0, iMax = events.length; i < iMax; i++) {\n          events[i].segment.ringOut = this;\n        }\n        this.poly = null;\n      }\n      getGeom() {\n        // Remove superfluous points (ie extra points along a straight line),\n        let prevPt = this.events[0].point;\n        const points = [prevPt];\n        for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n          const pt = this.events[i].point;\n          const nextPt = this.events[i + 1].point;\n          if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n          points.push(pt);\n          prevPt = pt;\n        }\n\n        // ring was all (within rounding error of angle calc) colinear points\n        if (points.length === 1) return null;\n\n        // check if the starting point is necessary\n        const pt = points[0];\n        const nextPt = points[1];\n        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n        points.push(points[0]);\n        const step = this.isExteriorRing() ? 1 : -1;\n        const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n        const iEnd = this.isExteriorRing() ? points.length : -1;\n        const orderedPoints = [];\n        for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);\n        return orderedPoints;\n      }\n      isExteriorRing() {\n        if (this._isExteriorRing === undefined) {\n          const enclosing = this.enclosingRing();\n          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n        }\n        return this._isExteriorRing;\n      }\n      enclosingRing() {\n        if (this._enclosingRing === undefined) {\n          this._enclosingRing = this._calcEnclosingRing();\n        }\n        return this._enclosingRing;\n      }\n\n      /* Returns the ring that encloses this one, if any */\n      _calcEnclosingRing() {\n        // start with the ealier sweep line event so that the prevSeg\n        // chain doesn't lead us inside of a loop of ours\n        let leftMostEvt = this.events[0];\n        for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n          const evt = this.events[i];\n          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n        }\n        let prevSeg = leftMostEvt.segment.prevInResult();\n        let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        while (true) {\n          // no segment found, thus no ring can enclose us\n          if (!prevSeg) return null;\n\n          // no segments below prev segment found, thus the ring of the prev\n          // segment must loop back around and enclose us\n          if (!prevPrevSeg) return prevSeg.ringOut;\n\n          // if the two segments are of different rings, the ring of the prev\n          // segment must either loop around us or the ring of the prev prev\n          // seg, which would make us and the ring of the prev peers\n          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n              return prevSeg.ringOut;\n            } else return prevSeg.ringOut.enclosingRing();\n          }\n\n          // two segments are from the same ring, so this was a penisula\n          // of that ring. iterate downward, keep searching\n          prevSeg = prevPrevSeg.prevInResult();\n          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n        }\n      }\n    }\n    class PolyOut {\n      constructor(exteriorRing) {\n        this.exteriorRing = exteriorRing;\n        exteriorRing.poly = this;\n        this.interiorRings = [];\n      }\n      addInterior(ring) {\n        this.interiorRings.push(ring);\n        ring.poly = this;\n      }\n      getGeom() {\n        const geom = [this.exteriorRing.getGeom()];\n        // exterior ring was all (within rounding error of angle calc) colinear points\n        if (geom[0] === null) return null;\n        for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n          const ringGeom = this.interiorRings[i].getGeom();\n          // interior ring was all (within rounding error of angle calc) colinear points\n          if (ringGeom === null) continue;\n          geom.push(ringGeom);\n        }\n        return geom;\n      }\n    }\n    class MultiPolyOut {\n      constructor(rings) {\n        this.rings = rings;\n        this.polys = this._composePolys(rings);\n      }\n      getGeom() {\n        const geom = [];\n        for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n          const polyGeom = this.polys[i].getGeom();\n          // exterior ring was all (within rounding error of angle calc) colinear points\n          if (polyGeom === null) continue;\n          geom.push(polyGeom);\n        }\n        return geom;\n      }\n      _composePolys(rings) {\n        const polys = [];\n        for (let i = 0, iMax = rings.length; i < iMax; i++) {\n          const ring = rings[i];\n          if (ring.poly) continue;\n          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n            const enclosingRing = ring.enclosingRing();\n            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n            enclosingRing.poly.addInterior(ring);\n          }\n        }\n        return polys;\n      }\n    }\n\n    /**\n     * NOTE:  We must be careful not to change any segments while\n     *        they are in the SplayTree. AFAIK, there's no way to tell\n     *        the tree to rebalance itself - thus before splitting\n     *        a segment that's in the tree, we remove it from the tree,\n     *        do the split, then re-insert it. (Even though splitting a\n     *        segment *shouldn't* change its correct position in the\n     *        sweep line tree, the reality is because of rounding errors,\n     *        it sometimes does.)\n     */\n\n    class SweepLine {\n      constructor(queue) {\n        let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n        this.queue = queue;\n        this.tree = new Tree(comparator);\n        this.segments = [];\n      }\n      process(event) {\n        const segment = event.segment;\n        const newEvents = [];\n\n        // if we've already been consumed by another segment,\n        // clean up our body parts and get out\n        if (event.consumedBy) {\n          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n          return newEvents;\n        }\n        const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n        if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n        let prevNode = node;\n        let nextNode = node;\n        let prevSeg = undefined;\n        let nextSeg = undefined;\n\n        // skip consumed segments still in tree\n        while (prevSeg === undefined) {\n          prevNode = this.tree.prev(prevNode);\n          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n        }\n\n        // skip consumed segments still in tree\n        while (nextSeg === undefined) {\n          nextNode = this.tree.next(nextNode);\n          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n        }\n        if (event.isLeft) {\n          // Check for intersections against the previous segment in the sweep line\n          let prevMySplitter = null;\n          if (prevSeg) {\n            const prevInter = prevSeg.getIntersection(segment);\n            if (prevInter !== null) {\n              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n              if (!prevSeg.isAnEndpoint(prevInter)) {\n                const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          }\n\n          // Check for intersections against the next segment in the sweep line\n          let nextMySplitter = null;\n          if (nextSeg) {\n            const nextInter = nextSeg.getIntersection(segment);\n            if (nextInter !== null) {\n              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n              if (!nextSeg.isAnEndpoint(nextInter)) {\n                const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          }\n\n          // For simplicity, even if we find more than one intersection we only\n          // spilt on the 'earliest' (sweep-line style) of the intersections.\n          // The other intersection will be handled in a future process().\n          if (prevMySplitter !== null || nextMySplitter !== null) {\n            let mySplitter = null;\n            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n              const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n            }\n\n            // Rounding errors can cause changes in ordering,\n            // so remove afected segments and right sweep events before splitting\n            this.queue.remove(segment.rightSE);\n            newEvents.push(segment.rightSE);\n            const newEventsFromSplit = segment.split(mySplitter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (newEvents.length > 0) {\n            // We found some intersections, so re-do the current event to\n            // make sure sweep line ordering is totally consistent for later\n            // use with the segment 'prev' pointers\n            this.tree.remove(segment);\n            newEvents.push(event);\n          } else {\n            // done with left event\n            this.segments.push(segment);\n            segment.prev = prevSeg;\n          }\n        } else {\n          // event.isRight\n\n          // since we're about to be removed from the sweep line, check for\n          // intersections between our previous and next segments\n          if (prevSeg && nextSeg) {\n            const inter = prevSeg.getIntersection(nextSeg);\n            if (inter !== null) {\n              if (!prevSeg.isAnEndpoint(inter)) {\n                const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n              if (!nextSeg.isAnEndpoint(inter)) {\n                const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n                for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                  newEvents.push(newEventsFromSplit[i]);\n                }\n              }\n            }\n          }\n          this.tree.remove(segment);\n        }\n        return newEvents;\n      }\n\n      /* Safely split a segment that is currently in the datastructures\n       * IE - a segment other than the one that is currently being processed. */\n      _splitSafely(seg, pt) {\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        // removeNode() doesn't work, so have re-find the seg\n        // https://github.com/w8r/splay-tree/pull/5\n        this.tree.remove(seg);\n        const rightSE = seg.rightSE;\n        this.queue.remove(rightSE);\n        const newEvents = seg.split(pt);\n        newEvents.push(rightSE);\n        // splitting can trigger consumption\n        if (seg.consumedBy === undefined) this.tree.add(seg);\n        return newEvents;\n      }\n    }\n\n    // Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\n    const POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\n    const POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\n    class Operation {\n      run(type, geom, moreGeoms) {\n        operation.type = type;\n        rounder.reset();\n\n        /* Convert inputs to MultiPoly objects */\n        const multipolys = [new MultiPolyIn(geom, true)];\n        for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n          multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n        }\n        operation.numMultiPolys = multipolys.length;\n\n        /* BBox optimization for difference operation\n         * If the bbox of a multipolygon that's part of the clipping doesn't\n         * intersect the bbox of the subject at all, we can just drop that\n         * multiploygon. */\n        if (operation.type === \"difference\") {\n          // in place removal\n          const subject = multipolys[0];\n          let i = 1;\n          while (i < multipolys.length) {\n            if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);\n          }\n        }\n\n        /* BBox optimization for intersection operation\n         * If we can find any pair of multipolygons whose bbox does not overlap,\n         * then the result will be empty. */\n        if (operation.type === \"intersection\") {\n          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n          //       it could be optimized to O(n * ln(n))\n          for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n            const mpA = multipolys[i];\n            for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n            }\n          }\n        }\n\n        /* Put segment endpoints in a priority queue */\n        const queue = new Tree(SweepEvent.compare);\n        for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n          const sweepEvents = multipolys[i].getSweepEvents();\n          for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n            queue.insert(sweepEvents[j]);\n            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n              // prevents an infinite loop, an otherwise common manifestation of bugs\n              throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n            }\n          }\n        }\n\n        /* Pass the sweep line over those endpoints */\n        const sweepLine = new SweepLine(queue);\n        let prevQueueSize = queue.size;\n        let node = queue.pop();\n        while (node) {\n          const evt = node.key;\n          if (queue.size === prevQueueSize) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            const seg = evt.segment;\n            throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n          }\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n          }\n          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n          }\n          const newEvents = sweepLine.process(evt);\n          for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n            const evt = newEvents[i];\n            if (evt.consumedBy === undefined) queue.insert(evt);\n          }\n          prevQueueSize = queue.size;\n          node = queue.pop();\n        }\n\n        // free some memory we don't need anymore\n        rounder.reset();\n\n        /* Collect and compile segments we're keeping into a multipolygon */\n        const ringsOut = RingOut.factory(sweepLine.segments);\n        const result = new MultiPolyOut(ringsOut);\n        return result.getGeom();\n      }\n    }\n\n    // singleton available by import\n    const operation = new Operation();\n\n    const union = function (geom) {\n      for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        moreGeoms[_key - 1] = arguments[_key];\n      }\n      return operation.run(\"union\", geom, moreGeoms);\n    };\n    const intersection = function (geom) {\n      for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        moreGeoms[_key2 - 1] = arguments[_key2];\n      }\n      return operation.run(\"intersection\", geom, moreGeoms);\n    };\n    const xor = function (geom) {\n      for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        moreGeoms[_key3 - 1] = arguments[_key3];\n      }\n      return operation.run(\"xor\", geom, moreGeoms);\n    };\n    const difference = function (subjectGeom) {\n      for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        clippingGeoms[_key4 - 1] = arguments[_key4];\n      }\n      return operation.run(\"difference\", subjectGeom, clippingGeoms);\n    };\n    var index = {\n      union: union,\n      intersection: intersection,\n      xor: xor,\n      difference: difference\n    };\n\n    return index;\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}