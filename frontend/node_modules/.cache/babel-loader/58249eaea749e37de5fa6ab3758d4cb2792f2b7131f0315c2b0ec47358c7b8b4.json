{"ast":null,"code":"import { getCoords, getType } from '@turf/invariant';\nimport { lineString } from '@turf/helpers';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\n\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @name lineSlice\n * @param {Coord} startPt starting point\n * @param {Coord} stopPt stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var start = turf.point([-77.029609, 38.881946]);\n * var stop = turf.point([-77.021884, 38.889563]);\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //addToMap\n * var addToMap = [start, stop, line]\n */\nfunction lineSlice(startPt, stopPt, line) {\n  // Validation\n  var coords = getCoords(line);\n  if (getType(line) !== \"LineString\") throw new Error(\"line must be a LineString\");\n  var startVertex = nearestPointOnLine(line, startPt);\n  var stopVertex = nearestPointOnLine(line, stopPt);\n  var ends;\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n  var clipCoords = [ends[0].geometry.coordinates];\n  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n    clipCoords.push(coords[i]);\n  }\n  clipCoords.push(ends[1].geometry.coordinates);\n  return lineString(clipCoords, line.properties);\n}\nexport default lineSlice;","map":{"version":3,"names":["getCoords","getType","lineString","nearestPointOnLine","lineSlice","startPt","stopPt","line","coords","Error","startVertex","stopVertex","ends","properties","index","clipCoords","geometry","coordinates","i","push"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/line-slice/dist/es/index.js"],"sourcesContent":["import { getCoords, getType } from '@turf/invariant';\nimport { lineString } from '@turf/helpers';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\n\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @name lineSlice\n * @param {Coord} startPt starting point\n * @param {Coord} stopPt stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var start = turf.point([-77.029609, 38.881946]);\n * var stop = turf.point([-77.021884, 38.889563]);\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //addToMap\n * var addToMap = [start, stop, line]\n */\nfunction lineSlice(startPt, stopPt, line) {\n  // Validation\n  var coords = getCoords(line);\n  if (getType(line) !== \"LineString\")\n    throw new Error(\"line must be a LineString\");\n\n  var startVertex = nearestPointOnLine(line, startPt);\n  var stopVertex = nearestPointOnLine(line, stopPt);\n  var ends;\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n  var clipCoords = [ends[0].geometry.coordinates];\n  for (\n    var i = ends[0].properties.index + 1;\n    i < ends[1].properties.index + 1;\n    i++\n  ) {\n    clipCoords.push(coords[i]);\n  }\n  clipCoords.push(ends[1].geometry.coordinates);\n  return lineString(clipCoords, line.properties);\n}\n\nexport default lineSlice;\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,OAAO,QAAQ,iBAAiB;AACpD,SAASC,UAAU,QAAQ,eAAe;AAC1C,OAAOC,kBAAkB,MAAM,6BAA6B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACC,OAAO,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACxC;EACA,IAAIC,MAAM,GAAGR,SAAS,CAACO,IAAI,CAAC;EAC5B,IAAIN,OAAO,CAACM,IAAI,CAAC,KAAK,YAAY,EAChC,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;EAE9C,IAAIC,WAAW,GAAGP,kBAAkB,CAACI,IAAI,EAAEF,OAAO,CAAC;EACnD,IAAIM,UAAU,GAAGR,kBAAkB,CAACI,IAAI,EAAED,MAAM,CAAC;EACjD,IAAIM,IAAI;EACR,IAAIF,WAAW,CAACG,UAAU,CAACC,KAAK,IAAIH,UAAU,CAACE,UAAU,CAACC,KAAK,EAAE;IAC/DF,IAAI,GAAG,CAACF,WAAW,EAAEC,UAAU,CAAC;EAClC,CAAC,MAAM;IACLC,IAAI,GAAG,CAACD,UAAU,EAAED,WAAW,CAAC;EAClC;EACA,IAAIK,UAAU,GAAG,CAACH,IAAI,CAAC,CAAC,CAAC,CAACI,QAAQ,CAACC,WAAW,CAAC;EAC/C,KACE,IAAIC,CAAC,GAAGN,IAAI,CAAC,CAAC,CAAC,CAACC,UAAU,CAACC,KAAK,GAAG,CAAC,EACpCI,CAAC,GAAGN,IAAI,CAAC,CAAC,CAAC,CAACC,UAAU,CAACC,KAAK,GAAG,CAAC,EAChCI,CAAC,EAAE,EACH;IACAH,UAAU,CAACI,IAAI,CAACX,MAAM,CAACU,CAAC,CAAC,CAAC;EAC5B;EACAH,UAAU,CAACI,IAAI,CAACP,IAAI,CAAC,CAAC,CAAC,CAACI,QAAQ,CAACC,WAAW,CAAC;EAC7C,OAAOf,UAAU,CAACa,UAAU,EAAER,IAAI,CAACM,UAAU,CAAC;AAChD;AAEA,eAAeT,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}