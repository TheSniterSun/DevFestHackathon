{"ast":null,"code":"import { isObject, multiPolygon, featureCollection } from '@turf/helpers';\nimport { collectionOf } from '@turf/invariant';\nimport { featureEach } from '@turf/meta';\nimport flatten from '@turf/flatten';\nimport polygonClipping from 'polygon-clipping';\n\n/**\n * Dissolves a FeatureCollection of {@link polygon} features, filtered by an optional property name:value.\n * Note that {@link mulitpolygon} features within the collection are not supported\n *\n * @name dissolve\n * @param {FeatureCollection<Polygon>} featureCollection input feature collection to be dissolved\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.propertyName] features with the same `propertyName` value will be dissolved.\n * @returns {FeatureCollection<Polygon>} a FeatureCollection containing the dissolved polygons\n * @example\n * var features = turf.featureCollection([\n *   turf.polygon([[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]], {combine: 'yes'}),\n *   turf.polygon([[[0, -1], [0, 0], [1, 0], [1, -1], [0,-1]]], {combine: 'yes'}),\n *   turf.polygon([[[1,-1],[1, 0], [2, 0], [2, -1], [1, -1]]], {combine: 'no'}),\n * ]);\n *\n * var dissolved = turf.dissolve(features, {propertyName: 'combine'});\n *\n * //addToMap\n * var addToMap = [features, dissolved]\n */\nfunction dissolve(fc, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var propertyName = options.propertyName;\n\n  // Input validation\n  collectionOf(fc, \"Polygon\", \"dissolve\");\n\n  // Main\n  var outFeatures = [];\n  if (!options.propertyName) {\n    return flatten(multiPolygon(polygonClipping.union.apply(null, fc.features.map(function (f) {\n      return f.geometry.coordinates;\n    }))));\n  } else {\n    var uniquePropertyVals = {};\n    featureEach(fc, function (feature) {\n      if (!Object.prototype.hasOwnProperty.call(uniquePropertyVals, feature.properties[propertyName])) {\n        uniquePropertyVals[feature.properties[propertyName]] = [];\n      }\n      uniquePropertyVals[feature.properties[propertyName]].push(feature);\n    });\n    var vals = Object.keys(uniquePropertyVals);\n    for (var i = 0; i < vals.length; i++) {\n      var mp = multiPolygon(polygonClipping.union.apply(null, uniquePropertyVals[vals[i]].map(function (f) {\n        return f.geometry.coordinates;\n      })));\n      mp.properties[propertyName] = vals[i];\n      outFeatures.push(mp);\n    }\n  }\n  return flatten(featureCollection(outFeatures));\n}\nexport default dissolve;","map":{"version":3,"names":["isObject","multiPolygon","featureCollection","collectionOf","featureEach","flatten","polygonClipping","dissolve","fc","options","Error","propertyName","outFeatures","union","apply","features","map","f","geometry","coordinates","uniquePropertyVals","feature","Object","prototype","hasOwnProperty","call","properties","push","vals","keys","i","length","mp"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/dissolve/dist/es/index.js"],"sourcesContent":["import { isObject, multiPolygon, featureCollection } from '@turf/helpers';\nimport { collectionOf } from '@turf/invariant';\nimport { featureEach } from '@turf/meta';\nimport flatten from '@turf/flatten';\nimport polygonClipping from 'polygon-clipping';\n\n/**\n * Dissolves a FeatureCollection of {@link polygon} features, filtered by an optional property name:value.\n * Note that {@link mulitpolygon} features within the collection are not supported\n *\n * @name dissolve\n * @param {FeatureCollection<Polygon>} featureCollection input feature collection to be dissolved\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.propertyName] features with the same `propertyName` value will be dissolved.\n * @returns {FeatureCollection<Polygon>} a FeatureCollection containing the dissolved polygons\n * @example\n * var features = turf.featureCollection([\n *   turf.polygon([[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]], {combine: 'yes'}),\n *   turf.polygon([[[0, -1], [0, 0], [1, 0], [1, -1], [0,-1]]], {combine: 'yes'}),\n *   turf.polygon([[[1,-1],[1, 0], [2, 0], [2, -1], [1, -1]]], {combine: 'no'}),\n * ]);\n *\n * var dissolved = turf.dissolve(features, {propertyName: 'combine'});\n *\n * //addToMap\n * var addToMap = [features, dissolved]\n */\nfunction dissolve(fc, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var propertyName = options.propertyName;\n\n  // Input validation\n  collectionOf(fc, \"Polygon\", \"dissolve\");\n\n  // Main\n  var outFeatures = [];\n  if (!options.propertyName) {\n    return flatten(\n      multiPolygon(\n        polygonClipping.union.apply(\n          null,\n          fc.features.map(function (f) {\n            return f.geometry.coordinates;\n          })\n        )\n      )\n    );\n  } else {\n    var uniquePropertyVals = {};\n    featureEach(fc, function (feature) {\n      if (\n        !Object.prototype.hasOwnProperty.call(\n          uniquePropertyVals,\n          feature.properties[propertyName]\n        )\n      ) {\n        uniquePropertyVals[feature.properties[propertyName]] = [];\n      }\n      uniquePropertyVals[feature.properties[propertyName]].push(feature);\n    });\n    var vals = Object.keys(uniquePropertyVals);\n    for (var i = 0; i < vals.length; i++) {\n      var mp = multiPolygon(\n        polygonClipping.union.apply(\n          null,\n          uniquePropertyVals[vals[i]].map(function (f) {\n            return f.geometry.coordinates;\n          })\n        )\n      );\n      mp.properties[propertyName] = vals[i];\n      outFeatures.push(mp);\n    }\n  }\n\n  return flatten(featureCollection(outFeatures));\n}\n\nexport default dissolve;\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,YAAY,EAAEC,iBAAiB,QAAQ,eAAe;AACzE,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,WAAW,QAAQ,YAAY;AACxC,OAAOC,OAAO,MAAM,eAAe;AACnC,OAAOC,eAAe,MAAM,kBAAkB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,QAAQA,CAACC,EAAE,EAAEC,OAAO,EAAE;EAC7B;EACAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAI,CAACT,QAAQ,CAACS,OAAO,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;EAC7D,IAAIC,YAAY,GAAGF,OAAO,CAACE,YAAY;;EAEvC;EACAR,YAAY,CAACK,EAAE,EAAE,SAAS,EAAE,UAAU,CAAC;;EAEvC;EACA,IAAII,WAAW,GAAG,EAAE;EACpB,IAAI,CAACH,OAAO,CAACE,YAAY,EAAE;IACzB,OAAON,OAAO,CACZJ,YAAY,CACVK,eAAe,CAACO,KAAK,CAACC,KAAK,CACzB,IAAI,EACJN,EAAE,CAACO,QAAQ,CAACC,GAAG,CAAC,UAAUC,CAAC,EAAE;MAC3B,OAAOA,CAAC,CAACC,QAAQ,CAACC,WAAW;IAC/B,CAAC,CACH,CACF,CACF,CAAC;EACH,CAAC,MAAM;IACL,IAAIC,kBAAkB,GAAG,CAAC,CAAC;IAC3BhB,WAAW,CAACI,EAAE,EAAE,UAAUa,OAAO,EAAE;MACjC,IACE,CAACC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CACnCL,kBAAkB,EAClBC,OAAO,CAACK,UAAU,CAACf,YAAY,CACjC,CAAC,EACD;QACAS,kBAAkB,CAACC,OAAO,CAACK,UAAU,CAACf,YAAY,CAAC,CAAC,GAAG,EAAE;MAC3D;MACAS,kBAAkB,CAACC,OAAO,CAACK,UAAU,CAACf,YAAY,CAAC,CAAC,CAACgB,IAAI,CAACN,OAAO,CAAC;IACpE,CAAC,CAAC;IACF,IAAIO,IAAI,GAAGN,MAAM,CAACO,IAAI,CAACT,kBAAkB,CAAC;IAC1C,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MACpC,IAAIE,EAAE,GAAG/B,YAAY,CACnBK,eAAe,CAACO,KAAK,CAACC,KAAK,CACzB,IAAI,EACJM,kBAAkB,CAACQ,IAAI,CAACE,CAAC,CAAC,CAAC,CAACd,GAAG,CAAC,UAAUC,CAAC,EAAE;QAC3C,OAAOA,CAAC,CAACC,QAAQ,CAACC,WAAW;MAC/B,CAAC,CACH,CACF,CAAC;MACDa,EAAE,CAACN,UAAU,CAACf,YAAY,CAAC,GAAGiB,IAAI,CAACE,CAAC,CAAC;MACrClB,WAAW,CAACe,IAAI,CAACK,EAAE,CAAC;IACtB;EACF;EAEA,OAAO3B,OAAO,CAACH,iBAAiB,CAACU,WAAW,CAAC,CAAC;AAChD;AAEA,eAAeL,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}