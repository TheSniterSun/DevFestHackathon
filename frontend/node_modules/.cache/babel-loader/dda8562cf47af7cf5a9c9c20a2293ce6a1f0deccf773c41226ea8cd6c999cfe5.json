{"ast":null,"code":"import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { point } from \"@turf/helpers\";\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\nfunction mathSign(x) {\n  return (x > 0) - (x < 0) || +x;\n}\n/**\n * Returns the direction of the point q relative to the vector p1 -> p2.\n *\n * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()\n * (same as geos::algorithm::CGAlgorithm::computeOrientation())\n *\n * @param {number[]} p1 - the origin point of the vector\n * @param {number[]} p2 - the final point of the vector\n * @param {number[]} q - the point to compute the direction to\n *\n * @returns {number} - 1 if q is ccw (left) from p1->p2,\n *    -1 if q is cw (right) from p1->p2,\n *     0 if q is colinear with p1->p2\n */\nexport function orientationIndex(p1, p2, q) {\n  var dx1 = p2[0] - p1[0],\n    dy1 = p2[1] - p1[1],\n    dx2 = q[0] - p2[0],\n    dy2 = q[1] - p2[1];\n  return mathSign(dx1 * dy2 - dx2 * dy1);\n}\n/**\n * Checks if two envelopes are equal.\n *\n * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon\n *\n * @param {Feature<Polygon>} env1 - Envelope\n * @param {Feature<Polygon>} env2 - Envelope\n * @returns {boolean} - True if the envelopes are equal\n */\nexport function envelopeIsEqual(env1, env2) {\n  var envX1 = env1.geometry.coordinates[0].map(function (c) {\n      return c[0];\n    }),\n    envY1 = env1.geometry.coordinates[0].map(function (c) {\n      return c[1];\n    }),\n    envX2 = env2.geometry.coordinates[0].map(function (c) {\n      return c[0];\n    }),\n    envY2 = env2.geometry.coordinates[0].map(function (c) {\n      return c[1];\n    });\n  return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);\n}\n/**\n * Check if a envelope is contained in other one.\n *\n * The function assumes that the arguments are envelopes, i.e.: Convex polygon\n * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,\n * this could be further improved.\n *\n * @param {Feature<Polygon>} self - Envelope\n * @param {Feature<Polygon>} env - Envelope\n * @returns {boolean} - True if env is contained in self\n */\nexport function envelopeContains(self, env) {\n  return env.geometry.coordinates[0].every(function (c) {\n    return booleanPointInPolygon(point(c), self);\n  });\n}\n/**\n * Checks if two coordinates are equal.\n *\n * @param {number[]} coord1 - First coordinate\n * @param {number[]} coord2 - Second coordinate\n * @returns {boolean} - True if coordinates are equal\n */\nexport function coordinatesEqual(coord1, coord2) {\n  return coord1[0] === coord2[0] && coord1[1] === coord2[1];\n}","map":{"version":3,"names":["booleanPointInPolygon","point","mathSign","x","orientationIndex","p1","p2","q","dx1","dy1","dx2","dy2","envelopeIsEqual","env1","env2","envX1","geometry","coordinates","map","c","envY1","envX2","envY2","Math","max","apply","min","envelopeContains","self","env","every","coordinatesEqual","coord1","coord2"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/polygonize/dist/es/lib/util.js"],"sourcesContent":["import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { point } from \"@turf/helpers\";\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\nfunction mathSign(x) {\n    return ((x > 0) - (x < 0) || +x);\n}\n/**\n * Returns the direction of the point q relative to the vector p1 -> p2.\n *\n * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()\n * (same as geos::algorithm::CGAlgorithm::computeOrientation())\n *\n * @param {number[]} p1 - the origin point of the vector\n * @param {number[]} p2 - the final point of the vector\n * @param {number[]} q - the point to compute the direction to\n *\n * @returns {number} - 1 if q is ccw (left) from p1->p2,\n *    -1 if q is cw (right) from p1->p2,\n *     0 if q is colinear with p1->p2\n */\nexport function orientationIndex(p1, p2, q) {\n    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];\n    return mathSign(dx1 * dy2 - dx2 * dy1);\n}\n/**\n * Checks if two envelopes are equal.\n *\n * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon\n *\n * @param {Feature<Polygon>} env1 - Envelope\n * @param {Feature<Polygon>} env2 - Envelope\n * @returns {boolean} - True if the envelopes are equal\n */\nexport function envelopeIsEqual(env1, env2) {\n    var envX1 = env1.geometry.coordinates[0].map(function (c) { return c[0]; }), envY1 = env1.geometry.coordinates[0].map(function (c) { return c[1]; }), envX2 = env2.geometry.coordinates[0].map(function (c) { return c[0]; }), envY2 = env2.geometry.coordinates[0].map(function (c) { return c[1]; });\n    return (Math.max.apply(null, envX1) === Math.max.apply(null, envX2) &&\n        Math.max.apply(null, envY1) === Math.max.apply(null, envY2) &&\n        Math.min.apply(null, envX1) === Math.min.apply(null, envX2) &&\n        Math.min.apply(null, envY1) === Math.min.apply(null, envY2));\n}\n/**\n * Check if a envelope is contained in other one.\n *\n * The function assumes that the arguments are envelopes, i.e.: Convex polygon\n * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,\n * this could be further improved.\n *\n * @param {Feature<Polygon>} self - Envelope\n * @param {Feature<Polygon>} env - Envelope\n * @returns {boolean} - True if env is contained in self\n */\nexport function envelopeContains(self, env) {\n    return env.geometry.coordinates[0].every(function (c) {\n        return booleanPointInPolygon(point(c), self);\n    });\n}\n/**\n * Checks if two coordinates are equal.\n *\n * @param {number[]} coord1 - First coordinate\n * @param {number[]} coord2 - Second coordinate\n * @returns {boolean} - True if coordinates are equal\n */\nexport function coordinatesEqual(coord1, coord2) {\n    return coord1[0] === coord2[0] && coord1[1] === coord2[1];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}