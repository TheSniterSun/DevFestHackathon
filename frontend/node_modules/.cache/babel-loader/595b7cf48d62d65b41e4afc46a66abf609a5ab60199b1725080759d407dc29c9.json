{"ast":null,"code":"import { getCoord } from '@turf/invariant';\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\nvar Coord = function (lon, lat) {\n  this.lon = lon;\n  this.lat = lat;\n  this.x = D2R * lon;\n  this.y = D2R * lat;\n};\nCoord.prototype.view = function () {\n  return String(this.lon).slice(0, 4) + \",\" + String(this.lat).slice(0, 4);\n};\nCoord.prototype.antipode = function () {\n  var anti_lat = -1 * this.lat;\n  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;\n  return new Coord(anti_lon, anti_lat);\n};\nvar LineString = function () {\n  this.coords = [];\n  this.length = 0;\n};\nLineString.prototype.move_to = function (coord) {\n  this.length++;\n  this.coords.push(coord);\n};\nvar Arc = function (properties) {\n  this.properties = properties || {};\n  this.geometries = [];\n};\nArc.prototype.json = function () {\n  if (this.geometries.length <= 0) {\n    return {\n      geometry: {\n        type: \"LineString\",\n        coordinates: null\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n  } else if (this.geometries.length === 1) {\n    return {\n      geometry: {\n        type: \"LineString\",\n        coordinates: this.geometries[0].coords\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n  } else {\n    var multiline = [];\n    for (var i = 0; i < this.geometries.length; i++) {\n      multiline.push(this.geometries[i].coords);\n    }\n    return {\n      geometry: {\n        type: \"MultiLineString\",\n        coordinates: multiline\n      },\n      type: \"Feature\",\n      properties: this.properties\n    };\n  }\n};\n\n// TODO - output proper multilinestring\nArc.prototype.wkt = function () {\n  var wkt_string = \"\";\n  var wkt = \"LINESTRING(\";\n  var collect = function (c) {\n    wkt += c[0] + \" \" + c[1] + \",\";\n  };\n  for (var i = 0; i < this.geometries.length; i++) {\n    if (this.geometries[i].coords.length === 0) {\n      return \"LINESTRING(empty)\";\n    } else {\n      var coords = this.geometries[i].coords;\n      coords.forEach(collect);\n      wkt_string += wkt.substring(0, wkt.length - 1) + \")\";\n    }\n  }\n  return wkt_string;\n};\n\n/*\n * http://en.wikipedia.org/wiki/Great-circle_distance\n *\n */\nvar GreatCircle = function (start, end, properties) {\n  if (!start || start.x === undefined || start.y === undefined) {\n    throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n  }\n  if (!end || end.x === undefined || end.y === undefined) {\n    throw new Error(\"GreatCircle constructor expects two args: start and end objects with x and y properties\");\n  }\n  this.start = new Coord(start.x, start.y);\n  this.end = new Coord(end.x, end.y);\n  this.properties = properties || {};\n  var w = this.start.x - this.end.x;\n  var h = this.start.y - this.end.y;\n  var z = Math.pow(Math.sin(h / 2.0), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2.0), 2);\n  this.g = 2.0 * Math.asin(Math.sqrt(z));\n  if (this.g === Math.PI) {\n    throw new Error(\"it appears \" + start.view() + \" and \" + end.view() + \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\");\n  } else if (isNaN(this.g)) {\n    throw new Error(\"could not calculate great circle between \" + start + \" and \" + end);\n  }\n};\n\n/*\n * http://williams.best.vwh.net/avform.htm#Intermediate\n */\nGreatCircle.prototype.interpolate = function (f) {\n  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n  var B = Math.sin(f * this.g) / Math.sin(this.g);\n  var x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);\n  var y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);\n  var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n  var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n  var lon = R2D * Math.atan2(y, x);\n  return [lon, lat];\n};\n\n/*\n * Generate points along the great circle\n */\nGreatCircle.prototype.Arc = function (npoints, options) {\n  var first_pass = [];\n  if (!npoints || npoints <= 2) {\n    first_pass.push([this.start.lon, this.start.lat]);\n    first_pass.push([this.end.lon, this.end.lat]);\n  } else {\n    var delta = 1.0 / (npoints - 1);\n    for (var i = 0; i < npoints; ++i) {\n      var step = delta * i;\n      var pair = this.interpolate(step);\n      first_pass.push(pair);\n    }\n  }\n  /* partial port of dateline handling from:\n      gdal/ogr/ogrgeometryfactory.cpp\n       TODO - does not handle all wrapping scenarios yet\n    */\n  var bHasBigDiff = false;\n  var dfMaxSmallDiffLong = 0;\n  // from http://www.gdal.org/ogr2ogr.html\n  // -datelineoffset:\n  // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)\n  var dfDateLineOffset = options && options.offset ? options.offset : 10;\n  var dfLeftBorderX = 180 - dfDateLineOffset;\n  var dfRightBorderX = -180 + dfDateLineOffset;\n  var dfDiffSpace = 360 - dfDateLineOffset;\n\n  // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342\n  for (var j = 1; j < first_pass.length; ++j) {\n    var dfPrevX = first_pass[j - 1][0];\n    var dfX = first_pass[j][0];\n    var dfDiffLong = Math.abs(dfX - dfPrevX);\n    if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {\n      bHasBigDiff = true;\n    } else if (dfDiffLong > dfMaxSmallDiffLong) {\n      dfMaxSmallDiffLong = dfDiffLong;\n    }\n  }\n  var poMulti = [];\n  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n    var poNewLS = [];\n    poMulti.push(poNewLS);\n    for (var k = 0; k < first_pass.length; ++k) {\n      var dfX0 = parseFloat(first_pass[k][0]);\n      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {\n        var dfX1 = parseFloat(first_pass[k - 1][0]);\n        var dfY1 = parseFloat(first_pass[k - 1][1]);\n        var dfX2 = parseFloat(first_pass[k][0]);\n        var dfY2 = parseFloat(first_pass[k][1]);\n        if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {\n          poNewLS.push([-180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {\n          poNewLS.push([180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        }\n        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {\n          // swap dfX1, dfX2\n          var tmpX = dfX1;\n          dfX1 = dfX2;\n          dfX2 = tmpX;\n          // swap dfY1, dfY2\n          var tmpY = dfY1;\n          dfY1 = dfY2;\n          dfY2 = tmpY;\n        }\n        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n          dfX2 += 360;\n        }\n        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {\n          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n          poNewLS.push([first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180, dfY]);\n          poNewLS = [];\n          poNewLS.push([first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180, dfY]);\n          poMulti.push(poNewLS);\n        } else {\n          poNewLS = [];\n          poMulti.push(poNewLS);\n        }\n        poNewLS.push([dfX0, first_pass[k][1]]);\n      } else {\n        poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n      }\n    }\n  } else {\n    // add normally\n    var poNewLS0 = [];\n    poMulti.push(poNewLS0);\n    for (var l = 0; l < first_pass.length; ++l) {\n      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);\n    }\n  }\n  var arc = new Arc(this.properties);\n  for (var m = 0; m < poMulti.length; ++m) {\n    var line = new LineString();\n    arc.geometries.push(line);\n    var points = poMulti[m];\n    for (var j0 = 0; j0 < points.length; ++j0) {\n      line.move_to(points[j0]);\n    }\n  }\n  return arc;\n};\n\n/**\n * Calculate great circles routes as {@link LineString} or {@link MultiLineString}.\n * If the `start` and `end` points span the antimeridian, the resulting feature will\n * be split into a `MultiLineString`.\n *\n * @name greatCircle\n * @param {Coord} start source point feature\n * @param {Coord} end destination point feature\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] line feature properties\n * @param {number} [options.npoints=100] number of points\n * @param {number} [options.offset=10] offset controls the likelyhood that lines will\n * be split which cross the dateline. The higher the number the more likely.\n * @returns {Feature<LineString | MultiLineString>} great circle line feature\n * @example\n * var start = turf.point([-122, 48]);\n * var end = turf.point([-77, 39]);\n *\n * var greatCircle = turf.greatCircle(start, end, {properties: {name: 'Seattle to DC'}});\n *\n * //addToMap\n * var addToMap = [start, end, greatCircle]\n */\nfunction greatCircle(start, end, options) {\n  // Optional parameters\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var properties = options.properties;\n  var npoints = options.npoints;\n  var offset = options.offset;\n  start = getCoord(start);\n  end = getCoord(end);\n  properties = properties || {};\n  npoints = npoints || 100;\n  offset = offset || 10;\n  var generator = new GreatCircle({\n    x: start[0],\n    y: start[1]\n  }, {\n    x: end[0],\n    y: end[1]\n  }, properties);\n  var line = generator.Arc(npoints, {\n    offset: offset\n  });\n  return line.json();\n}\nexport default greatCircle;","map":{"version":3,"names":["getCoord","D2R","Math","PI","R2D","Coord","lon","lat","x","y","prototype","view","String","slice","antipode","anti_lat","anti_lon","LineString","coords","length","move_to","coord","push","Arc","properties","geometries","json","geometry","type","coordinates","multiline","i","wkt","wkt_string","collect","c","forEach","substring","GreatCircle","start","end","undefined","Error","w","h","z","pow","sin","cos","g","asin","sqrt","isNaN","interpolate","f","A","B","atan2","npoints","options","first_pass","delta","step","pair","bHasBigDiff","dfMaxSmallDiffLong","dfDateLineOffset","offset","dfLeftBorderX","dfRightBorderX","dfDiffSpace","j","dfPrevX","dfX","dfDiffLong","abs","poMulti","poNewLS","k","dfX0","parseFloat","dfX1","dfY1","dfX2","dfY2","tmpX","tmpY","dfRatio","dfY","poNewLS0","l","arc","m","line","points","j0","greatCircle","generator"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/@turf/great-circle/dist/es/index.js"],"sourcesContent":["import { getCoord } from '@turf/invariant';\n\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\n\nvar Coord = function (lon, lat) {\n  this.lon = lon;\n  this.lat = lat;\n  this.x = D2R * lon;\n  this.y = D2R * lat;\n};\n\nCoord.prototype.view = function () {\n  return String(this.lon).slice(0, 4) + \",\" + String(this.lat).slice(0, 4);\n};\n\nCoord.prototype.antipode = function () {\n  var anti_lat = -1 * this.lat;\n  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;\n  return new Coord(anti_lon, anti_lat);\n};\n\nvar LineString = function () {\n  this.coords = [];\n  this.length = 0;\n};\n\nLineString.prototype.move_to = function (coord) {\n  this.length++;\n  this.coords.push(coord);\n};\n\nvar Arc = function (properties) {\n  this.properties = properties || {};\n  this.geometries = [];\n};\n\nArc.prototype.json = function () {\n  if (this.geometries.length <= 0) {\n    return {\n      geometry: { type: \"LineString\", coordinates: null },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  } else if (this.geometries.length === 1) {\n    return {\n      geometry: { type: \"LineString\", coordinates: this.geometries[0].coords },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  } else {\n    var multiline = [];\n    for (var i = 0; i < this.geometries.length; i++) {\n      multiline.push(this.geometries[i].coords);\n    }\n    return {\n      geometry: { type: \"MultiLineString\", coordinates: multiline },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  }\n};\n\n// TODO - output proper multilinestring\nArc.prototype.wkt = function () {\n  var wkt_string = \"\";\n  var wkt = \"LINESTRING(\";\n  var collect = function (c) {\n    wkt += c[0] + \" \" + c[1] + \",\";\n  };\n  for (var i = 0; i < this.geometries.length; i++) {\n    if (this.geometries[i].coords.length === 0) {\n      return \"LINESTRING(empty)\";\n    } else {\n      var coords = this.geometries[i].coords;\n      coords.forEach(collect);\n      wkt_string += wkt.substring(0, wkt.length - 1) + \")\";\n    }\n  }\n  return wkt_string;\n};\n\n/*\n * http://en.wikipedia.org/wiki/Great-circle_distance\n *\n */\nvar GreatCircle = function (start, end, properties) {\n  if (!start || start.x === undefined || start.y === undefined) {\n    throw new Error(\n      \"GreatCircle constructor expects two args: start and end objects with x and y properties\"\n    );\n  }\n  if (!end || end.x === undefined || end.y === undefined) {\n    throw new Error(\n      \"GreatCircle constructor expects two args: start and end objects with x and y properties\"\n    );\n  }\n  this.start = new Coord(start.x, start.y);\n  this.end = new Coord(end.x, end.y);\n  this.properties = properties || {};\n\n  var w = this.start.x - this.end.x;\n  var h = this.start.y - this.end.y;\n  var z =\n    Math.pow(Math.sin(h / 2.0), 2) +\n    Math.cos(this.start.y) *\n      Math.cos(this.end.y) *\n      Math.pow(Math.sin(w / 2.0), 2);\n  this.g = 2.0 * Math.asin(Math.sqrt(z));\n\n  if (this.g === Math.PI) {\n    throw new Error(\n      \"it appears \" +\n        start.view() +\n        \" and \" +\n        end.view() +\n        \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\"\n    );\n  } else if (isNaN(this.g)) {\n    throw new Error(\n      \"could not calculate great circle between \" + start + \" and \" + end\n    );\n  }\n};\n\n/*\n * http://williams.best.vwh.net/avform.htm#Intermediate\n */\nGreatCircle.prototype.interpolate = function (f) {\n  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n  var B = Math.sin(f * this.g) / Math.sin(this.g);\n  var x =\n    A * Math.cos(this.start.y) * Math.cos(this.start.x) +\n    B * Math.cos(this.end.y) * Math.cos(this.end.x);\n  var y =\n    A * Math.cos(this.start.y) * Math.sin(this.start.x) +\n    B * Math.cos(this.end.y) * Math.sin(this.end.x);\n  var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n  var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n  var lon = R2D * Math.atan2(y, x);\n  return [lon, lat];\n};\n\n/*\n * Generate points along the great circle\n */\nGreatCircle.prototype.Arc = function (npoints, options) {\n  var first_pass = [];\n  if (!npoints || npoints <= 2) {\n    first_pass.push([this.start.lon, this.start.lat]);\n    first_pass.push([this.end.lon, this.end.lat]);\n  } else {\n    var delta = 1.0 / (npoints - 1);\n    for (var i = 0; i < npoints; ++i) {\n      var step = delta * i;\n      var pair = this.interpolate(step);\n      first_pass.push(pair);\n    }\n  }\n  /* partial port of dateline handling from:\n      gdal/ogr/ogrgeometryfactory.cpp\n\n      TODO - does not handle all wrapping scenarios yet\n    */\n  var bHasBigDiff = false;\n  var dfMaxSmallDiffLong = 0;\n  // from http://www.gdal.org/ogr2ogr.html\n  // -datelineoffset:\n  // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)\n  var dfDateLineOffset = options && options.offset ? options.offset : 10;\n  var dfLeftBorderX = 180 - dfDateLineOffset;\n  var dfRightBorderX = -180 + dfDateLineOffset;\n  var dfDiffSpace = 360 - dfDateLineOffset;\n\n  // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342\n  for (var j = 1; j < first_pass.length; ++j) {\n    var dfPrevX = first_pass[j - 1][0];\n    var dfX = first_pass[j][0];\n    var dfDiffLong = Math.abs(dfX - dfPrevX);\n    if (\n      dfDiffLong > dfDiffSpace &&\n      ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) ||\n        (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))\n    ) {\n      bHasBigDiff = true;\n    } else if (dfDiffLong > dfMaxSmallDiffLong) {\n      dfMaxSmallDiffLong = dfDiffLong;\n    }\n  }\n\n  var poMulti = [];\n  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n    var poNewLS = [];\n    poMulti.push(poNewLS);\n    for (var k = 0; k < first_pass.length; ++k) {\n      var dfX0 = parseFloat(first_pass[k][0]);\n      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {\n        var dfX1 = parseFloat(first_pass[k - 1][0]);\n        var dfY1 = parseFloat(first_pass[k - 1][1]);\n        var dfX2 = parseFloat(first_pass[k][0]);\n        var dfY2 = parseFloat(first_pass[k][1]);\n        if (\n          dfX1 > -180 &&\n          dfX1 < dfRightBorderX &&\n          dfX2 === 180 &&\n          k + 1 < first_pass.length &&\n          first_pass[k - 1][0] > -180 &&\n          first_pass[k - 1][0] < dfRightBorderX\n        ) {\n          poNewLS.push([-180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        } else if (\n          dfX1 > dfLeftBorderX &&\n          dfX1 < 180 &&\n          dfX2 === -180 &&\n          k + 1 < first_pass.length &&\n          first_pass[k - 1][0] > dfLeftBorderX &&\n          first_pass[k - 1][0] < 180\n        ) {\n          poNewLS.push([180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        }\n\n        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {\n          // swap dfX1, dfX2\n          var tmpX = dfX1;\n          dfX1 = dfX2;\n          dfX2 = tmpX;\n          // swap dfY1, dfY2\n          var tmpY = dfY1;\n          dfY1 = dfY2;\n          dfY2 = tmpY;\n        }\n        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n          dfX2 += 360;\n        }\n\n        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {\n          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n          poNewLS.push([\n            first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,\n            dfY,\n          ]);\n          poNewLS = [];\n          poNewLS.push([\n            first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,\n            dfY,\n          ]);\n          poMulti.push(poNewLS);\n        } else {\n          poNewLS = [];\n          poMulti.push(poNewLS);\n        }\n        poNewLS.push([dfX0, first_pass[k][1]]);\n      } else {\n        poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n      }\n    }\n  } else {\n    // add normally\n    var poNewLS0 = [];\n    poMulti.push(poNewLS0);\n    for (var l = 0; l < first_pass.length; ++l) {\n      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);\n    }\n  }\n\n  var arc = new Arc(this.properties);\n  for (var m = 0; m < poMulti.length; ++m) {\n    var line = new LineString();\n    arc.geometries.push(line);\n    var points = poMulti[m];\n    for (var j0 = 0; j0 < points.length; ++j0) {\n      line.move_to(points[j0]);\n    }\n  }\n  return arc;\n};\n\n/**\n * Calculate great circles routes as {@link LineString} or {@link MultiLineString}.\n * If the `start` and `end` points span the antimeridian, the resulting feature will\n * be split into a `MultiLineString`.\n *\n * @name greatCircle\n * @param {Coord} start source point feature\n * @param {Coord} end destination point feature\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] line feature properties\n * @param {number} [options.npoints=100] number of points\n * @param {number} [options.offset=10] offset controls the likelyhood that lines will\n * be split which cross the dateline. The higher the number the more likely.\n * @returns {Feature<LineString | MultiLineString>} great circle line feature\n * @example\n * var start = turf.point([-122, 48]);\n * var end = turf.point([-77, 39]);\n *\n * var greatCircle = turf.greatCircle(start, end, {properties: {name: 'Seattle to DC'}});\n *\n * //addToMap\n * var addToMap = [start, end, greatCircle]\n */\nfunction greatCircle(start, end, options) {\n  // Optional parameters\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var properties = options.properties;\n  var npoints = options.npoints;\n  var offset = options.offset;\n\n  start = getCoord(start);\n  end = getCoord(end);\n  properties = properties || {};\n  npoints = npoints || 100;\n  offset = offset || 10;\n\n  var generator = new GreatCircle(\n    { x: start[0], y: start[1] },\n    { x: end[0], y: end[1] },\n    properties\n  );\n\n  var line = generator.Arc(npoints, { offset: offset });\n\n  return line.json();\n}\n\nexport default greatCircle;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}