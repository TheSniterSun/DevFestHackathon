{"ast":null,"code":"'use strict';\n\nvar dsv = require('d3-dsv'),\n  sexagesimal = require('@mapbox/sexagesimal');\nvar latRegex = /(Lat)(itude)?/gi,\n  lonRegex = /(L)(on|ng)(gitude)?/i;\nfunction guessHeader(row, regexp) {\n  var name, match, score;\n  for (var f in row) {\n    match = f.match(regexp);\n    if (match && (!name || match[0].length / f.length > score)) {\n      score = match[0].length / f.length;\n      name = f;\n    }\n  }\n  return name;\n}\nfunction guessLatHeader(row) {\n  return guessHeader(row, latRegex);\n}\nfunction guessLonHeader(row) {\n  return guessHeader(row, lonRegex);\n}\nfunction isLat(f) {\n  return !!f.match(latRegex);\n}\nfunction isLon(f) {\n  return !!f.match(lonRegex);\n}\nfunction keyCount(o) {\n  return typeof o == 'object' ? Object.keys(o).length : 0;\n}\nfunction autoDelimiter(x) {\n  var delimiters = [',', ';', '\\t', '|'];\n  var results = [];\n  delimiters.forEach(function (delimiter) {\n    var res = dsv.dsvFormat(delimiter).parse(x);\n    if (res.length >= 1) {\n      var count = keyCount(res[0]);\n      for (var i = 0; i < res.length; i++) {\n        if (keyCount(res[i]) !== count) return;\n      }\n      results.push({\n        delimiter: delimiter,\n        arity: Object.keys(res[0]).length\n      });\n    }\n  });\n  if (results.length) {\n    return results.sort(function (a, b) {\n      return b.arity - a.arity;\n    })[0].delimiter;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Silly stopgap for dsv to d3-dsv upgrade\n *\n * @param {Array} x dsv output\n * @returns {Array} array without columns member\n */\nfunction deleteColumns(x) {\n  delete x.columns;\n  return x;\n}\nfunction auto(x) {\n  var delimiter = autoDelimiter(x);\n  if (!delimiter) return null;\n  return deleteColumns(dsv.dsvFormat(delimiter).parse(x));\n}\nfunction csv2geojson(x, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n  options.delimiter = options.delimiter || ',';\n  var latfield = options.latfield || '',\n    lonfield = options.lonfield || '',\n    crs = options.crs || '';\n  var features = [],\n    featurecollection = {\n      type: 'FeatureCollection',\n      features: features\n    };\n  if (crs !== '') {\n    featurecollection.crs = {\n      type: 'name',\n      properties: {\n        name: crs\n      }\n    };\n  }\n  if (options.delimiter === 'auto' && typeof x == 'string') {\n    options.delimiter = autoDelimiter(x);\n    if (!options.delimiter) {\n      callback({\n        type: 'Error',\n        message: 'Could not autodetect delimiter'\n      });\n      return;\n    }\n  }\n  var numericFields = options.numericFields ? options.numericFields.split(',') : null;\n  var parsed = typeof x == 'string' ? dsv.dsvFormat(options.delimiter).parse(x, function (d) {\n    if (numericFields) {\n      for (var key in d) {\n        if (numericFields.includes(key)) {\n          d[key] = +d[key];\n        }\n      }\n    }\n    return d;\n  }) : x;\n  if (!parsed.length) {\n    callback(null, featurecollection);\n    return;\n  }\n  var errors = [];\n  var i;\n  if (!latfield) latfield = guessLatHeader(parsed[0]);\n  if (!lonfield) lonfield = guessLonHeader(parsed[0]);\n  var noGeometry = !latfield || !lonfield;\n  if (noGeometry) {\n    for (i = 0; i < parsed.length; i++) {\n      features.push({\n        type: 'Feature',\n        properties: parsed[i],\n        geometry: null\n      });\n    }\n    callback(errors.length ? errors : null, featurecollection);\n    return;\n  }\n  for (i = 0; i < parsed.length; i++) {\n    if (parsed[i][lonfield] !== undefined && parsed[i][latfield] !== undefined) {\n      var lonk = parsed[i][lonfield],\n        latk = parsed[i][latfield],\n        lonf,\n        latf,\n        a;\n      a = sexagesimal(lonk, 'EW');\n      if (a) lonk = a;\n      a = sexagesimal(latk, 'NS');\n      if (a) latk = a;\n      lonf = parseFloat(lonk);\n      latf = parseFloat(latk);\n      if (isNaN(lonf) || isNaN(latf)) {\n        errors.push({\n          message: 'A row contained an invalid value for latitude or longitude',\n          row: parsed[i],\n          index: i\n        });\n      } else {\n        if (!options.includeLatLon) {\n          delete parsed[i][lonfield];\n          delete parsed[i][latfield];\n        }\n        features.push({\n          type: 'Feature',\n          properties: parsed[i],\n          geometry: {\n            type: 'Point',\n            coordinates: [parseFloat(lonf), parseFloat(latf)]\n          }\n        });\n      }\n    }\n  }\n  callback(errors.length ? errors : null, featurecollection);\n}\nfunction toLine(gj) {\n  var features = gj.features;\n  var line = {\n    type: 'Feature',\n    geometry: {\n      type: 'LineString',\n      coordinates: []\n    }\n  };\n  for (var i = 0; i < features.length; i++) {\n    line.geometry.coordinates.push(features[i].geometry.coordinates);\n  }\n  line.properties = features.reduce(function (aggregatedProperties, newFeature) {\n    for (var key in newFeature.properties) {\n      if (!aggregatedProperties[key]) {\n        aggregatedProperties[key] = [];\n      }\n      aggregatedProperties[key].push(newFeature.properties[key]);\n    }\n    return aggregatedProperties;\n  }, {});\n  return {\n    type: 'FeatureCollection',\n    features: [line]\n  };\n}\nfunction toPolygon(gj) {\n  var features = gj.features;\n  var poly = {\n    type: 'Feature',\n    geometry: {\n      type: 'Polygon',\n      coordinates: [[]]\n    }\n  };\n  for (var i = 0; i < features.length; i++) {\n    poly.geometry.coordinates[0].push(features[i].geometry.coordinates);\n  }\n  poly.properties = features.reduce(function (aggregatedProperties, newFeature) {\n    for (var key in newFeature.properties) {\n      if (!aggregatedProperties[key]) {\n        aggregatedProperties[key] = [];\n      }\n      aggregatedProperties[key].push(newFeature.properties[key]);\n    }\n    return aggregatedProperties;\n  }, {});\n  return {\n    type: 'FeatureCollection',\n    features: [poly]\n  };\n}\nmodule.exports = {\n  isLon: isLon,\n  isLat: isLat,\n  guessLatHeader: guessLatHeader,\n  guessLonHeader: guessLonHeader,\n  csv: dsv.csvParse,\n  tsv: dsv.tsvParse,\n  dsv: dsv,\n  auto: auto,\n  csv2geojson: csv2geojson,\n  toLine: toLine,\n  toPolygon: toPolygon\n};","map":{"version":3,"names":["dsv","require","sexagesimal","latRegex","lonRegex","guessHeader","row","regexp","name","match","score","f","length","guessLatHeader","guessLonHeader","isLat","isLon","keyCount","o","Object","keys","autoDelimiter","x","delimiters","results","forEach","delimiter","res","dsvFormat","parse","count","i","push","arity","sort","a","b","deleteColumns","columns","auto","csv2geojson","options","callback","latfield","lonfield","crs","features","featurecollection","type","properties","message","numericFields","split","parsed","d","key","includes","errors","noGeometry","geometry","undefined","lonk","latk","lonf","latf","parseFloat","isNaN","index","includeLatLon","coordinates","toLine","gj","line","reduce","aggregatedProperties","newFeature","toPolygon","poly","module","exports","csv","csvParse","tsv","tsvParse"],"sources":["/Users/brandonpae/Desktop/DevFestHackathon/frontend/node_modules/csv2geojson/index.js"],"sourcesContent":["'use strict';\n\nvar dsv = require('d3-dsv'),\n    sexagesimal = require('@mapbox/sexagesimal');\n\nvar latRegex = /(Lat)(itude)?/gi,\n    lonRegex = /(L)(on|ng)(gitude)?/i;\n\nfunction guessHeader(row, regexp) {\n    var name, match, score;\n    for (var f in row) {\n        match = f.match(regexp);\n        if (match && (!name || match[0].length / f.length > score)) {\n            score = match[0].length / f.length;\n            name = f;\n        }\n    }\n    return name;\n}\n\nfunction guessLatHeader(row) { return guessHeader(row, latRegex); }\nfunction guessLonHeader(row) { return guessHeader(row, lonRegex); }\n\nfunction isLat(f) { return !!f.match(latRegex); }\nfunction isLon(f) { return !!f.match(lonRegex); }\n\nfunction keyCount(o) {\n    return (typeof o == 'object') ? Object.keys(o).length : 0;\n}\n\nfunction autoDelimiter(x) {\n    var delimiters = [',', ';', '\\t', '|'];\n    var results = [];\n\n    delimiters.forEach(function (delimiter) {\n        var res = dsv.dsvFormat(delimiter).parse(x);\n        if (res.length >= 1) {\n            var count = keyCount(res[0]);\n            for (var i = 0; i < res.length; i++) {\n                if (keyCount(res[i]) !== count) return;\n            }\n            results.push({\n                delimiter: delimiter,\n                arity: Object.keys(res[0]).length,\n            });\n        }\n    });\n\n    if (results.length) {\n        return results.sort(function (a, b) {\n            return b.arity - a.arity;\n        })[0].delimiter;\n    } else {\n        return null;\n    }\n}\n\n/**\n * Silly stopgap for dsv to d3-dsv upgrade\n *\n * @param {Array} x dsv output\n * @returns {Array} array without columns member\n */\nfunction deleteColumns(x) {\n    delete x.columns;\n    return x;\n}\n\nfunction auto(x) {\n    var delimiter = autoDelimiter(x);\n    if (!delimiter) return null;\n    return deleteColumns(dsv.dsvFormat(delimiter).parse(x));\n}\n\nfunction csv2geojson(x, options, callback) {\n\n    if (!callback) {\n        callback = options;\n        options = {};\n    }\n\n    options.delimiter = options.delimiter || ',';\n\n    var latfield = options.latfield || '',\n        lonfield = options.lonfield || '',\n        crs = options.crs || '';\n\n    var features = [],\n        featurecollection = {type: 'FeatureCollection', features: features};\n\n    if (crs !== '') {\n        featurecollection.crs = {type: 'name', properties: {name: crs}};\n    }\n\n    if (options.delimiter === 'auto' && typeof x == 'string') {\n        options.delimiter = autoDelimiter(x);\n        if (!options.delimiter) {\n            callback({\n                type: 'Error',\n                message: 'Could not autodetect delimiter'\n            });\n            return;\n        }\n    }\n\n    var numericFields = options.numericFields ? options.numericFields.split(',') : null;\n\n    var parsed = (typeof x == 'string') ?\n        dsv.dsvFormat(options.delimiter).parse(x, function (d) {\n            if (numericFields) {\n                for (var key in d) {\n                    if (numericFields.includes(key)) {\n                        d[key] = +d[key];\n                    }\n                }\n            }\n            return d;\n        }) : x;\n\n    if (!parsed.length) {\n        callback(null, featurecollection);\n        return;\n    }\n\n    var errors = [];\n    var i;\n\n\n    if (!latfield) latfield = guessLatHeader(parsed[0]);\n    if (!lonfield) lonfield = guessLonHeader(parsed[0]);\n    var noGeometry = (!latfield || !lonfield);\n\n    if (noGeometry) {\n        for (i = 0; i < parsed.length; i++) {\n            features.push({\n                type: 'Feature',\n                properties: parsed[i],\n                geometry: null\n            });\n        }\n        callback(errors.length ? errors : null, featurecollection);\n        return;\n    }\n\n    for (i = 0; i < parsed.length; i++) {\n        if (parsed[i][lonfield] !== undefined &&\n            parsed[i][latfield] !== undefined) {\n\n            var lonk = parsed[i][lonfield],\n                latk = parsed[i][latfield],\n                lonf, latf,\n                a;\n\n            a = sexagesimal(lonk, 'EW');\n            if (a) lonk = a;\n            a = sexagesimal(latk, 'NS');\n            if (a) latk = a;\n\n            lonf = parseFloat(lonk);\n            latf = parseFloat(latk);\n\n            if (isNaN(lonf) ||\n                isNaN(latf)) {\n                errors.push({\n                    message: 'A row contained an invalid value for latitude or longitude',\n                    row: parsed[i],\n                    index: i\n                });\n            } else {\n                if (!options.includeLatLon) {\n                    delete parsed[i][lonfield];\n                    delete parsed[i][latfield];\n                }\n\n                features.push({\n                    type: 'Feature',\n                    properties: parsed[i],\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [\n                            parseFloat(lonf),\n                            parseFloat(latf)\n                        ]\n                    }\n                });\n            }\n        }\n    }\n\n    callback(errors.length ? errors : null, featurecollection);\n}\n\nfunction toLine(gj) {\n    var features = gj.features;\n    var line = {\n        type: 'Feature',\n        geometry: {\n            type: 'LineString',\n            coordinates: []\n        }\n    };\n    for (var i = 0; i < features.length; i++) {\n        line.geometry.coordinates.push(features[i].geometry.coordinates);\n    }\n    line.properties = features.reduce(function (aggregatedProperties, newFeature) {\n        for (var key in newFeature.properties) {\n            if (!aggregatedProperties[key]) {\n                aggregatedProperties[key] = [];\n            }\n            aggregatedProperties[key].push(newFeature.properties[key]);\n        }\n        return aggregatedProperties;\n    }, {});\n    return {\n        type: 'FeatureCollection',\n        features: [line]\n    };\n}\n\nfunction toPolygon(gj) {\n    var features = gj.features;\n    var poly = {\n        type: 'Feature',\n        geometry: {\n            type: 'Polygon',\n            coordinates: [[]]\n        }\n    };\n    for (var i = 0; i < features.length; i++) {\n        poly.geometry.coordinates[0].push(features[i].geometry.coordinates);\n    }\n    poly.properties = features.reduce(function (aggregatedProperties, newFeature) {\n        for (var key in newFeature.properties) {\n            if (!aggregatedProperties[key]) {\n                aggregatedProperties[key] = [];\n            }\n            aggregatedProperties[key].push(newFeature.properties[key]);\n        }\n        return aggregatedProperties;\n    }, {});\n    return {\n        type: 'FeatureCollection',\n        features: [poly]\n    };\n}\n\nmodule.exports = {\n    isLon: isLon,\n    isLat: isLat,\n    guessLatHeader: guessLatHeader,\n    guessLonHeader: guessLonHeader,\n    csv: dsv.csvParse,\n    tsv: dsv.tsvParse,\n    dsv: dsv,\n    auto: auto,\n    csv2geojson: csv2geojson,\n    toLine: toLine,\n    toPolygon: toPolygon\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,GAAG,GAAGC,OAAO,CAAC,QAAQ,CAAC;EACvBC,WAAW,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAEhD,IAAIE,QAAQ,GAAG,iBAAiB;EAC5BC,QAAQ,GAAG,sBAAsB;AAErC,SAASC,WAAWA,CAACC,GAAG,EAAEC,MAAM,EAAE;EAC9B,IAAIC,IAAI,EAAEC,KAAK,EAAEC,KAAK;EACtB,KAAK,IAAIC,CAAC,IAAIL,GAAG,EAAE;IACfG,KAAK,GAAGE,CAAC,CAACF,KAAK,CAACF,MAAM,CAAC;IACvB,IAAIE,KAAK,KAAK,CAACD,IAAI,IAAIC,KAAK,CAAC,CAAC,CAAC,CAACG,MAAM,GAAGD,CAAC,CAACC,MAAM,GAAGF,KAAK,CAAC,EAAE;MACxDA,KAAK,GAAGD,KAAK,CAAC,CAAC,CAAC,CAACG,MAAM,GAAGD,CAAC,CAACC,MAAM;MAClCJ,IAAI,GAAGG,CAAC;IACZ;EACJ;EACA,OAAOH,IAAI;AACf;AAEA,SAASK,cAAcA,CAACP,GAAG,EAAE;EAAE,OAAOD,WAAW,CAACC,GAAG,EAAEH,QAAQ,CAAC;AAAE;AAClE,SAASW,cAAcA,CAACR,GAAG,EAAE;EAAE,OAAOD,WAAW,CAACC,GAAG,EAAEF,QAAQ,CAAC;AAAE;AAElE,SAASW,KAAKA,CAACJ,CAAC,EAAE;EAAE,OAAO,CAAC,CAACA,CAAC,CAACF,KAAK,CAACN,QAAQ,CAAC;AAAE;AAChD,SAASa,KAAKA,CAACL,CAAC,EAAE;EAAE,OAAO,CAAC,CAACA,CAAC,CAACF,KAAK,CAACL,QAAQ,CAAC;AAAE;AAEhD,SAASa,QAAQA,CAACC,CAAC,EAAE;EACjB,OAAQ,OAAOA,CAAC,IAAI,QAAQ,GAAIC,MAAM,CAACC,IAAI,CAACF,CAAC,CAAC,CAACN,MAAM,GAAG,CAAC;AAC7D;AAEA,SAASS,aAAaA,CAACC,CAAC,EAAE;EACtB,IAAIC,UAAU,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC;EACtC,IAAIC,OAAO,GAAG,EAAE;EAEhBD,UAAU,CAACE,OAAO,CAAC,UAAUC,SAAS,EAAE;IACpC,IAAIC,GAAG,GAAG3B,GAAG,CAAC4B,SAAS,CAACF,SAAS,CAAC,CAACG,KAAK,CAACP,CAAC,CAAC;IAC3C,IAAIK,GAAG,CAACf,MAAM,IAAI,CAAC,EAAE;MACjB,IAAIkB,KAAK,GAAGb,QAAQ,CAACU,GAAG,CAAC,CAAC,CAAC,CAAC;MAC5B,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACf,MAAM,EAAEmB,CAAC,EAAE,EAAE;QACjC,IAAId,QAAQ,CAACU,GAAG,CAACI,CAAC,CAAC,CAAC,KAAKD,KAAK,EAAE;MACpC;MACAN,OAAO,CAACQ,IAAI,CAAC;QACTN,SAAS,EAAEA,SAAS;QACpBO,KAAK,EAAEd,MAAM,CAACC,IAAI,CAACO,GAAG,CAAC,CAAC,CAAC,CAAC,CAACf;MAC/B,CAAC,CAAC;IACN;EACJ,CAAC,CAAC;EAEF,IAAIY,OAAO,CAACZ,MAAM,EAAE;IAChB,OAAOY,OAAO,CAACU,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MAChC,OAAOA,CAAC,CAACH,KAAK,GAAGE,CAAC,CAACF,KAAK;IAC5B,CAAC,CAAC,CAAC,CAAC,CAAC,CAACP,SAAS;EACnB,CAAC,MAAM;IACH,OAAO,IAAI;EACf;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,aAAaA,CAACf,CAAC,EAAE;EACtB,OAAOA,CAAC,CAACgB,OAAO;EAChB,OAAOhB,CAAC;AACZ;AAEA,SAASiB,IAAIA,CAACjB,CAAC,EAAE;EACb,IAAII,SAAS,GAAGL,aAAa,CAACC,CAAC,CAAC;EAChC,IAAI,CAACI,SAAS,EAAE,OAAO,IAAI;EAC3B,OAAOW,aAAa,CAACrC,GAAG,CAAC4B,SAAS,CAACF,SAAS,CAAC,CAACG,KAAK,CAACP,CAAC,CAAC,CAAC;AAC3D;AAEA,SAASkB,WAAWA,CAAClB,CAAC,EAAEmB,OAAO,EAAEC,QAAQ,EAAE;EAEvC,IAAI,CAACA,QAAQ,EAAE;IACXA,QAAQ,GAAGD,OAAO;IAClBA,OAAO,GAAG,CAAC,CAAC;EAChB;EAEAA,OAAO,CAACf,SAAS,GAAGe,OAAO,CAACf,SAAS,IAAI,GAAG;EAE5C,IAAIiB,QAAQ,GAAGF,OAAO,CAACE,QAAQ,IAAI,EAAE;IACjCC,QAAQ,GAAGH,OAAO,CAACG,QAAQ,IAAI,EAAE;IACjCC,GAAG,GAAGJ,OAAO,CAACI,GAAG,IAAI,EAAE;EAE3B,IAAIC,QAAQ,GAAG,EAAE;IACbC,iBAAiB,GAAG;MAACC,IAAI,EAAE,mBAAmB;MAAEF,QAAQ,EAAEA;IAAQ,CAAC;EAEvE,IAAID,GAAG,KAAK,EAAE,EAAE;IACZE,iBAAiB,CAACF,GAAG,GAAG;MAACG,IAAI,EAAE,MAAM;MAAEC,UAAU,EAAE;QAACzC,IAAI,EAAEqC;MAAG;IAAC,CAAC;EACnE;EAEA,IAAIJ,OAAO,CAACf,SAAS,KAAK,MAAM,IAAI,OAAOJ,CAAC,IAAI,QAAQ,EAAE;IACtDmB,OAAO,CAACf,SAAS,GAAGL,aAAa,CAACC,CAAC,CAAC;IACpC,IAAI,CAACmB,OAAO,CAACf,SAAS,EAAE;MACpBgB,QAAQ,CAAC;QACLM,IAAI,EAAE,OAAO;QACbE,OAAO,EAAE;MACb,CAAC,CAAC;MACF;IACJ;EACJ;EAEA,IAAIC,aAAa,GAAGV,OAAO,CAACU,aAAa,GAAGV,OAAO,CAACU,aAAa,CAACC,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI;EAEnF,IAAIC,MAAM,GAAI,OAAO/B,CAAC,IAAI,QAAQ,GAC9BtB,GAAG,CAAC4B,SAAS,CAACa,OAAO,CAACf,SAAS,CAAC,CAACG,KAAK,CAACP,CAAC,EAAE,UAAUgC,CAAC,EAAE;IACnD,IAAIH,aAAa,EAAE;MACf,KAAK,IAAII,GAAG,IAAID,CAAC,EAAE;QACf,IAAIH,aAAa,CAACK,QAAQ,CAACD,GAAG,CAAC,EAAE;UAC7BD,CAAC,CAACC,GAAG,CAAC,GAAG,CAACD,CAAC,CAACC,GAAG,CAAC;QACpB;MACJ;IACJ;IACA,OAAOD,CAAC;EACZ,CAAC,CAAC,GAAGhC,CAAC;EAEV,IAAI,CAAC+B,MAAM,CAACzC,MAAM,EAAE;IAChB8B,QAAQ,CAAC,IAAI,EAAEK,iBAAiB,CAAC;IACjC;EACJ;EAEA,IAAIU,MAAM,GAAG,EAAE;EACf,IAAI1B,CAAC;EAGL,IAAI,CAACY,QAAQ,EAAEA,QAAQ,GAAG9B,cAAc,CAACwC,MAAM,CAAC,CAAC,CAAC,CAAC;EACnD,IAAI,CAACT,QAAQ,EAAEA,QAAQ,GAAG9B,cAAc,CAACuC,MAAM,CAAC,CAAC,CAAC,CAAC;EACnD,IAAIK,UAAU,GAAI,CAACf,QAAQ,IAAI,CAACC,QAAS;EAEzC,IAAIc,UAAU,EAAE;IACZ,KAAK3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,MAAM,CAACzC,MAAM,EAAEmB,CAAC,EAAE,EAAE;MAChCe,QAAQ,CAACd,IAAI,CAAC;QACVgB,IAAI,EAAE,SAAS;QACfC,UAAU,EAAEI,MAAM,CAACtB,CAAC,CAAC;QACrB4B,QAAQ,EAAE;MACd,CAAC,CAAC;IACN;IACAjB,QAAQ,CAACe,MAAM,CAAC7C,MAAM,GAAG6C,MAAM,GAAG,IAAI,EAAEV,iBAAiB,CAAC;IAC1D;EACJ;EAEA,KAAKhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,MAAM,CAACzC,MAAM,EAAEmB,CAAC,EAAE,EAAE;IAChC,IAAIsB,MAAM,CAACtB,CAAC,CAAC,CAACa,QAAQ,CAAC,KAAKgB,SAAS,IACjCP,MAAM,CAACtB,CAAC,CAAC,CAACY,QAAQ,CAAC,KAAKiB,SAAS,EAAE;MAEnC,IAAIC,IAAI,GAAGR,MAAM,CAACtB,CAAC,CAAC,CAACa,QAAQ,CAAC;QAC1BkB,IAAI,GAAGT,MAAM,CAACtB,CAAC,CAAC,CAACY,QAAQ,CAAC;QAC1BoB,IAAI;QAAEC,IAAI;QACV7B,CAAC;MAELA,CAAC,GAAGjC,WAAW,CAAC2D,IAAI,EAAE,IAAI,CAAC;MAC3B,IAAI1B,CAAC,EAAE0B,IAAI,GAAG1B,CAAC;MACfA,CAAC,GAAGjC,WAAW,CAAC4D,IAAI,EAAE,IAAI,CAAC;MAC3B,IAAI3B,CAAC,EAAE2B,IAAI,GAAG3B,CAAC;MAEf4B,IAAI,GAAGE,UAAU,CAACJ,IAAI,CAAC;MACvBG,IAAI,GAAGC,UAAU,CAACH,IAAI,CAAC;MAEvB,IAAII,KAAK,CAACH,IAAI,CAAC,IACXG,KAAK,CAACF,IAAI,CAAC,EAAE;QACbP,MAAM,CAACzB,IAAI,CAAC;UACRkB,OAAO,EAAE,4DAA4D;UACrE5C,GAAG,EAAE+C,MAAM,CAACtB,CAAC,CAAC;UACdoC,KAAK,EAAEpC;QACX,CAAC,CAAC;MACN,CAAC,MAAM;QACH,IAAI,CAACU,OAAO,CAAC2B,aAAa,EAAE;UACxB,OAAOf,MAAM,CAACtB,CAAC,CAAC,CAACa,QAAQ,CAAC;UAC1B,OAAOS,MAAM,CAACtB,CAAC,CAAC,CAACY,QAAQ,CAAC;QAC9B;QAEAG,QAAQ,CAACd,IAAI,CAAC;UACVgB,IAAI,EAAE,SAAS;UACfC,UAAU,EAAEI,MAAM,CAACtB,CAAC,CAAC;UACrB4B,QAAQ,EAAE;YACNX,IAAI,EAAE,OAAO;YACbqB,WAAW,EAAE,CACTJ,UAAU,CAACF,IAAI,CAAC,EAChBE,UAAU,CAACD,IAAI,CAAC;UAExB;QACJ,CAAC,CAAC;MACN;IACJ;EACJ;EAEAtB,QAAQ,CAACe,MAAM,CAAC7C,MAAM,GAAG6C,MAAM,GAAG,IAAI,EAAEV,iBAAiB,CAAC;AAC9D;AAEA,SAASuB,MAAMA,CAACC,EAAE,EAAE;EAChB,IAAIzB,QAAQ,GAAGyB,EAAE,CAACzB,QAAQ;EAC1B,IAAI0B,IAAI,GAAG;IACPxB,IAAI,EAAE,SAAS;IACfW,QAAQ,EAAE;MACNX,IAAI,EAAE,YAAY;MAClBqB,WAAW,EAAE;IACjB;EACJ,CAAC;EACD,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,QAAQ,CAAClC,MAAM,EAAEmB,CAAC,EAAE,EAAE;IACtCyC,IAAI,CAACb,QAAQ,CAACU,WAAW,CAACrC,IAAI,CAACc,QAAQ,CAACf,CAAC,CAAC,CAAC4B,QAAQ,CAACU,WAAW,CAAC;EACpE;EACAG,IAAI,CAACvB,UAAU,GAAGH,QAAQ,CAAC2B,MAAM,CAAC,UAAUC,oBAAoB,EAAEC,UAAU,EAAE;IAC1E,KAAK,IAAIpB,GAAG,IAAIoB,UAAU,CAAC1B,UAAU,EAAE;MACnC,IAAI,CAACyB,oBAAoB,CAACnB,GAAG,CAAC,EAAE;QAC5BmB,oBAAoB,CAACnB,GAAG,CAAC,GAAG,EAAE;MAClC;MACAmB,oBAAoB,CAACnB,GAAG,CAAC,CAACvB,IAAI,CAAC2C,UAAU,CAAC1B,UAAU,CAACM,GAAG,CAAC,CAAC;IAC9D;IACA,OAAOmB,oBAAoB;EAC/B,CAAC,EAAE,CAAC,CAAC,CAAC;EACN,OAAO;IACH1B,IAAI,EAAE,mBAAmB;IACzBF,QAAQ,EAAE,CAAC0B,IAAI;EACnB,CAAC;AACL;AAEA,SAASI,SAASA,CAACL,EAAE,EAAE;EACnB,IAAIzB,QAAQ,GAAGyB,EAAE,CAACzB,QAAQ;EAC1B,IAAI+B,IAAI,GAAG;IACP7B,IAAI,EAAE,SAAS;IACfW,QAAQ,EAAE;MACNX,IAAI,EAAE,SAAS;MACfqB,WAAW,EAAE,CAAC,EAAE;IACpB;EACJ,CAAC;EACD,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,QAAQ,CAAClC,MAAM,EAAEmB,CAAC,EAAE,EAAE;IACtC8C,IAAI,CAAClB,QAAQ,CAACU,WAAW,CAAC,CAAC,CAAC,CAACrC,IAAI,CAACc,QAAQ,CAACf,CAAC,CAAC,CAAC4B,QAAQ,CAACU,WAAW,CAAC;EACvE;EACAQ,IAAI,CAAC5B,UAAU,GAAGH,QAAQ,CAAC2B,MAAM,CAAC,UAAUC,oBAAoB,EAAEC,UAAU,EAAE;IAC1E,KAAK,IAAIpB,GAAG,IAAIoB,UAAU,CAAC1B,UAAU,EAAE;MACnC,IAAI,CAACyB,oBAAoB,CAACnB,GAAG,CAAC,EAAE;QAC5BmB,oBAAoB,CAACnB,GAAG,CAAC,GAAG,EAAE;MAClC;MACAmB,oBAAoB,CAACnB,GAAG,CAAC,CAACvB,IAAI,CAAC2C,UAAU,CAAC1B,UAAU,CAACM,GAAG,CAAC,CAAC;IAC9D;IACA,OAAOmB,oBAAoB;EAC/B,CAAC,EAAE,CAAC,CAAC,CAAC;EACN,OAAO;IACH1B,IAAI,EAAE,mBAAmB;IACzBF,QAAQ,EAAE,CAAC+B,IAAI;EACnB,CAAC;AACL;AAEAC,MAAM,CAACC,OAAO,GAAG;EACb/D,KAAK,EAAEA,KAAK;EACZD,KAAK,EAAEA,KAAK;EACZF,cAAc,EAAEA,cAAc;EAC9BC,cAAc,EAAEA,cAAc;EAC9BkE,GAAG,EAAEhF,GAAG,CAACiF,QAAQ;EACjBC,GAAG,EAAElF,GAAG,CAACmF,QAAQ;EACjBnF,GAAG,EAAEA,GAAG;EACRuC,IAAI,EAAEA,IAAI;EACVC,WAAW,EAAEA,WAAW;EACxB8B,MAAM,EAAEA,MAAM;EACdM,SAAS,EAAEA;AACf,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}